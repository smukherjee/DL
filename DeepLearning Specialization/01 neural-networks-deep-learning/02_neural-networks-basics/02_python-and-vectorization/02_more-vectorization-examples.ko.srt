1
00:00:00,000 --> 00:00:05,340
이전 비디오에서 vectorization이 
내장된 기능을 이용하고

2
00:00:05,340 --> 00:00:07,770
일정한 for-loop 사용을 피하여

3
00:00:07,770 --> 00:00:11,130
코드의 속도를 높일 수 있는 몇 가지 예를 보셨을 겁니다

4
00:00:11,130 --> 00:00:13,558
또 다른 예시를 보겠습니다.

5
00:00:13,558 --> 00:00:16,110
새로운 네트워크를 프로그래밍하는데 있어 또는

6
00:00:16,110 --> 00:00:19,792
회귀를 프로그래밍 하는데 있어 경험을 근거한 규칙은

7
00:00:19,792 --> 00:00:23,190
가능한 한 일정한 for-loop를 피하는 것입니다.

8
00:00:23,190 --> 00:00:27,285
for-loop를 완전히 사용하지 않는 
것은 항상 가능한 것은 아닌데요,

9
00:00:27,285 --> 00:00:29,520
가능하면 내장된 기능을 이용하거나

10
00:00:29,520 --> 00:00:32,710
계산을 필요로 하는 경우, 다른 방법을 찾으면

11
00:00:32,710 --> 00:00:36,555
일정한 for-loop가 있는 것보다 
훨씬 더 빨리 처리가 가능할 것입니다.

12
00:00:36,555 --> 00:00:38,445
다른 예제를 보시죠.

13
00:00:38,445 --> 00:00:44,412
A 매트릭스의 곱셈으로 언제든 
벡터 u를 계산하고 싶은 경우에는,

14
00:00:44,412 --> 00:00:46,144
그리고 벡터 v를 계산하고 싶은 경우에는,

15
00:00:46,144 --> 00:00:50,840
매트릭스 곱셈의 정의는

16
00:00:50,840 --> 00:00:55,830
Ui= ∑/j, A/j , V/j 합니다.

17
00:00:55,830 --> 00:00:57,050
좋아요.

18
00:00:57,050 --> 00:00:58,445
이렇게 Ui를 정의합니다.

19
00:00:58,445 --> 00:01:01,500
그렇게해서 non-vector형 도입은

20
00:01:01,500 --> 00:01:06,140
U= np.zeros(n, 1)가 되도록 설정하는 것입니다.

21
00:01:06,140 --> 00:01:08,105
(n, i) 이죠.

22
00:01:08,105 --> 00:01:11,745
i에 대해서 말이죠.

23
00:01:11,745 --> 00:01:14,250
이것은 j에 대해서 이고요.

24
00:01:14,250 --> 00:01:22,950
그러면 u[i] + a[i][j] 곱하기 v[j]가 됩니다.

25
00:01:22,950 --> 00:01:27,725
그러면 이것이 2개의 for-loop인데요, 
I와 j를 looping하고 있습니다.

26
00:01:27,725 --> 00:01:29,269
I와 j를 looping하고 있습니다.

27
00:01:29,269 --> 00:01:37,355
u= np.(A, v)가 되도록 벡터 
형으로 도입한 경우입니다.

28
00:01:37,355 --> 00:01:39,160
오른쪽처럼 벡터형 버전으로 도입한 것은

29
00:01:39,160 --> 00:01:41,655
2개의 다른 for-loop를 제거하고

30
00:01:41,655 --> 00:01:44,628
훨씬 더 빨라질 것입니다.

31
00:01:44,628 --> 00:01:46,655
다른 사례를 보겠습니다. 

32
00:01:46,655 --> 00:01:50,900
v라는 벡터가 이미 메모리에 있다고 해봅시다.

33
00:01:50,900 --> 00:01:55,190
지수의 방법을 벡터 v의 모든 
요소에 적용시키고 싶습니다.

34
00:01:55,190 --> 00:01:59,250
그러면 u가 벡터가 되게 해서, 즉 e의 v1승,

35
00:01:59,250 --> 00:02:04,085
e의 v2, 등등 e의 vn승이 될 때까지요.

36
00:02:04,085 --> 00:02:10,370
이것이 논벡터형 도입인데요.

37
00:02:10,370 --> 00:02:13,700
처음에는 u의 벡터 0으로 초기화를 시킵니다.

38
00:02:13,700 --> 00:02:18,260
그 다음, for-loop이 
요소들을 각각 1개씩 계산해줍니다.

39
00:02:18,260 --> 00:02:24,110
하지만 파이썬과 넘파이에서는 
이미 수 많은 내장된 기능을 통해

40
00:02:24,110 --> 00:02:31,160
함수에서 한번의 명령만으로 
이러한 벡터들을 계산하는 방법이 있는데요,

41
00:02:31,160 --> 00:02:40,180
그렇기 때문에 저 같은 경우엔, 
불러온 값 넘파이를 np로 도입해서

42
00:02:40,180 --> 00:02:50,110
그냥 u= np.exp(v)로 부르는 것입니다.

43
00:02:50,110 --> 00:02:53,600
이전에는 v의 입력값 벡터, u의 결과값 벡터로,

44
00:02:53,600 --> 00:02:57,317
1가지 라인의 코드로 이루어진,

45
00:02:57,317 --> 00:02:58,840
일정한 for-loop가 있었지만,

46
00:02:58,840 --> 00:03:02,340
이제는 일정한 for-loop를 제거하여 
오른쪽처럼 도입하여

47
00:03:02,340 --> 00:03:06,275
일정한 for-loop를 필요로 하는 
것보다 훨씬 더 빨리 처리가 가능합니다.

48
00:03:06,275 --> 00:03:10,310
사실 넘파이 library에는 
벡터의 값으로 된함수가 많습니다.

49
00:03:10,310 --> 00:03:15,175
그러므로 np.log (v)는 element-wise log를계산하고

50
00:03:15,175 --> 00:03:19,220
np.abs는 절대값을 계산할 것입니다.

51
00:03:19,220 --> 00:03:24,935
np.maximum는 element-wise maximum 계산하여

52
00:03:24,935 --> 00:03:29,850
v의 모든 요소에 대한 최대값을 0으로 할 것입니다.

53
00:03:29,850 --> 00:03:31,290
v**2 는

54
00:03:31,290 --> 00:03:38,214
v의 각각의 요소에 대해서 
element-wise의 제곱으로 합니다.

55
00:03:38,214 --> 00:03:42,932
1 나누기 v는 element-wise를 거꾸로 그 값을 갖습니다.

56
00:03:42,932 --> 00:03:45,635
그러므로, 여러분이 for-loop를 쓰고 싶은 경우에는

57
00:03:45,635 --> 00:03:48,440
넘파이 의 내장된 기능이 for-loop없이

58
00:03:48,440 --> 00:03:53,069
처리할 수 있는지 먼저 보시기 바랍니다.

59
00:03:53,069 --> 00:03:55,640
이제까지 배운 것을 취합해서

60
00:03:55,640 --> 00:03:59,105
로지스틱 회귀분석법, 
기울기 강하 도입에 적용해서

61
00:03:59,105 --> 00:04:02,955
적어도 2개중 1개의 for-loop을 
제거할 수 있는지 보겠습니다.

62
00:04:02,955 --> 00:04:07,980
여기는 로지스틱 회귀분석법에서 
derivative를 계산하는 코드인데요.

63
00:04:07,980 --> 00:04:09,335
여기서는 2개의 for-loop가 있었습니다.

64
00:04:09,335 --> 00:04:13,065
하나는 여기 위에 있는 것이고, 
2번째 것은 이것입니다.

65
00:04:13,065 --> 00:04:15,422
예제에서는,

66
00:04:15,422 --> 00:04:17,810
nx가 2인데요,

67
00:04:17,810 --> 00:04:19,910
2개의 특성보다 더 많은 경우,

68
00:04:19,910 --> 00:04:23,865
for-loop가 dw1, dw2, dw3 
등등에 있어야 할 것입니다.

69
00:04:23,865 --> 00:04:25,676
for-loop가 dw1, dw2, dw3 
등등에 있어야 할 것입니다.

70
00:04:25,676 --> 00:04:30,305
그렇기 때문에 마치 4j는 1, 2, 그리고 x인 것처럼

71
00:04:30,305 --> 00:04:37,395
dWj가 업데이트 됩니다.

72
00:04:37,395 --> 00:04:41,745
우리는 이 2번째 for-loop를 제거하고 싶은데요

73
00:04:41,745 --> 00:04:43,745
이번 슬라이드에서 해보겠습니다.

74
00:04:43,745 --> 00:04:48,725
하는 방법은, 일단은 대놓고 
dw1, dw2 등등을 0으로 초기화시키기 보다는

75
00:04:48,725 --> 00:04:51,390
하는 방법은, 일단은 대놓고 
dw1, dw2 등등을 0으로 초기화시키기 보다는

76
00:04:51,390 --> 00:04:58,100
이것을 먼저 제거하고 dw를 벡터로 만들겠습니다.

77
00:04:58,100 --> 00:05:05,600
그러면 dw를 np.zeros가 되게 만들고

78
00:05:05,600 --> 00:05:10,490
이 nx를 1차원 벡터로 만들겠습니다.

79
00:05:10,490 --> 00:05:13,175
그러면 여기서 개인 요소에 대한 for-loop 대신에

80
00:05:13,175 --> 00:05:15,941
그러면 여기서 개인 요소에 대한 for-loop 대신에

81
00:05:15,941 --> 00:05:19,190
이 벡터 값 방법을 사용하겠습니다.

82
00:05:19,190 --> 00:05:22,350
dw 플러스는 xi 곱하기 dz(i) 말이죠.

83
00:05:22,350 --> 00:05:32,031
dw 플러스는 xi 곱하기 dz(i) 말이죠.

84
00:05:32,031 --> 00:05:33,620
그리고 마지막으로, 이것 대신에

85
00:05:33,620 --> 00:05:42,562
dw 나누기가 m이 되도록 하겠습니다. 
이렇게 해서 for-loop가 2개에서 1개가 되었는데요,

86
00:05:42,562 --> 00:05:48,864
아직까지 각각의 트레이닝 예시에 
대한 1개의 for-loop가 있습니다.

87
00:05:48,864 --> 00:05:51,030
저는 이 비디오가 vectorization에 대한 개념을

88
00:05:51,030 --> 00:05:54,165
이해하는데 도움이 되셨으면 좋겠습니다.

89
00:05:54,165 --> 00:05:56,505
그리고 1개의 for-loop를 제거하여 
이제는 코디가 훨씬 더 빨리 운영될 것입니다.

90
00:05:56,505 --> 00:05:58,320
하지만 더 잘할 수 있죠,

91
00:05:58,320 --> 00:05:59,418
다음 비디오에서는

92
00:05:59,418 --> 00:06:03,237
로지스틱 회귀분석을 벡터화시키는 
방법에 대해 더욱 자세히 다루겠습니다.

93
00:06:03,237 --> 00:06:07,365
여러분들은 트레이닝 example에서 
for-loop의 사용 없이도

94
00:06:07,365 --> 00:06:10,695
전체적인 트레이닝 세트를 코드화시킬 
수 있다는 조금 놀라운 결과를 보셨는데요.

95
00:06:10,695 --> 00:06:14,760
전체적인 트레이닝 세트를 코드화시킬 
수 있다는 조금 놀라운 결과를 보셨는데요.

96
00:06:14,760 --> 00:06:17,060
이 모든 것을 한번에 이룰 수 있는데요.

97
00:06:17,060 --> 00:06:19,000
다음 비디오에서 보도록 하겠습니다.