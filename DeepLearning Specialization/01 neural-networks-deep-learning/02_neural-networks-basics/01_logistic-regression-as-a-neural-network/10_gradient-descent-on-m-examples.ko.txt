이전 비디오에서는 1개의 트레이닝 example에 대해서 로지스틱 회귀분석을 위한 기울기 강하를 도입하기 위해 derivative를 산출하는 방법을 배웠는데요, 이제는 m개의 트레이닝 example에 대하여 구하고 싶습니다. 시작하기에 앞서, j의 비용함수 정의에 사시 한번 짚고 넘어가겠습니다. J(w, b) 비용함수는 여기 이 것의 평균값인데요 1 나누기 m 의 합, l이 1에서 m 까지의 합이고, 알고리즘 결과값의 loss가 a i 이고 y example에 대한 것입니다. 그리고 ai는 i번째의 트레이닝 example의 예측 수치입니다. 그것은 zi의 시그마인데요 이 값은 또 w transpose 더하기 b의 시그마입니다. 이전 슬라이드에서는, 1개의 트레이닝 example에 대해서 d의 derivative 값을 구하는 방법에 대해 배웠는데요, 
즉, dw1, dw2, 그리고 db인데요, 이제는 위 첨자 i를 표기해서 이전 슬라이드에서 했던 것을 똑같이 하면 나오는 값을 표현하겠습니다. 1개의 트레이닝 example인 xi, yi를 이용했을 때 말이죠. 죄송합니다. 여기 i가 빠졌네요. 그러면 여러분도 아시겠지만, 전체 비용 함수는 합, 아니 사실 평균이죠, 여기 1 나누기 m 에 대한 loss값에서 말이죠. w1에 대한 derivative는 전체 비용함수에서 마찬가지로 w1에 대한 derivative의 개인 loss 항들에 대한 평균값이 될 것입니다. 하지만 이전에 이 항을 계산하는 방법을 보여줬듯이, dw i라고 했는데요, 맞죠. 이것을 이전 슬라이드에서는 1개의 트레이닝 example의 경우 계산하는 방법을 알려드렸는데요, 이제 여러분은 여기 dervative를 이전의 트레이닝 example에서 보여줬듯이 계산해야 합니다. 그런 다음에 평균치를 구하면, 기울기 강하를 바로 도입할 수 있는 전체 기울기 값을 구할 수 있는 것입니다. 지금 다룬 내용이 굉장히 많은 양인데요, 이것들을 모두 모아서 더 구체적인 알고리즘을 만들어 봅시다. 기울기 강하와 로지스틱 회귀분석이 같이 도입된 잘 작동하는 알고리즘으로 말이죠. 이제 여러분이 할 수 있는 것은 이런데요, 
J=0으로 초기화 하고, dw1 = 0, dw2 = 0, db = 0으로 설정하고, 이제 할 것은 이런 트레이닝 세트에 for loop를 사용해서 각각의 트레이닝 example에 대해서 derivative 값을 구한 뒤에, 그 값들을 더할 것입니다. 이제 이렇게 하는데요, i가 1에서 m까지, m은 트레이닝 example의 개수입니다. zi 는 w transpose xi 더하기 b이고요, 예측 값 ai는 zi 의 시그마 그리고 j를 더해보도록 하죠. j 플러스는 yi log ai 더하기 1 빼기 yi 의 로그 1 빼기 ai하고 나서 전체 괄호 바깥으로 마이너스 부호를 앞에 두겠습니다. 그리고 이전에도 봤듯이 dzi는 ai 빼기 yi 이고요 dw 플러스 값은 x1 i 곱하기 d zi 입니다. dw2 플러스는 xi 2 dzi 입니다. 아 그리고 저는 이 계산들을 오로지 2개의 특성만 있다는 가정하에 진행하고 있는 것입니다.
즉, n= 2인 경우이죠, 안 그러면, 아니면 이것을 dw1, dw2, dw3 등등 이어서 하겠죠, 그러면 db 플러스는 dzi 인데요, 이렇게 하면 for loop의 끝입니다. 이렇게 m트레이닝 example에 대해서 모든 것을 마치면, 아직도 M으로 나누어야 할 텐데요, 평균을 구하는 것이기 때문입니다. 그러므로 dw1을 나눈 값이 m이고, dw2를 나누면 m이고, db 나누면 m이 되겠죠. 모든 평균에서 말이죠 그러면 전체 모든 계산에서 3개의 parameter w1, w2, b에 대한 j 비용함수의 derivative를 계산했는데요, 저희가 무엇을 했는지 조금 더 커멘트 해드리자면 저희가 dw1, dw2와 b를 이용하는데요, 누산기들 (accumulators)로 말이죠, 그렇기 때문에 계산 이후에는 dw1이 전체 비용함수의 derivative와 일치 하다는 것을 알 수 있습니다. w1에 대해서 말이죠. 비슷하게 dw2와 db에서도 말이죠. 보시면 알겠지만 dw1과 dw2는 위 첨자 i가 없습니다. 그 이유는 여기 코드에서 이것을 누산기들로 이용해서 전체 트레이닝 세트에 대해 사용하기 때문입니다. 반면에, dzi는 여기서 1개의 트레이닝 샘플에 대한 dz 값이었는데요, 그렇기 때문에 1개의 트레이닝 샘플임을 나타내기 위해 위 첨자 i가 있었던 것인데요, 이제 이런 계산을 모두 마쳤는데요, 기울기 강하의 1개의 단계를 도입하기 위해서는 w1을 도입하고, 이것은 w1 빼기 러닝속도 곱하기 dw1으로 업데이트 되고요. dw2는 w2 빼기 러닝속도 곱하기 dw2로 업데이트 됩니다. 그리고 b는 b 빼기 러닝속도 곱하기 db로 업데이트됩니다. 그리고 dw1, dw2, db는 이전에 왼쪽에서 계산했던 대로의 값입니다. 마지막으로 여기 J는 비용함수의 올바른 값일 것입니다. 그러면 이제 슬라이드의 모든 내용은 1가지 단계의 기울기 강하를 도입하는 것인데요, 여기 슬라이드에 있는 모든 내용을 복수로 반복해야 복수의 gradient descent 단계를 갖출 수 있습니다. 여기 상세 내용이 조금 너무 복잡하다고 생각되면, 다시 말씀 드리지만 너무 걱정하지 마십시요 아직 까지는요, 연습문제에서 이것들을 도입하게 되면 더 명백해질 것입니다. 여기 도입한 것과 같이 계산부분에 있어서는 2가지의 단점이 나타날 수 있는데요, 로지스틱 회귀분석을 이렇게 도입하기 위해서는 2개의 for loop을 써야 합니다. 첫 번째 for loop은 여기 m 트레이닝 example에 대한 for loop 이고요, 두 번째는 여기 모든 특성에 대한 for loop입니다. 여기 예제에서는 저희는 단순히 2개의 특성만 있었는데요, 
즉 n=2 그리고 x=2였죠, 하지만 더 많은 특성이 있을 시, dw1 과 dw2를 쓰게 될 텐데요 그리고 dw3로 비슷한 산출 법이 적용됩니다. dw n까지 말이죠. 그러므로 이렇게 n 개의 특성에 거쳐 for loop을 필요로 합니다. 딥러닝을 알고리즘을 도입하는 경우에 명백한 for loop을 갖는 경우, 코딩에서 말이죠, 이런 경우, 알고리즘이 덜 효율적으로 운영됩니다. 그러므로 딥러닝 시대에 데이터세트는 더욱 커지고 커지는데요, 알고리즘을 명백히 for loop을 알고리즘에 도입시키지 않고 진행하는 것이 굉장히 중요합니다. 그리고 더 많이 큰 데이터세트를 스케일링 할 수 있도록 도와주겠죠. vectorization이라고 하는 한가지 세트의 기술이 있는데요, 이 기술은 for loop을 코드에서 제거하게 해주는데요, 딥러닝 전 시대에는, 즉 딥러닝이 급부상하기 전에 말이죠, vectorization을 갖는 것이 좋았습니다. 가끔씩은 빠르게 하기 위해서 쓰였고 안 그럴 수도 있는데요, 딥러닝 세대에는, vectorization이 for loop을 이렇게 제거함으로써 또는 이렇게 말이죠, 아주 중요하게 되었습니다. 왜냐면 이제는 더욱 더 큰 데이터세트에서 트레이닝 시키기 때문입니다. 그렇기 때문에 여러분의 코드를 효율적으로 만드는 게 매우 중요해졌습니다. 다음 몇 개의 비디오에서는 vectorization에 대해 이야기하고 한 개의 for loop도 없이 이 모든 것을 도입하는 방법에 대해 배워보겠습니다. 그렇게 해서 로지스틱 회귀분석을 또는 기울기 강하를 도입하는 방법에 대해 이해하셨길 바랍니다. 연습문제를 진행하는 경우에
조금 더 명백히 이해하실 수 있을 것입니다. 하지만 연습문제를 하기에 앞서, 먼저 vectorization에 대해 이야기해보겠습니다. 그러면, 여기 모든 내용에 for loop없이 기울기 강하의 single iteration을 통해 도입할 수 있을 것입니다.