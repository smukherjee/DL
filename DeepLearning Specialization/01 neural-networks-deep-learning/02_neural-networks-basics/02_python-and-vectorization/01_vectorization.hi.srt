1
00:00:00,000 --> 00:00:03,195
पुन: स्वागत है. वेक्टराइज़ेशन है मूलत:

2
00:00:03,195 --> 00:00:07,315
कला छुटकारा पाने की स्पष्ट फ़ॉर लूप्स से आपके कोड में.

3
00:00:07,315 --> 00:00:11,835
डीप लर्निंग के युग में, निश्चित रूप से, 
व्यावहारिक रूप में डीप लर्निंग में,

4
00:00:11,835 --> 00:00:15,210
अक्सर आप पाएँगे आपको ट्रेन करते हुए
 अपेक्षाकृत बड़े डेटा सेट्स पर,

5
00:00:15,210 --> 00:00:18,475
क्योंकि तब ही डीप लर्निंग अल्गोरिद्म्स बेहतर काम करते हैं.

6
00:00:18,475 --> 00:00:22,790
और इसलिए, यह महत्वपूर्ण हैं कि आपका 
कोड त्वरित काम करे क्योंकि अन्यथा,

7
00:00:22,790 --> 00:00:24,525
यदि यह चल रहा है एक बड़े डेटा सेट पर,

8
00:00:24,525 --> 00:00:27,000
आपके कोड को शायद लग सकता हैं लम्बा समय चलने में 
तब आप पाएँगे

9
00:00:27,000 --> 00:00:30,255
अपने को इंतज़ार करते हुए एक लम्बे समय तक 
परिणाम प्राप्त करने के लिए.

10
00:00:30,255 --> 00:00:32,035
तो डीप लर्निंग के युग में,

11
00:00:32,035 --> 00:00:37,490
मुझे लगता है वेक्टराइज़ कर पाने की क्षमता 
एक महत्वपूर्ण कौशल बन गया है.

12
00:00:37,490 --> 00:00:40,010
चलिए शुरू करते हैं एक उदाहरण से.

13
00:00:40,010 --> 00:00:42,225
तो, क्या है वेक्टराइज़ेशन?

14
00:00:42,225 --> 00:00:48,780
लॉजिस्टिक रेग्रेशन में आपको कम्प्यूट करना होता है
 Z बराबर है W ट्रान्स्पोज़ X जमा B,

15
00:00:48,780 --> 00:00:55,405
जहाँ W था यह कॉलम वेक्टर और X भी है यह वेक्टर.

16
00:00:55,405 --> 00:00:58,000
शायद वहाँ बहुत बड़े वेक्टर्स हैं
 यदि आपके पास बहुत से फ़ीचर्ज़ हैं.

17
00:00:58,000 --> 00:01:07,080
तो, W और X थे दोनो R पर Nx डिमेन्शन के वेक्टर्स.

18
00:01:07,080 --> 00:01:10,170
तो, W ट्रान्स्पोज़ X कम्प्यूट करने के लिए,

19
00:01:10,170 --> 00:01:15,660
यदि आपके पास थी एक नॉन-वेक्टराइज्ड इम्प्लमेंटेशन,

20
00:01:15,660 --> 00:01:18,725
आप भी करेंगे कुछ ऐसा जैसे Z बराबर है ज़ीरो.

21
00:01:18,725 --> 00:01:24,860
और फिर फ़ॉर I होते हुए Nx की रेंज में,

22
00:01:24,860 --> 00:01:27,330
तो, I बराबर है 1, 2, ... Nx के लिए,

23
00:01:27,330 --> 00:01:34,040
Z प्लस W बराबर है W I गुणा XI.

24
00:01:34,040 --> 00:01:37,100
और फिर शायद आप करें Z प्लस B अंत में.

25
00:01:37,100 --> 00:01:39,855
तो, वह है एक नॉन-वेक्टराइज्ड इम्प्लमेंटेशन.

26
00:01:39,855 --> 00:01:43,090
तब आप पाएँगे कि यह वाक़ई में बहुत धीरे चल रहा है.

27
00:01:43,090 --> 00:01:48,560
इसके विपरीत, एक वेक्टराइज्ड इम्प्लमेंटेशन
 सिर्फ़ कम्प्यूट करेगी W ट्रान्स्पोज़ X सीधे.

28
00:01:48,560 --> 00:01:52,085
पाइथान में या numpy में,

29
00:01:52,085 --> 00:02:01,428
कमांड जो आप इस्तेमाल करते हैं उसके लिए है Z ईक्वल्ज़ np.W,

30
00:02:01,428 --> 00:02:06,270
X, तो यह कम्प्यूट करता है W ट्रान्स्पोज़ X.

31
00:02:06,270 --> 00:02:09,075
और आप जोड़ भी सकते हैं B उसको सीधे.

32
00:02:09,075 --> 00:02:12,400
और आप पाएँगे कि यह अधिक तेज़ है.

33
00:02:12,400 --> 00:02:17,075
चलो इसे वास्तव में स्पष्ट करते हैं एक छोटे डेमो से.

34
00:02:17,075 --> 00:02:21,960
तो यहाँ है मेरी जूपिटर नोट्बुक जहाँ मैं लिखूँगा कुछ पाइथान कोड.

35
00:02:21,960 --> 00:02:28,041
तो, पहले मैं इम्पोर्ट करता हूँ numpy लाइब्रेरी import

36
00:02:28,041 --> 00:02:30,000
numpy as np. और तो, उदाहरण के लिए,

37
00:02:30,000 --> 00:02:36,570
मैं बना सकता हूँ A एक एर्रे की तरह इस प्रकार.

38
00:02:36,570 --> 00:02:39,560
मान लो कहते हैं print A.

39
00:02:39,560 --> 00:02:41,160
अब, इस कोड को लिख लेने के बाद,

40
00:02:41,160 --> 00:02:43,170
यदि मैं दबाता हूँ शिफ़्ट एंटर,

41
00:02:43,170 --> 00:02:44,847
तो यह कोड एक्सेक्यूट करेगा.

42
00:02:44,847 --> 00:02:47,970
तो, इसने बनाया एर्रे A और यह इसे प्रिंट करता है.

43
00:02:47,970 --> 00:02:50,580
अब, चलो करते हैं वेक्टराइज़ेशन डेमो.

44
00:02:50,580 --> 00:02:51,990
मैं इम्पोर्ट करूँगा टाइम लाइब्रेरीज़.

45
00:02:51,990 --> 00:02:53,580
क्योंकि हम उसका इस्तेमाल करते हैं,

46
00:02:53,580 --> 00:02:56,565
पाने के लिए समय कि कितना समय लगता है 
विभिन्न ऑपरेशन्स को.

47
00:02:56,565 --> 00:02:59,139
चलो बनाते हैं एक एर्रे A.

48
00:02:59,139 --> 00:03:02,905
वह है random.rand.

49
00:03:02,905 --> 00:03:10,065
यह बनाता है एक मिलियन डिमेन्शन का एर्रे 
जिसमें रैंडम वैल्यूज़ हैं.

50
00:03:10,065 --> 00:03:13,300
b = np.random.rand.

51
00:03:13,300 --> 00:03:16,120
एक और मिलियन डिमेन्शन का एर्रे.

52
00:03:16,120 --> 00:03:20,810
और, अब, tic=time.time, तो वह मापता है अभी का समय,

53
00:03:20,810 --> 00:03:26,395
c = np.dot (a, b).

54
00:03:26,395 --> 00:03:28,649
toc = time.time.

55
00:03:28,649 --> 00:03:31,950
और यह print,

56
00:03:31,950 --> 00:03:34,857
यह है वेक्टर वर्ज़न.

57
00:03:34,857 --> 00:03:37,685
यह है एक वेक्टर वर्ज़न.

58
00:03:37,685 --> 00:03:41,985
और तो, चलो प्रिंट करते हैं.

59
00:03:41,985 --> 00:03:45,060
चलो देखते हैं पिछला समय,

60
00:03:45,060 --> 00:03:48,330
तो वह है toc - tic x 1000,

61
00:03:48,330 --> 00:03:52,075
ताकि हम व्यक्त कर सकें इसे मिलीसेकंड में.

62
00:03:52,075 --> 00:03:54,075
तो, ms है मिलीसेकंड.

63
00:03:54,075 --> 00:03:56,435
तो मैं दबाता हूँ शिफ़्ट एंटर,

64
00:03:56,435 --> 00:04:01,890
तो, उस कोड ने लगभग तीन मिलीसेकंड या 
कुछ इतना इस समय लिया 1.5,

65
00:04:01,890 --> 00:04:06,170
शायद लगभग 1.5 या 3.5 मिलीसेकंड एक समय में.

66
00:04:06,170 --> 00:04:08,370
यह बदलता है थोड़ा जैसे मैं इसे चलाता हूँ,

67
00:04:08,370 --> 00:04:12,085
लेकिन लगता है औसतन इसे लग रहा कुछ 1.5 मिलीसेकंड,

68
00:04:12,085 --> 00:04:15,665
शायद दो मिलीसेकंड जब मैं इसे चलाता हूँ.

69
00:04:15,665 --> 00:04:16,967
ठीक है.

70
00:04:16,967 --> 00:04:19,005
चलो इस कोड में डालना जारी रखते हैं.

71
00:04:19,005 --> 00:04:22,270
चलो अब इम्प्लमेंट करते हैं नॉन-वेक्टराइज्ड वर्ज़न.

72
00:04:22,270 --> 00:04:24,151
चलो देखते हैं, c = 0,

73
00:04:24,151 --> 00:04:27,750
फिर tic = time.time.

74
00:04:27,750 --> 00:04:29,335
अब चलो इम्प्लमेंट करते हैं एक फ़ॉर लूप.

75
00:04:29,335 --> 00:04:35,348
फ़ॉर I 1 मिलियन की रेंज में,

76
00:04:35,348 --> 00:04:38,676
मेरे पास हैं ज़ीरोज़ की संख्या, ठीक है?

77
00:04:38,676 --> 00:04:43,936
C += (a,i) x (b,i),

78
00:04:43,936 --> 00:04:50,775
और फिर toc = time.time.

79
00:04:50,775 --> 00:04:57,725
अंत में, प्रिंट करते हैं स्पष्ट फ़ॉर लूप के लिए.

80
00:04:57,725 --> 00:05:15,225
समय जो इसे लगता हैं वह है यह 1000 x toc - tic + "ms"

81
00:05:15,225 --> 00:05:17,505
डिनोट करने के लिए कि हम इसे कर रहे हैं मिली सेकंड में.

82
00:05:17,505 --> 00:05:19,735
चलो एक और चीज़ करते हैं.

83
00:05:19,735 --> 00:05:22,802
चलो प्रिंट करते हैं c की वैल्यू. हम

84
00:05:22,802 --> 00:05:27,960
कम्प्यूट करते हैं इसे सुनिश्चित करने के लिए 
यह समान वैल्यू है दोनो स्थितियों में.

85
00:05:27,960 --> 00:05:35,770
मैं दबाता हूँ शिफ़्ट एंटर इसे रन करने के लिए और चेक करें उसे.

86
00:05:35,770 --> 00:05:38,305
दोनो स्थितियों में, वेक्टर वर्ज़न

87
00:05:38,305 --> 00:05:41,125
और नॉन-वेक्टर वर्ज़न ने कम्प्यूट की समान वैल्यूज़,

88
00:05:41,125 --> 00:05:45,355
जैसा कि आप जाते हैं, 250286.99, और इसी प्रकार आगे.

89
00:05:45,355 --> 00:05:48,670
वेक्टर वर्ज़न को लगे 1.5 मिलीसेकंड.

90
00:05:48,670 --> 00:05:57,555
स्पष्ट फ़ॉर लूप को और नॉन-वेक्टर वर्ज़न ने लिए 
लगभग 400 या 500 मिलीसेकंड.

91
00:05:57,555 --> 00:06:01,285
नॉन-वेक्टर वर्ज़न को लगे कुछ 300

92
00:06:01,285 --> 00:06:05,660
गुणा ज़्यादा समय वेक्टर वर्ज़न की तुलना में.

93
00:06:05,660 --> 00:06:11,230
इस उदाहरण से आप देख सकते हैं 
यदि आप याद रखें वेक्टराइज़ करना आपका कोड,

94
00:06:11,230 --> 00:06:15,120
आपका कोड वास्तव में 300 गुणा तेज़ काम करता है.

95
00:06:15,120 --> 00:06:16,540
चलो फिर से रन करते हैं.

96
00:06:16,540 --> 00:06:18,930
बस फिर से रन करते हैं.

97
00:06:18,930 --> 00:06:22,235
हाँ. वेक्टर वर्ज़न 1.5 मिली सेकंड एंड फ़ॉर लूप

98
00:06:22,235 --> 00:06:25,960
तो यह 481 मिलीसेकंड, फिर से.

99
00:06:25,960 --> 00:06:29,535
क़रीब 300 गुणा धीरे स्पष्ट फ़ॉर लूप करने के लिए.

100
00:06:29,535 --> 00:06:30,980
तो 300 गुणा धीरे,

101
00:06:30,980 --> 00:06:33,880
यह है अंतर आपके कोड जो शायद ले एक मिनट

102
00:06:33,880 --> 00:06:37,615
रन करने के लिए तुलना में पाँच घंटे रन करने में.

103
00:06:37,615 --> 00:06:41,410
और जब आप इम्प्लमेंट कर रहे हैं 
डीप लर्निंग अल्गोरिद्म्स,

104
00:06:41,410 --> 00:06:43,300
आपको वास्तव में मिल सकता है 
एक परिणाम वापिस जल्दी.

105
00:06:43,300 --> 00:06:46,590
यह होगा और अधिक तेज़ यदि आप 
वेक्टराइज़ करते हैं आपका कोड.

106
00:06:46,590 --> 00:06:49,300
आप में से कुछ ने बहुत शायद सुना हो

107
00:06:49,300 --> 00:06:54,260
स्केल कर सकने वाले डीप लर्निंग इम्प्लमेंटेशन्स 
के बारे में जो किए जाते हैं एक GPU पर 
या एक ग्राफ़िक्स प्रासेसिंग यूनिट पर.

108
00:06:54,260 --> 00:06:59,515
लेकिन सभी डेमो जो मैंने अभी किए 
जूपिटर नोट्बुक पर, हम वास्तव में हैं CPU पर.

109
00:06:59,515 --> 00:07:04,530
और ऐसा होता है कि दोनो GPU और CPU में हैं 
पैरलेलाइज़ेशन इन्स्ट्रक्शन्स.

110
00:07:04,530 --> 00:07:07,530
उन्हें कभी-कभी कहते हैं SIMD इन्स्ट्रक्शन्स.

111
00:07:07,530 --> 00:07:11,190
उसका मतलब है एक सिंगल इन्स्ट्रक्शन मल्टिपल डेटा.

112
00:07:11,190 --> 00:07:13,045
लेकिन इसका मूल रूप से मतलब है कि,

113
00:07:13,045 --> 00:07:16,835
यदि आप इस्तेमाल करते हैं बिल्ट-इन फ़ंक्शन्स, 
जैसे कि यह

114
00:07:16,835 --> 00:07:23,495
np.function या अन्य फ़ंक्शन्स जिनके लिए 
आपको स्पष्ट रूप से नहीं इम्प्लमेंट करना पड़ता 
एक फ़ॉर लूप.

115
00:07:23,495 --> 00:07:28,150
यह सक्षम करता हैं पाइथान numpy को
 लेने के लिए

116
00:07:28,150 --> 00:07:33,640
बेहतर लाभ पैरलेलिस्म का करने के लिए 
आपकी कॉम्प्यूटेशन्स अधिक तेज़.

117
00:07:33,640 --> 00:07:38,610
और यह सत्य है दोनो कॉम्प्यूटेशन्स CPU पर 
और कॉम्प्यूटेशन्स GPU पर.

118
00:07:38,610 --> 00:07:41,070
सिर्फ़ इतना कि GPU हैं उल्लेखनीय रूप से बेहतर

119
00:07:41,070 --> 00:07:44,980
इन SIMD कैल्क्युलेशन्स में 
लेकिन CPU हैं वास्तव में उतनी बुरी नहीं उसमें.

120
00:07:44,980 --> 00:07:47,510
शायद उतनी अच्छी नहीं जितनी GPU.

121
00:07:47,510 --> 00:07:51,660
आप देख रहे हैं कि कैसे वेक्टराइज़ेशन 
काफ़ी गति बढ़ा सकता है आपके कोड की.

122
00:07:51,660 --> 00:07:54,685
नियम याद रखना है कि जहाँ तक सम्भव हो,

123
00:07:54,685 --> 00:07:57,425
स्पष्ट फ़ॉर लूप का इस्तेमाल न करें.

124
00:07:57,425 --> 00:07:59,980
चलो जाते हैं अगले वीडियो पर देखने के लिए 
कुछ और उदाहरण

125
00:07:59,980 --> 00:08:04,000
वेक्टराइज़ेशन के और शुरू करने के लिए 
वेक्टराइज़ लॉजिसिटिक रेग्रेशन भी.