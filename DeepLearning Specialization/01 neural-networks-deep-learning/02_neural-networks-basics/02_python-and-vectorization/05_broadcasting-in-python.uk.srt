1
00:00:00,210 --> 00:00:03,240
В попередньому відео я казав, що посів [broadcasting] -

2
00:00:03,240 --> 00:00:07,040
це ще одна методика прискорення виконання твого Python коду.

3
00:00:07,040 --> 00:00:11,860
В цьому відео, давай детальніше розглянемо як працює посів у Python.

4
00:00:11,860 --> 00:00:14,240
Давай розглянемо посів на прикладі.

5
00:00:14,240 --> 00:00:18,730
В цій матриці я показав кількість вуглеводних,

6
00:00:18,730 --> 00:00:22,320
білкових і жирових калорій, які містяться в 100г 4-ох різних продуктів.

7
00:00:22,320 --> 00:00:25,380
Тож, наприклад, в 100г яблук -

8
00:00:25,380 --> 00:00:29,690
56 вуглеводних калорій, а білкових і жирових набагато менше.

9
00:00:29,690 --> 00:00:35,110
В той час як в 100г м'яса білкових калорій - 105,

10
00:00:35,110 --> 00:00:37,620
а жирових - 135.

11
00:00:37,620 --> 00:00:43,330
Тепер, скажімо, ми хочемо обчислити у %

12
00:00:43,330 --> 00:00:48,440
вуглеводні, білкові і жирові калорії для кожного типу їжі.

13
00:00:48,440 --> 00:00:52,338
Тож, наприклад, якщо ми глянемо на цей стовпець і

14
00:00:52,338 --> 00:00:57,697
додамо числа в ньому, то отримаємо, що 100г яблук

15
00:00:57,697 --> 00:01:02,580
містять 56+1,2+1,8, тобто 59 калорій.

16
00:01:02,580 --> 00:01:06,806
Тож у відсотках

17
00:01:06,806 --> 00:01:11,800
вуглеводних калорій в яблуках

18
00:01:11,800 --> 00:01:16,932
буде 56/59, буде 94,9%.

19
00:01:16,932 --> 00:01:22,399
Тож більшість калорій з яблук надходять від вуглеводів, в той час як

20
00:01:22,399 --> 00:01:27,630
більшість калорій з яловичини надходять з білків і жирів і т.д.

21
00:01:27,630 --> 00:01:33,630
Тож для обчислення нам треба додати всі 4 стовпці

22
00:01:33,630 --> 00:01:38,740
матриці, щоб отримати загальну кількість калорій в 100г яблук,

23
00:01:38,740 --> 00:01:40,920
яловичини, яєць і картоплі.

24
00:01:40,920 --> 00:01:45,090
Далі поділити кожен член матриці

25
00:01:47,230 --> 00:01:51,230
так, щоб отримати у % вуглеводні, білкові і

26
00:01:51,230 --> 00:01:54,870
жирові калорії для кожного з 4 типів їжі.

27
00:01:54,870 --> 00:02:01,370
Тож виникає питання: чи можемо ми це зробити без явного циклу for?

28
00:02:01,370 --> 00:02:03,290
Давай подивимось як це можна зробити.

29
00:02:04,450 --> 00:02:08,602
Зараз я покажу як можна перетворити,

30
00:02:08,602 --> 00:02:12,990
скажімо, цю матрицю розміру 3*4, матрицю A.

31
00:02:12,990 --> 00:02:18,300
За допомогою лише однієї строки Python коду ми просумуємо всі стовпці.

32
00:02:18,300 --> 00:02:22,078
Тож ми отримаємо 4 числа, що відповідають загальній кількості

33
00:02:22,078 --> 00:02:25,046
калорій в цих 4-ох типах їжі.

34
00:02:25,046 --> 00:02:28,095
В 100г цих 4-ох типів їжі.

35
00:02:28,095 --> 00:02:32,113
Зараз я напишу другу строку Python коду, щоб поділити кожен

36
00:02:32,113 --> 00:02:35,390
з 4-ох стовпців на відповідну суму.

37
00:02:35,390 --> 00:02:37,250
Якщо я не дуже зрозуміло описав це словами,

38
00:02:37,250 --> 00:02:40,670
надіюсь, зараз стане зрозуміліше коли я напишу Python код.

39
00:02:40,670 --> 00:02:42,460
Тож зараз ми в записнику Jupyter.

40
00:02:42,460 --> 00:02:46,150
Я вже написав частину коду, що заповнює

41
00:02:46,150 --> 00:02:49,860
матрицю A числами, які ми вже бачили. Тож натискаємо Shift+Enter і

42
00:02:49,860 --> 00:02:51,220
запускаємо виконання. Тож ось матриця A.

43
00:02:51,220 --> 00:02:55,080
А тепер додамо ще 2 строки Python коду.

44
00:02:55,080 --> 00:02:59,983
Спочатку обчислимо cal=A.sum(axis=0),

45
00:02:59,983 --> 00:03:02,280
що означає просумувати по вертикалі.

46
00:03:02,280 --> 00:03:05,280
Я розкажу про це детальніше дещо пізніше.

47
00:03:05,280 --> 00:03:06,076
І виводимо cal.

48
00:03:06,076 --> 00:03:07,825
Тож ми просумували по вертикалі.

49
00:03:07,825 --> 00:03:13,735
Тепер 59 - це загальна кількість калорій в яблуках, 239 -

50
00:03:13,735 --> 00:03:19,575
загальна кількість калорій в яловичині, і т.д. в яйцях і картоплі.

51
00:03:19,575 --> 00:03:25,151
І тепер ми можемо обчислити %:

52
00:03:25,151 --> 00:03:30,733
percentage=A/cal.reshape(1,4).

53
00:03:30,733 --> 00:03:33,927
І множимо це ще на 100, щоб отримати %.

54
00:03:35,913 --> 00:03:38,860
І давай виведемо percentage.

55
00:03:40,800 --> 00:03:41,950
Давай виконаємо.

56
00:03:41,950 --> 00:03:46,870
Цією командою ми беремо матрицю A і

57
00:03:46,870 --> 00:03:50,820
ділимо на цю матрицю розміру 1*4.

58
00:03:50,820 --> 00:03:52,672
І отримуємо матрицю відсотків.

59
00:03:52,672 --> 00:03:57,327
Якщо співставити [матриці], то для яблук

60
00:03:57,327 --> 00:04:02,480
(перший стовпець) 94,9% калорій припадає на вуглеводи.

61
00:04:02,480 --> 00:04:04,000
Давай повернемось до слайдів.

62
00:04:04,000 --> 00:04:06,310
Просто повторимо 2 рядки нашого коду.

63
00:04:06,310 --> 00:04:09,940
Ті, що ми записали в записнику Jupiter.

64
00:04:09,940 --> 00:04:13,306
Трохи детальніше про цей параметр.

65
00:04:13,306 --> 00:04:18,540
(axis=0) означає, що ми хочемо, щоб Python просумував по вертикалі.

66
00:04:18,540 --> 00:04:21,567
Тобто по оцій осі 0 просумувати по вертикалі.

67
00:04:21,567 --> 00:04:24,029
А горизонтальна вісь - це axis=1.

68
00:04:24,029 --> 00:04:28,050
Тобто можна присвоїти axis 1, 
щоб просумувати горизонтально, а не вертикально.

69
00:04:28,050 --> 00:04:30,670
А ось ця команда -

70
00:04:30,670 --> 00:04:35,210
це приклад Python посіву. Тут береться матриця A,

71
00:04:35,210 --> 00:04:43,330
матриця розміру 3*4, і ділиться на матрицю розміру 1*4.

72
00:04:43,330 --> 00:04:47,370
І, технічно, після першого рядка коду cal, змінна cal,

73
00:04:47,370 --> 00:04:49,590
вже є матрицею розміру 1*4.

74
00:04:49,590 --> 00:04:52,616
Тож, технічно, не потрібно викликати reshape() знову,

75
00:04:52,616 --> 00:04:54,722
це вже трохи зайве.

76
00:04:54,722 --> 00:04:59,140
Проте, коли я пишу Python код, я не завжди впевнений

77
00:04:59,140 --> 00:05:04,056
який розмір у матриці, тож я часто викликаю команду reshape(), щоб

78
00:05:04,056 --> 00:05:07,833
пересвідчитись, 
що використовується правильний вектор-стовпець, вектор-рядок

79
00:05:07,833 --> 00:05:09,500
чи щось інше.

80
00:05:09,500 --> 00:05:11,840
Команда reshape виконується визначений час.

81
00:05:11,840 --> 00:05:15,150
Це операція першого порядку, тож її виконання дуже дешеве.

82
00:05:15,150 --> 00:05:18,404
Тож не бійся використовувати команду reshape, 
щоб пересвідчитись, що твої матриці

83
00:05:18,404 --> 00:05:20,830
потрібного розміру.

84
00:05:21,920 --> 00:05:27,272
Тепер давай більш детально пояснимо як працюють операції такого типу.

85
00:05:27,272 --> 00:05:33,780
Ми маємо матрицю 3*4, яка ділиться на матрицю 1*4.

86
00:05:33,780 --> 00:05:37,840
Тож як ми можемо поділити матрицю 3*4 на матрицю 1*4

87
00:05:37,840 --> 00:05:38,860
або вектор 1*4?

88
00:05:40,130 --> 00:05:43,160
Давай розглянемо ще кілька прикладів посіву.

89
00:05:43,160 --> 00:05:47,920
Якщо ми візьмемо вектор 4*1 і додамо його до числа, то

90
00:05:47,920 --> 00:05:53,011
Python візьме це число і автоматично розширить

91
00:05:53,011 --> 00:05:58,180
його до вектора теж 1*4. Ось так.

92
00:05:58,180 --> 00:06:00,257
Тож додавання до вектора [1, 2, 3, 4]

93
00:06:00,257 --> 00:06:04,450
числа 100, замінить 100 на вектор справа.

94
00:06:04,450 --> 00:06:09,280
Тобто додасть 100 до кожного елементу. 
І, дійсно, ми використовували цю форму посіву

95
00:06:09,280 --> 00:06:14,365
коли нашою константою був параметр b в попередньому відео.

96
00:06:14,365 --> 00:06:19,414
І ця форма посіву працює і з векторами-стовпцями, і з векторами-рядками.

97
00:06:19,414 --> 00:06:24,157
І, фактично, цю ж форму посіву ми використовували раніше до константи,

98
00:06:24,157 --> 00:06:29,330
коли доданком вектора був параметр b ЛР.

99
00:06:29,330 --> 00:06:31,610
Інший приклад.

100
00:06:31,610 --> 00:06:35,900
Скажімо, ми маємо матрицю 2*3 і

101
00:06:35,900 --> 00:06:39,420
додаємо до неї матрицю 1*n.

102
00:06:40,950 --> 00:06:45,682
Тож в загальному випадку, якщо

103
00:06:45,682 --> 00:06:50,583
є матриця m*n і

104
00:06:50,583 --> 00:06:55,330
до неї додається матриця 1*n,

105
00:06:55,330 --> 00:06:58,667
То Python скопіює додавану матрицю

106
00:06:58,667 --> 00:07:03,672
m разів, що перетворити її на m*n. Тож оця матриця 1*3

107
00:07:03,672 --> 00:07:09,980
буде скопійована 2 рази (в цьому прикладі), 
щоб бути перетвореною на

108
00:07:09,980 --> 00:07:14,092
матрицю 2*3. Тож її можна буде додати

109
00:07:14,092 --> 00:07:18,270
і отримати оцей результат справа. Так?

110
00:07:18,270 --> 00:07:21,583
Тож ми додаємо 100 до першого стовпця,

111
00:07:21,583 --> 00:07:25,812
додаємо 200 до другого стовпця і додаємо 300 до третього.

112
00:07:25,812 --> 00:07:28,796
Ось, по суті, те, що ми зробили на попередньому слайді.

113
00:07:28,796 --> 00:07:32,810
Просто ми виконували операцію ділення, а не додавання.

114
00:07:34,180 --> 00:07:40,402
І ще один, останній приклад. Якщо ми маємо матрицю m*n і

115
00:07:40,402 --> 00:07:46,260
додаємо її до вектора m*1, матриці m*1,

116
00:07:47,310 --> 00:07:50,760
то вона буде скопійована n разів по горизонталі.

117
00:07:50,760 --> 00:07:53,510
Ми отримаємо матрицю m*n.

118
00:07:53,510 --> 00:07:56,990
Тож, уявімо, що ми копіюємо її 3 рази по горизонталі

119
00:07:56,990 --> 00:07:58,650
і додаємо ось цю.

120
00:07:58,650 --> 00:08:01,070
Тож ми отримаємо ось це.

121
00:08:01,070 --> 00:08:06,890
Тобто додаємо 100 до першого рядка і 200 - до другого.

122
00:08:08,270 --> 00:08:12,061
Ось загальний принцип посіву в Python.

123
00:08:12,061 --> 00:08:17,353
Якщо ми маємо матриця m*n і ми додаємо,

124
00:08:17,353 --> 00:08:24,409
або віднімаємо, або множимо, або ділимо на матрицю 1*n,

125
00:08:24,409 --> 00:08:31,177
то це буде скопійовано m разів до отримання матриці m*n.

126
00:08:31,177 --> 00:08:33,781
А потім буде виконано додавання, віднімання,

127
00:08:33,781 --> 00:08:36,140
множення чи ділення поелементно.

128
00:08:37,250 --> 00:08:42,250
Натомість, якщо ми хочемо додати, відняти, помножити

129
00:08:42,250 --> 00:08:49,060
чи поділити на матрицю m*1, то це теж буде скопійовано n разів

130
00:08:49,060 --> 00:08:54,740
і перетворено на матрицю m*n, 
і тоді виконано операцію поелементно.

131
00:08:54,740 --> 00:09:00,327
Одна з форм посіву, це коли ми маємо матрицю m*1,

132
00:09:00,327 --> 00:09:05,175
тобто вектор-стовпець, скажімо, [1, 2, 3] і хочемо додати

133
00:09:05,175 --> 00:09:08,482
відняти, помножити чи поділити на дійсне число,

134
00:09:08,482 --> 00:09:11,080
або матрицю 1*1.

135
00:09:11,080 --> 00:09:16,117
Тож ось це +100. А в результаті ми отримаємо

136
00:09:16,117 --> 00:09:23,512
скопійоване m разів це дійсне число 
(поки не створиться ще одна матриця m*1).

137
00:09:23,512 --> 00:09:29,700
І потім виконаємо операцію додавання (в цьому прикладі) поелементно.

138
00:09:29,700 --> 00:09:35,823
Аналогічно відбувається для векторів-рядків.

139
00:09:38,281 --> 00:09:43,730
Повна загальна версія посіву може робити ще дещо.

140
00:09:43,730 --> 00:09:49,080
Якщо тобі цікаво, відкрий документацію по

141
00:09:49,080 --> 00:09:52,240
NumPy і пошукай там посів [broadcasting].

142
00:09:52,240 --> 00:09:56,380
Там є більш загальне визначення посіву.

143
00:09:56,380 --> 00:10:00,140
Проте, використані на слайді форми - основні з тих,

144
00:10:00,140 --> 00:10:02,560
які можуть знадобитись при реалізації нейронної мережі (НМ).

145
00:10:03,890 --> 00:10:06,840
Перед тим як закінчити, додам останній коментар для тих,

146
00:10:06,840 --> 00:10:10,210
хто програмував в Matlab або

147
00:10:10,210 --> 00:10:15,760
Octave. 
Якщо ти використовував/ла в Matlab або Octave функцію bsxfun,

148
00:10:15,760 --> 00:10:20,590
то в програмуванні НМ вона виконує щось схоже. 
Не повністю те саме,

149
00:10:20,590 --> 00:10:25,750
але часто використовується для тих же цілей, що й посів в Python.

150
00:10:25,750 --> 00:10:28,505
Проте, це лише для дуже просунутих Matlab і

151
00:10:28,505 --> 00:10:31,600
Octave користувачів. Якщо ти про це не чув/ла, не переймайся.

152
00:10:31,600 --> 00:10:35,524
Це не потрібно знати, якщо пишеш код НМ на Python.

153
00:10:35,524 --> 00:10:38,720
Тож ось що таке посів в Python.

154
00:10:38,720 --> 00:10:42,360
Надіюсь, коли ти будеш виконувати домашнє завдання, 
посів дозволить тобі

155
00:10:42,360 --> 00:10:44,580
не лише пришвидшити код,

156
00:10:44,580 --> 00:10:48,920
але й допоможе скоротити кількість рядків коду.

157
00:10:50,360 --> 00:10:53,630
Перед тим як ти почнеш виконувати програмувальну вправу, 
хочу поділитись з тобою

158
00:10:53,630 --> 00:10:56,290
ще одним набором ідей, деякими хитрощами,

159
00:10:56,290 --> 00:11:00,700
які, як я виявив, зменшують кількість помилок в моєму Python коді і,

160
00:11:00,700 --> 00:11:02,640
надіюсь, допоможуть тобі також.

161
00:11:02,640 --> 00:11:05,550
Тож давай поговоримо про це в наступному відео.