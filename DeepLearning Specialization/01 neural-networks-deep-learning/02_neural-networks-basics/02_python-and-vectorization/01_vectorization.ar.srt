1
00:00:00,000 --> 00:00:03,195
>> مرحبًا بكم مرة أخرى.
الكمية الموجهة بشكل أساسي هي

2
00:00:03,195 --> 00:00:07,315
فن التخلص من المجلدات
الصريحة في التعليمات البرمجية.

3
00:00:07,315 --> 00:00:11,835
في عصر التعلم العميق، السلامة
في التعلم العميق في الممارسة،

4
00:00:11,835 --> 00:00:15,210
غالبًا ما تجد نفسك تتدرب على
مجموعات كبيرة نسبيًا من البيانات،

5
00:00:15,210 --> 00:00:18,475
لأن ذلك عندما تميل خوارزميات
التعلم العميق إلى التألق.

6
00:00:18,475 --> 00:00:22,790
وبالتالي، من المهم أن يتم تغيير
التعليمات البرمجية بسرعة كبيرة،

7
00:00:22,790 --> 00:00:24,525
وإلّا إذا كانت تعمل على مجموعة بيانات كبيرة،

8
00:00:24,525 --> 00:00:27,000
فقد يستغرق تشغيل التعليمات البرمجية وقتًا طويلاً، ثم تجد

9
00:00:27,000 --> 00:00:30,255
نفسك تنتظر وقتًا طويلاً جدًا للوصول إلى النتيجة.

10
00:00:30,255 --> 00:00:32,035
إذًا، في عصر التعلم العميق،

11
00:00:32,035 --> 00:00:37,490
أعتقد أن القدرة على تنفيذ الكمية
الموجهة أصبحت مهارة أساسية.

12
00:00:37,490 --> 00:00:40,010
لنبدأ بمثال.

13
00:00:40,010 --> 00:00:42,225
إذًا، ماذا تكون الكمية الموجهة؟

14
00:00:42,225 --> 00:00:48,780
في الانحدار اللوجستي، تحتاج إلى حساب
Z يساوي W منقولة X زائد B،

15
00:00:48,780 --> 00:00:55,405
حيث W كان هذا المتجه العمود
وX هو أيضًا هذا المتجه.

16
00:00:55,405 --> 00:00:58,000
ربما تكون هناك متجهات كبيرة
جدًا إذا كان لديك الكثير من الخصائص.

17
00:00:58,000 --> 00:01:07,080
إذًا، W وX هما متجها الأبعاد Rn أو RNX.

18
00:01:07,080 --> 00:01:10,170
إذًا، لحساب W منقولة X،

19
00:01:10,170 --> 00:01:15,660
إذا كان لديك تنفيذ غير موجه،

20
00:01:15,660 --> 00:01:18,725
فستقوم بعمل شيء مثل Z يساوي صفر.

21
00:01:18,725 --> 00:01:24,860
ومن ثم I في نطاق X.

22
00:01:24,860 --> 00:01:27,330
إذًا، I يساوي 1، 2 NX،

23
00:01:27,330 --> 00:01:34,040
Z + يساوي W I في XI.

24
00:01:34,040 --> 00:01:37,100
ومن ثم، ربما تقوم بـ Z +
يساوي B في النهاية.

25
00:01:37,100 --> 00:01:39,855
إذًا، هذا تنفيذ غير موجه.

26
00:01:39,855 --> 00:01:43,090
ثم ستجد أن هذا سيكون بطيئًا جدًا.

27
00:01:43,090 --> 00:01:48,560
على النقيض من ذلك، فإن التنفيذ الموجه
سوف يحسب W منقولة X مباشرة.

28
00:01:48,560 --> 00:01:52,085
في بايثون أو نمباي،

29
00:01:52,085 --> 00:02:01,428
الأمر الذي تستخدمه هو Z يساوي np.W،

30
00:02:01,428 --> 00:02:06,270
X، بحيث يقوم ذلك بحساب W منقولة X.

31
00:02:06,270 --> 00:02:09,075
ويمكنك أيضًا إضافة B إلى ذلك مباشرةً.

32
00:02:09,075 --> 00:02:12,400
وستجد أن هذا أسرع بكثير.

33
00:02:12,400 --> 00:02:17,075
دعونا في الواقع نوضح هذا بعرض توضيحي بسيط.

34
00:02:17,075 --> 00:02:21,960
إذًا، هذا Jupiter notebook الذي
سأكتب فيه بعض تعليمات بايثون البرمجية.

35
00:02:21,960 --> 00:02:28,041
إذًا، أولاً، دعني أستورد مكتبة نمباي للاستيراد.

36
00:02:28,041 --> 00:02:30,000
إرسال P. إذًا، على سبيل المثال،

37
00:02:30,000 --> 00:02:36,570
يمكنني إنشاء A كمصفوفة على النحو التالي.

38
00:02:36,570 --> 00:02:39,560
لنفترض أنها print a.

39
00:02:39,560 --> 00:02:41,160
الآن، بعد أن كتبت هذا الجزء
من التعليمات البرمجية،

40
00:02:41,160 --> 00:02:43,170
إذا ضغطت على shift + enter،

41
00:02:43,170 --> 00:02:44,847
يتم تنفيذ التعليمات البرمجية.

42
00:02:44,847 --> 00:02:47,970
إذًا، تم إنشاء المصفوفة A وطباعتها.

43
00:02:47,970 --> 00:02:50,580
إذًا، دعنا نُجري العرض التوضيحي
على الكمية الموجهة.

44
00:02:50,580 --> 00:02:51,990
سأقوم باستيراد المكتبات الزمنية،

45
00:02:51,990 --> 00:02:53,580
لأننا نستخدم ذلك،

46
00:02:53,580 --> 00:02:56,565
من أجل تحديد الوقت الذي
تستغرقه العمليات المختلفة.

47
00:02:56,565 --> 00:02:59,139
هل يمكنها إنشاء مصفوفة A؟

48
00:02:59,139 --> 00:03:02,905
تلك جولة تفكير عشوائي.

49
00:03:02,905 --> 00:03:10,065
هذا يولّد مصفوفة أبعاد مليونية ذات قيم عشوائية.

50
00:03:10,065 --> 00:03:13,300
b = np.random.rand.

51
00:03:13,300 --> 00:03:16,120
مصفوفة أبعاد مليونية أخرى.

52
00:03:16,120 --> 00:03:20,810
والآن، tic=time.time، إذًا هذا
يقيس الوقت الحالي،

53
00:03:20,810 --> 00:03:26,395
c = np.dot (a, b)‎.

54
00:03:26,395 --> 00:03:28,649
toc = time.time.

55
00:03:28,649 --> 00:03:31,950
وهذه الطبعة،

56
00:03:31,950 --> 00:03:34,857
هي النسخة الموجهة.

57
00:03:34,857 --> 00:03:37,685
إنها نسخة موجهة.

58
00:03:37,685 --> 00:03:41,985
إذًا دعنا نُجري الطباعة.

59
00:03:41,985 --> 00:03:45,060
دعنا نرى المرة الأخيرة،

60
00:03:45,060 --> 00:03:48,330
إذًا toc - tic x 1000،

61
00:03:48,330 --> 00:03:52,075
بحيث يمكننا التعبير عن هذا بالمللي ثانية.

62
00:03:52,075 --> 00:03:54,075
إذًا، ms يعني مللي ثانية.

63
00:03:54,075 --> 00:03:56,435
سوف أضغط على Shift + Enter.

64
00:03:56,435 --> 00:04:01,890
إذًا، استغرقت هذه التعليمات البرمجية
حوالي 3 مللي ثانية أو هذه المرة 1,5،

65
00:04:01,890 --> 00:04:06,170
ربما حوالي 1,5 أو 3,5 مللي ثانية في المرة الواحدة.

66
00:04:06,170 --> 00:04:08,370
يختلف الأمر قليلاً عند تشغيلها،

67
00:04:08,370 --> 00:04:12,085
ولكن يبدو أنها في المتوسط
قد تستغرق 1,5 مللي ثانية،

68
00:04:12,085 --> 00:04:15,665
وربما 2 مللي ثانية أثناء تشغيل هذا.

69
00:04:15,665 --> 00:04:16,967
حسنًا.

70
00:04:16,967 --> 00:04:19,005
دعونا نستمر في الإضافة إلى
هذه الكتلة من التعليمات البرمجية.

71
00:04:19,005 --> 00:04:22,270
هذا لا ينفّذ نسخة غير موجهة.

72
00:04:22,270 --> 00:04:24,151
لنرى، c = 0،

73
00:04:24,151 --> 00:04:27,750
ثم tic = time.time.

74
00:04:27,750 --> 00:04:29,335
الآن، دعونا ننفذ مجلدًا.

75
00:04:29,335 --> 00:04:35,348
بالنسبة لـ I في نطاق 1 مليون،

76
00:04:35,348 --> 00:04:38,676
سوف أختر عدد الأصفار الصحيح.

77
00:04:38,676 --> 00:04:43,936
C += (a,i) x (b,‎

78
00:04:43,936 --> 00:04:50,775
i)، ثم toc = time.time.

79
00:04:50,775 --> 00:04:57,725
أخيرًا، اطبع أكثر من حلقة كاملة صريحة.

80
00:04:57,725 --> 00:05:15,225
الوقت الذي يستغرقه هذا هو
‎1000 x toc - tic + "ms"‎

81
00:05:15,225 --> 00:05:17,505
لمعرفة أننا نفعل هذا بالمللي ثانية.

82
00:05:17,505 --> 00:05:19,735
لنفعل شيئًا آخر.

83
00:05:19,735 --> 00:05:22,802
دعنا فقط نطبع قيمة C التي

84
00:05:22,802 --> 00:05:27,960
نحسبها للتأكد من أنها نفس القيمة في كلتا الحالتين.

85
00:05:27,960 --> 00:05:35,770
سأضغط على shift + enter
لتشغيل هذا والتحقق من ذلك.

86
00:05:35,770 --> 00:05:38,305
في كلتا الحالتين، تحسب النسخة الموجهة

87
00:05:38,305 --> 00:05:41,125
والنسخة غير الموجهة القيم نفسها،

88
00:05:41,125 --> 00:05:45,355
كما تعلم، من 2,50 إلى 6,99، وهكذا.

89
00:05:45,355 --> 00:05:48,670
استغرقت النسخة الموجهة 1,5 مللي ثانية.

90
00:05:48,670 --> 00:05:57,555
استغرقت حلقة for الصريحة والنسخة
غير الموجهة حوالي 400، تقريبًا 500 مللي ثانية.

91
00:05:57,555 --> 00:06:01,285
استغرقت النسخة غير الموجهة ما يقرب من 300

92
00:06:01,285 --> 00:06:05,660
مرة أطول من النسخة الموجهة.

93
00:06:05,660 --> 00:06:11,230
في هذا المثال سترى أنه إذا كنت تتذكر
فقط توجيه التعليمات البرمجية الخاصة بك،

94
00:06:11,230 --> 00:06:15,120
يتم تشغيل التعليمات البرمجية الخاصة بك
في الواقع بمعدل أسرع بمقدار 300 مرة.

95
00:06:15,120 --> 00:06:16,540
لنقم بتشغيلها مرة أخرى.

96
00:06:16,540 --> 00:06:18,930
لنقم بتشغيلها مرة أخرى فقط.

97
00:06:18,930 --> 00:06:22,235
بلى. النسخة الموجهة 1,5 مللي
ثانية أسرع من حلقة for.

98
00:06:22,235 --> 00:06:25,960
إذًا 481 مللي ثانية، مرة أخرى،

99
00:06:25,960 --> 00:06:29,535
حوالي 300 مرة أبطأ من تنفيذ حلقة for صريحة.

100
00:06:29,535 --> 00:06:30,980
إذا كان المحرك x يُبطئ العملية،

101
00:06:30,980 --> 00:06:33,880
فالفرق بين الوقت الذي يستغرقه تشغيل
تعليماتك البرمجية ربما يصل إلى دقيقة واحدة

102
00:06:33,880 --> 00:06:37,615
مقابل استهلاك خمس ساعات تقريبًا للتشغيل.

103
00:06:37,615 --> 00:06:41,410
وعندما تقوم بتطبيق خوارزميات التعلم العميق،

104
00:06:41,410 --> 00:06:43,300
يمكنك حقًا التوصل إلى نتيجة أسرع.

105
00:06:43,300 --> 00:06:46,590
سيكون ذلك أسرع بكثير إذا قمت
بتوجيه تعليماتك البرمجية.

106
00:06:46,590 --> 00:06:49,300
ربما سمع بعضكم أن الكثير من

107
00:06:49,300 --> 00:06:54,260
تطبيقات التعلم العميق القابلة للتطبيق تتم
على "جي بي يو" أو وحدة معالجة الرسومات.

108
00:06:54,260 --> 00:06:59,515
ولكن كل العروض التوضيحية التي أجريتها حتى الآن في
Jupiter notebook كانت في الواقع على وحدة المعالجة المركزية.

109
00:06:59,515 --> 00:07:04,530
وتبين أن كلاً من وحدة معالجة الرسومات
ووحدة المعالجة المركزية لديهما تعليمات توازي.

110
00:07:04,530 --> 00:07:07,530
إنها تسمى أحيانًا تعليمات "إس آي إم دي".

111
00:07:07,530 --> 00:07:11,190
وهذا يرمز إلى بيانات متعددة لتعليمة واحدة.

112
00:07:11,190 --> 00:07:13,045
لكن ما يعنيه هذا بشكل أساسي هو أنه

113
00:07:13,045 --> 00:07:16,835
إذا كنت تستخدم دوال مضمّنة مثل

114
00:07:16,835 --> 00:07:23,495
دالة ".np" أو دوال أخرى لا تتطلب
منك تنفيذ حلقة "for" بشكل صريح.

115
00:07:23,495 --> 00:07:28,150
إنها تمكن بايثون باي من الاستفادة

116
00:07:28,150 --> 00:07:33,640
بشكل أفضل من التوازي للقيام بحساباتك بشكل أسرع.

117
00:07:33,640 --> 00:07:38,610
وهذا صحيح لكل من الحسابات في وحدات المعالجة
المركزية والحسابات في وحدات معالجة الرسومات.

118
00:07:38,610 --> 00:07:41,070
إنها مجرد وحدات معالجة رسومات جيدة بشكل ملحوظ في

119
00:07:41,070 --> 00:07:44,980
حسابات SIMD هذه ولكن وحدة المعالجة المركزية
في الواقع ليست سيئة للغاية في ذلك.

120
00:07:44,980 --> 00:07:47,510
ربما ليست جيدة مثل وحدات معالجة الرسومات.

121
00:07:47,510 --> 00:07:51,660
أنت ترى كيف يمكن أن يؤدي التوجيه إلى تسريع
التعليمات البرمجية بشكل ملحوظ.

122
00:07:51,660 --> 00:07:54,685
القاعدة الأساسية هي أن تتذكر أنه
كلما كان ذلك ممكنًا،

123
00:07:54,685 --> 00:07:57,425
تجنب استخدام حلقات for صريحة.

124
00:07:57,425 --> 00:07:59,980
دعنا نذهب إلى الفيديو التالي لنرى
مزيدًا من الأمثلة عن

125
00:07:59,980 --> 00:08:04,000
التوجيه وأيضًا البدء في توجيه الانحدار اللوجستي.