>> مرحبًا بكم مرة أخرى.
الكمية الموجهة بشكل أساسي هي فن التخلص من المجلدات
الصريحة في التعليمات البرمجية. في عصر التعلم العميق، السلامة
في التعلم العميق في الممارسة، غالبًا ما تجد نفسك تتدرب على
مجموعات كبيرة نسبيًا من البيانات، لأن ذلك عندما تميل خوارزميات
التعلم العميق إلى التألق. وبالتالي، من المهم أن يتم تغيير
التعليمات البرمجية بسرعة كبيرة، وإلّا إذا كانت تعمل على مجموعة بيانات كبيرة، فقد يستغرق تشغيل التعليمات البرمجية وقتًا طويلاً، ثم تجد نفسك تنتظر وقتًا طويلاً جدًا للوصول إلى النتيجة. إذًا، في عصر التعلم العميق، أعتقد أن القدرة على تنفيذ الكمية
الموجهة أصبحت مهارة أساسية. لنبدأ بمثال. إذًا، ماذا تكون الكمية الموجهة؟ في الانحدار اللوجستي، تحتاج إلى حساب
Z يساوي W منقولة X زائد B، حيث W كان هذا المتجه العمود
وX هو أيضًا هذا المتجه. ربما تكون هناك متجهات كبيرة
جدًا إذا كان لديك الكثير من الخصائص. إذًا، W وX هما متجها الأبعاد Rn أو RNX. إذًا، لحساب W منقولة X، إذا كان لديك تنفيذ غير موجه، فستقوم بعمل شيء مثل Z يساوي صفر. ومن ثم I في نطاق X. إذًا، I يساوي 1، 2 NX، Z + يساوي W I في XI. ومن ثم، ربما تقوم بـ Z +
يساوي B في النهاية. إذًا، هذا تنفيذ غير موجه. ثم ستجد أن هذا سيكون بطيئًا جدًا. على النقيض من ذلك، فإن التنفيذ الموجه
سوف يحسب W منقولة X مباشرة. في بايثون أو نمباي، الأمر الذي تستخدمه هو Z يساوي np.W، X، بحيث يقوم ذلك بحساب W منقولة X. ويمكنك أيضًا إضافة B إلى ذلك مباشرةً. وستجد أن هذا أسرع بكثير. دعونا في الواقع نوضح هذا بعرض توضيحي بسيط. إذًا، هذا Jupiter notebook الذي
سأكتب فيه بعض تعليمات بايثون البرمجية. إذًا، أولاً، دعني أستورد مكتبة نمباي للاستيراد. إرسال P. إذًا، على سبيل المثال، يمكنني إنشاء A كمصفوفة على النحو التالي. لنفترض أنها print a. الآن، بعد أن كتبت هذا الجزء
من التعليمات البرمجية، إذا ضغطت على shift + enter، يتم تنفيذ التعليمات البرمجية. إذًا، تم إنشاء المصفوفة A وطباعتها. إذًا، دعنا نُجري العرض التوضيحي
على الكمية الموجهة. سأقوم باستيراد المكتبات الزمنية، لأننا نستخدم ذلك، من أجل تحديد الوقت الذي
تستغرقه العمليات المختلفة. هل يمكنها إنشاء مصفوفة A؟ تلك جولة تفكير عشوائي. هذا يولّد مصفوفة أبعاد مليونية ذات قيم عشوائية. b = np.random.rand. مصفوفة أبعاد مليونية أخرى. والآن، tic=time.time، إذًا هذا
يقيس الوقت الحالي، c = np.dot (a, b)‎. toc = time.time. وهذه الطبعة، هي النسخة الموجهة. إنها نسخة موجهة. إذًا دعنا نُجري الطباعة. دعنا نرى المرة الأخيرة، إذًا toc - tic x 1000، بحيث يمكننا التعبير عن هذا بالمللي ثانية. إذًا، ms يعني مللي ثانية. سوف أضغط على Shift + Enter. إذًا، استغرقت هذه التعليمات البرمجية
حوالي 3 مللي ثانية أو هذه المرة 1,5، ربما حوالي 1,5 أو 3,5 مللي ثانية في المرة الواحدة. يختلف الأمر قليلاً عند تشغيلها، ولكن يبدو أنها في المتوسط
قد تستغرق 1,5 مللي ثانية، وربما 2 مللي ثانية أثناء تشغيل هذا. حسنًا. دعونا نستمر في الإضافة إلى
هذه الكتلة من التعليمات البرمجية. هذا لا ينفّذ نسخة غير موجهة. لنرى، c = 0، ثم tic = time.time. الآن، دعونا ننفذ مجلدًا. بالنسبة لـ I في نطاق 1 مليون، سوف أختر عدد الأصفار الصحيح. C += (a,i) x (b,‎ i)، ثم toc = time.time. أخيرًا، اطبع أكثر من حلقة كاملة صريحة. الوقت الذي يستغرقه هذا هو
‎1000 x toc - tic + "ms"‎ لمعرفة أننا نفعل هذا بالمللي ثانية. لنفعل شيئًا آخر. دعنا فقط نطبع قيمة C التي نحسبها للتأكد من أنها نفس القيمة في كلتا الحالتين. سأضغط على shift + enter
لتشغيل هذا والتحقق من ذلك. في كلتا الحالتين، تحسب النسخة الموجهة والنسخة غير الموجهة القيم نفسها، كما تعلم، من 2,50 إلى 6,99، وهكذا. استغرقت النسخة الموجهة 1,5 مللي ثانية. استغرقت حلقة for الصريحة والنسخة
غير الموجهة حوالي 400، تقريبًا 500 مللي ثانية. استغرقت النسخة غير الموجهة ما يقرب من 300 مرة أطول من النسخة الموجهة. في هذا المثال سترى أنه إذا كنت تتذكر
فقط توجيه التعليمات البرمجية الخاصة بك، يتم تشغيل التعليمات البرمجية الخاصة بك
في الواقع بمعدل أسرع بمقدار 300 مرة. لنقم بتشغيلها مرة أخرى. لنقم بتشغيلها مرة أخرى فقط. بلى. النسخة الموجهة 1,5 مللي
ثانية أسرع من حلقة for. إذًا 481 مللي ثانية، مرة أخرى، حوالي 300 مرة أبطأ من تنفيذ حلقة for صريحة. إذا كان المحرك x يُبطئ العملية، فالفرق بين الوقت الذي يستغرقه تشغيل
تعليماتك البرمجية ربما يصل إلى دقيقة واحدة مقابل استهلاك خمس ساعات تقريبًا للتشغيل. وعندما تقوم بتطبيق خوارزميات التعلم العميق، يمكنك حقًا التوصل إلى نتيجة أسرع. سيكون ذلك أسرع بكثير إذا قمت
بتوجيه تعليماتك البرمجية. ربما سمع بعضكم أن الكثير من تطبيقات التعلم العميق القابلة للتطبيق تتم
على "جي بي يو" أو وحدة معالجة الرسومات. ولكن كل العروض التوضيحية التي أجريتها حتى الآن في
Jupiter notebook كانت في الواقع على وحدة المعالجة المركزية. وتبين أن كلاً من وحدة معالجة الرسومات
ووحدة المعالجة المركزية لديهما تعليمات توازي. إنها تسمى أحيانًا تعليمات "إس آي إم دي". وهذا يرمز إلى بيانات متعددة لتعليمة واحدة. لكن ما يعنيه هذا بشكل أساسي هو أنه إذا كنت تستخدم دوال مضمّنة مثل دالة ".np" أو دوال أخرى لا تتطلب
منك تنفيذ حلقة "for" بشكل صريح. إنها تمكن بايثون باي من الاستفادة بشكل أفضل من التوازي للقيام بحساباتك بشكل أسرع. وهذا صحيح لكل من الحسابات في وحدات المعالجة
المركزية والحسابات في وحدات معالجة الرسومات. إنها مجرد وحدات معالجة رسومات جيدة بشكل ملحوظ في حسابات SIMD هذه ولكن وحدة المعالجة المركزية
في الواقع ليست سيئة للغاية في ذلك. ربما ليست جيدة مثل وحدات معالجة الرسومات. أنت ترى كيف يمكن أن يؤدي التوجيه إلى تسريع
التعليمات البرمجية بشكل ملحوظ. القاعدة الأساسية هي أن تتذكر أنه
كلما كان ذلك ممكنًا، تجنب استخدام حلقات for صريحة. دعنا نذهب إلى الفيديو التالي لنرى
مزيدًا من الأمثلة عن التوجيه وأيضًا البدء في توجيه الانحدار اللوجستي.