이전 비디오에서 vectorization이 
내장된 기능을 이용하고 일정한 for-loop 사용을 피하여 코드의 속도를 높일 수 있는 몇 가지 예를 보셨을 겁니다 또 다른 예시를 보겠습니다. 새로운 네트워크를 프로그래밍하는데 있어 또는 회귀를 프로그래밍 하는데 있어 경험을 근거한 규칙은 가능한 한 일정한 for-loop를 피하는 것입니다. for-loop를 완전히 사용하지 않는 
것은 항상 가능한 것은 아닌데요, 가능하면 내장된 기능을 이용하거나 계산을 필요로 하는 경우, 다른 방법을 찾으면 일정한 for-loop가 있는 것보다 
훨씬 더 빨리 처리가 가능할 것입니다. 다른 예제를 보시죠. A 매트릭스의 곱셈으로 언제든 
벡터 u를 계산하고 싶은 경우에는, 그리고 벡터 v를 계산하고 싶은 경우에는, 매트릭스 곱셈의 정의는 Ui= ∑/j, A/j , V/j 합니다. 좋아요. 이렇게 Ui를 정의합니다. 그렇게해서 non-vector형 도입은 U= np.zeros(n, 1)가 되도록 설정하는 것입니다. (n, i) 이죠. i에 대해서 말이죠. 이것은 j에 대해서 이고요. 그러면 u[i] + a[i][j] 곱하기 v[j]가 됩니다. 그러면 이것이 2개의 for-loop인데요, 
I와 j를 looping하고 있습니다. I와 j를 looping하고 있습니다. u= np.(A, v)가 되도록 벡터 
형으로 도입한 경우입니다. 오른쪽처럼 벡터형 버전으로 도입한 것은 2개의 다른 for-loop를 제거하고 훨씬 더 빨라질 것입니다. 다른 사례를 보겠습니다. v라는 벡터가 이미 메모리에 있다고 해봅시다. 지수의 방법을 벡터 v의 모든 
요소에 적용시키고 싶습니다. 그러면 u가 벡터가 되게 해서, 즉 e의 v1승, e의 v2, 등등 e의 vn승이 될 때까지요. 이것이 논벡터형 도입인데요. 처음에는 u의 벡터 0으로 초기화를 시킵니다. 그 다음, for-loop이 
요소들을 각각 1개씩 계산해줍니다. 하지만 파이썬과 넘파이에서는 
이미 수 많은 내장된 기능을 통해 함수에서 한번의 명령만으로 
이러한 벡터들을 계산하는 방법이 있는데요, 그렇기 때문에 저 같은 경우엔, 
불러온 값 넘파이를 np로 도입해서 그냥 u= np.exp(v)로 부르는 것입니다. 이전에는 v의 입력값 벡터, u의 결과값 벡터로, 1가지 라인의 코드로 이루어진, 일정한 for-loop가 있었지만, 이제는 일정한 for-loop를 제거하여 
오른쪽처럼 도입하여 일정한 for-loop를 필요로 하는 
것보다 훨씬 더 빨리 처리가 가능합니다. 사실 넘파이 library에는 
벡터의 값으로 된함수가 많습니다. 그러므로 np.log (v)는 element-wise log를계산하고 np.abs는 절대값을 계산할 것입니다. np.maximum는 element-wise maximum 계산하여 v의 모든 요소에 대한 최대값을 0으로 할 것입니다. v**2 는 v의 각각의 요소에 대해서 
element-wise의 제곱으로 합니다. 1 나누기 v는 element-wise를 거꾸로 그 값을 갖습니다. 그러므로, 여러분이 for-loop를 쓰고 싶은 경우에는 넘파이 의 내장된 기능이 for-loop없이 처리할 수 있는지 먼저 보시기 바랍니다. 이제까지 배운 것을 취합해서 로지스틱 회귀분석법, 
기울기 강하 도입에 적용해서 적어도 2개중 1개의 for-loop을 
제거할 수 있는지 보겠습니다. 여기는 로지스틱 회귀분석법에서 
derivative를 계산하는 코드인데요. 여기서는 2개의 for-loop가 있었습니다. 하나는 여기 위에 있는 것이고, 
2번째 것은 이것입니다. 예제에서는, nx가 2인데요, 2개의 특성보다 더 많은 경우, for-loop가 dw1, dw2, dw3 
등등에 있어야 할 것입니다. for-loop가 dw1, dw2, dw3 
등등에 있어야 할 것입니다. 그렇기 때문에 마치 4j는 1, 2, 그리고 x인 것처럼 dWj가 업데이트 됩니다. 우리는 이 2번째 for-loop를 제거하고 싶은데요 이번 슬라이드에서 해보겠습니다. 하는 방법은, 일단은 대놓고 
dw1, dw2 등등을 0으로 초기화시키기 보다는 하는 방법은, 일단은 대놓고 
dw1, dw2 등등을 0으로 초기화시키기 보다는 이것을 먼저 제거하고 dw를 벡터로 만들겠습니다. 그러면 dw를 np.zeros가 되게 만들고 이 nx를 1차원 벡터로 만들겠습니다. 그러면 여기서 개인 요소에 대한 for-loop 대신에 그러면 여기서 개인 요소에 대한 for-loop 대신에 이 벡터 값 방법을 사용하겠습니다. dw 플러스는 xi 곱하기 dz(i) 말이죠. dw 플러스는 xi 곱하기 dz(i) 말이죠. 그리고 마지막으로, 이것 대신에 dw 나누기가 m이 되도록 하겠습니다. 
이렇게 해서 for-loop가 2개에서 1개가 되었는데요, 아직까지 각각의 트레이닝 예시에 
대한 1개의 for-loop가 있습니다. 저는 이 비디오가 vectorization에 대한 개념을 이해하는데 도움이 되셨으면 좋겠습니다. 그리고 1개의 for-loop를 제거하여 
이제는 코디가 훨씬 더 빨리 운영될 것입니다. 하지만 더 잘할 수 있죠, 다음 비디오에서는 로지스틱 회귀분석을 벡터화시키는 
방법에 대해 더욱 자세히 다루겠습니다. 여러분들은 트레이닝 example에서 
for-loop의 사용 없이도 전체적인 트레이닝 세트를 코드화시킬 
수 있다는 조금 놀라운 결과를 보셨는데요. 전체적인 트레이닝 세트를 코드화시킬 
수 있다는 조금 놀라운 결과를 보셨는데요. 이 모든 것을 한번에 이룰 수 있는데요. 다음 비디오에서 보도록 하겠습니다.