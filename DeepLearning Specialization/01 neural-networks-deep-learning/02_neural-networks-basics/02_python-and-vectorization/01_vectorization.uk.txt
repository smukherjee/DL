З поверненням! Векторизація, по суті, - це мистецтво позбутись від явних циклів for в коді. В еру глибокого навчання (ГН) і, зокрема, в практиці ГН ми часто змушені тренувати відносно великі набори даних, тому що ГН найкраще себе в цьому проявляє. Тож, дуже важливо, щоб наш код був швидким. Інакше, якщо він обробляє великий набір даних, він буде виконуватись дуже довго і ми будемо змушені просто довго чекати поки отримаємо результат. Тож в еру ГН, думаю, уміння застосовувати векторизацію стало ключовою навичкою. Давай почнемо з прикладу. Що ж таке векторизація? Для логістичної регресії (ЛР) нам треба було обчислити z=w.T*x+b, де w - ось цей стовпчиковий вектор, а x - ось цей вектор. Вони можуть бути дуже великими векторами, якщо у тебе є багато ознак. Отже, w та x були отакими векторами R 
(множина дійсних чисел) розміром n або nₓ. Тож, щоб обчислити w транспоноване і помножене на x невекторизованим способом, ми мали зробити щось таке: z=0; далі for i in range(n_x) для i = 1,2..n_x; z+=w[i]*x[i]; і далі, вкінці, щось типу z+=b. Тож це - невекторизований спосіб. Далі ми помічаємо, що це виконується досить повільно. На противагу йому, векторизований спосіб безпосередньо обчислює wᵀx. В Python, або numpy, ми можемо використати команду z=np.dot(w, x), яка обчислить wᵀx. І ми також можемо просто безпосередньо додати b. Ти помітиш, що це набагато швидше. Давай проведемо невеличку демонстрацію. Отже, ось мій записник Jupyter, в якому я збираюсь написати трохи Python коду. Тож, спочатку, я імпортую бібліотеку numpy: import numpy as np. І, для прикладу, я можу створити масив a ось так. Давай виведемо a. Тепер, коли цей шматок коду написано, якщо я натисну Shift+Enter, Jupiter виконає цей код. Тож він створив масив a і вивів його. Тепер давай продемонструємо векторизацію. Я імпортую бібліотеку time. оскільки вона необхідна для обчислення скільки часу займають операції. Далі можу створити масив a, що =np.random.rand(1000000). Це створить масив випадкових чисел розміром 1 000 000. b=np.random.rand(1000000). Ще один масив розміром 1 000 000. Тепер tic=time.time(), що повертає поточний час. c=np.dot(a,b). toc=time.time(). І print(). Це - векторизований спосіб. Vectorized version: І, давай виведемо це. Обчислимо тривалість. А це - (toc-tic)*1000 (щоб ми могли виразити результат в мілісекундах). Тож ms - це мілісекунди. І я натискаю Shift+Enter. Отож, цей код виконувався приблизно 3 мілісекунди. Цього разу 1,5мс. Добре. Тож виконання коду триває 1,5-3,5мс. Час дещо відрізняється кожного разу, але схоже на те, що ця операція триває приблизно 1,5мс. Можливо, 2мс. Добре. Давай допишемо в цей блок ще використання невекторизованого способу. c=0. тоді tic=time.time(). Тепер додамо цикл for: for i in range(1000000). Так, я правильно підібрав кількість нулів. c+=a[i]*b[i]. Тоді toc=time.time(). І, нарешті: print, явний цикл for, тривалість 1000*(toc-tic) плюс "ms" (щоб позначити те, що ми робимо мілісекундами). Ну і давай зробимо ще одну річ. Давай виведемо значення c, яке ми обчислюємо, щоб бути впевненими, що воно однакове в обох випадках. Добре. Отже, зараз я натисну Shift+Enter, щоб виконати і перевірити. В обох випадках, векторизованому і невекторизованому способах обчислення, - однакові значення - 250286,989 і далі. Векторизований спосіб зайняв 1,5мс. Явний цикл for (невекторизований спосіб) зайняв 400, майже 500мс. Невекторизований спосіб зайняв приблизно в 300 більше часу ніж векторизований. На цьому прикладі ми бачимо, що якщо не забувати векторизувати свій код, він буде виконуватись більш ніж у 300 разів швидше. Давай ще раз його виконаємо. І ще раз. Так, векторизований спосіб - 1,5мс, а цикл for зайняв 481мс. Тож знову приблизно в 300 разів повільніше користуватись явним циклом for. Отже, якщо якийсь комп'ютер x працює повільно (а є різниця коли твій код виконується 1 хвилину, а не, скажімо, 5 годин)... Коли ми застосовуємо алгоритми ГН, то можемо отримувати результат швидше, значно швидше, якщо векторизуємо свій код. Дехто з вас може чув, що багато масштабних застосувань ГН виконуються на GPU, або графічному процесорі. Проте, все, що я щойно продемонстрував в записнику Jupyter, виконувалось на CPU. Виявляється, що і GPU і CPU мають інструкції паралелізації. Вони ще називаються інструкціями SIMD. Що означає "одна інструкція - багато даних" [Single Instruction Multiple Data]. По суті, це означає, що якщо використовувати вбудовані функції як np.function() або інші функції, які не вимагають використання явного циклу for, це дозволяє Python numpy скористатись перевагами паралелізму, щоб прискорити обчислення. І це справджується для обчислень як на GPU, так і на CPU. Просто GPU дуже добре справляються з інструкціями SIMD, але CPU теж непогано це роблять. Просто, можливо, не так добре як GPU. Тепер ти переконався/лась, що векторизація значно прискорює код. Варто пам'ятати, що якщо можливо, то треба уникати використання явних циклів for. Давай перейдемо до наступного відео, що побачити більше прикладів векторизації і також почати векторизувати ЛР.