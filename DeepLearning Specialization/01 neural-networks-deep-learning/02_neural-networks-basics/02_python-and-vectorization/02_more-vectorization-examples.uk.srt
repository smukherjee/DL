1
00:00:00,000 --> 00:00:05,340
В попередньому відео ти бачив/ла кілька прикладів 
як векторизація, використовуючи

2
00:00:05,340 --> 00:00:07,770
вбудовані функції і уникаючи явних

3
00:00:07,770 --> 00:00:11,130
циклів for, дозволяє значно пришвидшити код.

4
00:00:11,130 --> 00:00:13,558
Давай розглянемо ще кілька прикладів.

5
00:00:13,558 --> 00:00:16,110
Практичне правило, яке варто запам'ятати, це коли ми

6
00:00:16,110 --> 00:00:19,792
програмуємо нейронну мережу (НМ) або логістичну регресію (ЛР)

7
00:00:19,792 --> 00:00:23,190
завжди, коли це можливо, треба уникати явних циклів for.

8
00:00:23,190 --> 00:00:27,285
Звичайно, взагалі не використовувати цикл for - не завжди можливо.

9
00:00:27,285 --> 00:00:29,520
Проте, використовуючи вбудовані функції або

10
00:00:29,520 --> 00:00:32,710
інші способи необхідних обчислень,

11
00:00:32,710 --> 00:00:36,555
це часто буде швидше ніж циклом for.

12
00:00:36,555 --> 00:00:38,445
Давай розглянемо приклад.

13
00:00:38,445 --> 00:00:44,412
Якщо ми хочемо обчислити вектор u, що є добутком матриці A

14
00:00:44,412 --> 00:00:46,144
і іншого вектору v,

15
00:00:46,144 --> 00:00:50,840
то за визначенням множення матриць наш вектор

16
00:00:50,840 --> 00:00:55,830
uᵢ= сумі по j для Aᵢⱼvⱼ.

17
00:00:55,830 --> 00:00:57,050
Правильно?

18
00:00:57,050 --> 00:00:58,445
Так ми визначаємо uᵢ.

19
00:00:58,445 --> 00:01:01,500
Невекторизована реалізація цього

20
00:01:01,500 --> 00:01:06,140
буде u=np.zeros(n, 1)

21
00:01:06,140 --> 00:01:08,105
u=np.zeros(n, 1).

22
00:01:08,105 --> 00:01:11,745
І далі "for i" і так далі,

23
00:01:11,745 --> 00:01:14,250
"for j" і так далі.

24
00:01:14,250 --> 00:01:22,950
Так? І далі u[i]+=A[i][j]*v[j].

25
00:01:22,950 --> 00:01:27,725
Тож ми маємо 2 цикли for, що проходять для i та j.

26
00:01:27,725 --> 00:01:29,269
Тож це - невекторизована версія.

27
00:01:29,269 --> 00:01:37,355
Векторизована реалізація буде u=np.dot(A, v).

28
00:01:37,355 --> 00:01:39,160
Імплементація справа

29
00:01:39,160 --> 00:01:41,655
(векторизована версія) позбувається

30
00:01:41,655 --> 00:01:44,628
цих 2-ох циклів for і виконується набагато швидше.

31
00:01:44,628 --> 00:01:46,655
Давай розглянемо ще один приклад.

32
00:01:46,655 --> 00:01:50,900
Скажімо, ми вже маємо в пам'яті вектор v і хочемо

33
00:01:50,900 --> 00:01:55,190
застосувати експоненційну операцію для кожного елементу

34
00:01:55,190 --> 00:01:59,250
цього вектора. Тож ми обчислюємо u= вектор, 
що складається з e в степені v₁, e в степені v₂

35
00:01:59,250 --> 00:02:04,085
і так далі до e в степені vₙ.

36
00:02:04,085 --> 00:02:10,370
Тож це буде невекторизована реалізація, де ми спочатку

37
00:02:10,370 --> 00:02:13,700
ініціалізуємо u як нульовий вектор, далі маємо

38
00:02:13,700 --> 00:02:18,260
цикл for, що обчислює 1 елемент за 1 прохід.

39
00:02:18,260 --> 00:02:24,110
Проте, виявляється, що Python і NumPy 
мають багато вбудованих функцій, що дозволяють

40
00:02:24,110 --> 00:02:31,160
обчислювати ці вектори, викликавши всього одну функцію.

41
00:02:31,160 --> 00:02:40,180
Тож, щоб реалізувати це, я б зробив "import NumPy as np",

42
00:02:40,180 --> 00:02:50,110
а потім просто викликав "u=np.exp(v)". 
Відміть, що в той час як в попередньому випадку

43
00:02:50,110 --> 00:02:53,600
ми мали явний цикл for з лише одним рядком

44
00:02:53,600 --> 00:02:57,317
коду, то тут вектор v використовується як вхідний,

45
00:02:57,317 --> 00:02:58,840
а u - як результуючий.

46
00:02:58,840 --> 00:03:02,340
Ми позбулись явного циклу for і реалізація

47
00:03:02,340 --> 00:03:06,275
справа буде набагато швидшою ніж та, що з явним циклом for.

48
00:03:06,275 --> 00:03:10,310
Насправді, бібліотека NumPy має багато інших векторних функцій.

49
00:03:10,310 --> 00:03:15,175
Тож, "np.log(v)" обчислює логарифми поелементно,

50
00:03:15,175 --> 00:03:19,220
"np.abs(v)" обчислює абсолютні величини,

51
00:03:19,220 --> 00:03:24,935
"np.maximum(v, 0)" обчислює максимуми поелементно

52
00:03:24,935 --> 00:03:29,850
(можна обчислити максимуми відносно кожного елемента і 0),

53
00:03:29,850 --> 00:03:31,290
"v**2"

54
00:03:31,290 --> 00:03:38,214
підносить в квадрат поелементно кожен елемент v.

55
00:03:38,214 --> 00:03:42,932
"1/v" обчислює поелементно обернені числа і т.д.

56
00:03:42,932 --> 00:03:45,635
Тож, коли тобі хочеться використати цикл for -

57
00:03:45,635 --> 00:03:48,440
пошукай. Можливо,

58
00:03:48,440 --> 00:03:53,069
в NumPy є вбудована функція, яка зробить це без циклу for.

59
00:03:53,069 --> 00:03:55,640
Тож давай візьмемо всі ці знання і спробуємо застосувати їх

60
00:03:55,640 --> 00:03:59,105
до нашої ЛР для реалізації Градієнтного спуску

61
00:03:59,105 --> 00:04:02,955
і подивимось чи можемо ми позбутись одного-двох циклів for, 
які в нас є.

62
00:04:02,955 --> 00:04:07,980
Тож ось наш код для обчислення похідних для ЛР.

63
00:04:07,980 --> 00:04:09,335
Ми маємо 2 цикли for.

64
00:04:09,335 --> 00:04:13,065
Один - ось тут вгорі, а інший - ось тут. Так?

65
00:04:13,065 --> 00:04:15,422
Тож в нашому прикладі

66
00:04:15,422 --> 00:04:17,810
ми мали nₓ=2,

67
00:04:17,810 --> 00:04:19,910
але, якщо ми маємо більше ознак ніж

68
00:04:19,910 --> 00:04:23,865
просто 2, то нам потрібен цикл for для dw₁,

69
00:04:23,865 --> 00:04:25,676
dw₂, dw₃ і т.д.

70
00:04:25,676 --> 00:04:30,305
Тобто ми б мали тут "for j=1..nₓ"

71
00:04:30,305 --> 00:04:37,395
і коригували б dwⱼ - "dwⱼ+=...". Так?

72
00:04:37,395 --> 00:04:41,745
Тож ми хочемо позбутися цього другого циклу for.

73
00:04:41,745 --> 00:04:43,745
Ось що ми зробимо з цією лінією.

74
00:04:43,745 --> 00:04:48,725
Тож замість явної ініціалізації dw₁,

75
00:04:48,725 --> 00:04:51,390
dw₂ і т.д. в 0,

76
00:04:51,390 --> 00:04:58,100
ми позбудемось цього і запишемо dw як вектор.

77
00:04:58,100 --> 00:05:05,600
Тож ініціалізуємо "dw=np.zeros(nₓ, 1)"

78
00:05:05,600 --> 00:05:10,490
як вектор розмірністю nₓ*1.

79
00:05:10,490 --> 00:05:13,175
А тут, замість оцього

80
00:05:13,175 --> 00:05:15,941
циклу for для окремих компонентів,

81
00:05:15,941 --> 00:05:19,190
ми використаємо векторну операцію

82
00:05:19,190 --> 00:05:22,350
dw+=

83
00:05:22,350 --> 00:05:32,031
x⁽ⁱ⁾*dz⁽ⁱ⁾. І, нарешті,

84
00:05:32,031 --> 00:05:33,620
замість оцього запишемо

85
00:05:33,620 --> 00:05:42,562
dw/=m. Тож тепер замість 2-ох ми маємо всього 1 цикл for.

86
00:05:42,562 --> 00:05:48,864
У нас залишається оцей 1 цикл for 
для окремого тренувального зразка.

87
00:05:48,864 --> 00:05:51,030
Тож, надіюсь, це відео дало тобі розуміння суті

88
00:05:51,030 --> 00:05:54,165
векторизації і що, позбувшись 1-ого циклу for,

89
00:05:54,165 --> 00:05:56,505
твій код буде вже працювати швидше.

90
00:05:56,505 --> 00:05:58,320
Проте, виявляється, що ми можемо зробити ще краще.

91
00:05:58,320 --> 00:05:59,418
Тож у наступному відео 

92
00:05:59,418 --> 00:06:03,237
ми поговоримо як ще векторизувати ЛР

93
00:06:03,237 --> 00:06:07,365
і ти виявиш несподіваний результат, -
що, навіть, взагалі без використання циклів for

94
00:06:07,365 --> 00:06:10,695
(без циклу for для тренувальних зразків)

95
00:06:10,695 --> 00:06:14,760
ти зможеш написати код, щоб обробити весь тренувальний набір,

96
00:06:14,760 --> 00:06:17,060
практично одномоментно.

97
00:06:17,060 --> 00:06:19,000
Тож давай подивимось на це в наступному відео.