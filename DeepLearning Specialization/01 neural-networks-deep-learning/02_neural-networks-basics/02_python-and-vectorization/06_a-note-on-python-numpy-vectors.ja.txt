Python で
ブロードキャストの操作ができることや より一般的に言えば
Python やNumpy に高いレベルの柔軟性があることは プログラム言語としての
強みでもあり弱みでもあります 強みの面としては
言語が高い表現性と柔軟性をもっていることで たった１行のコードでも
多くのことができるように なるからです 弱みでもあります
ブロードキャストや 高い柔軟性があることで
時として見つけにくいバグや 見たことのない挙動をするバグを
混入させてしまう可能性があるからです ブロードキャストのような機能の動作や
全体の複雑さに詳しくないと起こります 例えば列ベクトルに
行ベクトルを足すと 配列不一致や型のエラーなどを
期待するものだと思いますが 実は行ベクトルと
列ベクトルの合計が 返ってきます Python の奇妙な動作には
内部的なロジックが関わっています しかしPython に詳しくない場合で
非常に奇妙で見つけにくいバグを作った学生を 見てきました このビデオでは
コードに生まれうる奇妙なバグを排除して 簡素にコード書くために
非常に役立ってきたコツを 共有したいと思います これらのコツを使って バグのないPython やnumpy のコードを
容易に書けるようになればと思います 直感では分かりにくい
Python や numpyの結果をお見せする目的で ベクトルを作る方法について
デモを行います では
a = np.random.randn(5)と書いて ガウス分布の乱数を
５つ作り array a に記録します print(a) を実行します
またa.shapeは (5,)の構造になっています これはランク１の配列と
呼ばれています 行ベクトルでも
列ベクトルでもありません このことが
やや直感的でない結果を生みます 例えばaの転置をprint すると
a とまったく同じ結果になります a とa.T が同じ結果に
なってしまいます そしてa とa.T の内積を
print すると a×a.Tは外積になり
行列を返すことを期待するかもしれませんが これを実行すると
替わりに１つの数が返ってきます このためニューラルネットワークを
コードするときには (5,)や(n,)やランク１配列のような形の構造を
使わないことをお勧めします そのかわりに
a を(5,1)に指定すれば a が(5,1)の列ベクトルになることを
確定させることができます 先ほどはa×a.Tは
同一結果になりましたが a.T をprintすると
列ベクトルになっています 微妙な違いに注目してください print したa.Tのこのデータ構造には
[が２つあります 先ほどは
[は１つでした これが
この(1,5)の行列と このランク１の配列との違いでした aとa.Tの積をprint すると ベクトルの外積を
計算してくれます ベクトルの外積が 行列を返します 非常に細かなところまで
見てきました 最初に実行した１つ目のコマンドは
これでした このコマンドは
不思議な構造を作りました a.shapenbspで表示すると
(5,)になり ランク１配列と呼ばれます これは非常におかしなデータ構造で 行ベクトルや列ベクトルのどちらとしても動作せず 直感的でない結果を
生みます あなたがプログラム演習をする際に
私がおすすめするのは ニューラルネットワークに
ロジステック回帰を実装する演習では ランク１配列を使わないことを
お勧めします かわりに
配列を作るときはいつでも このように(5,1)の列ベクトルに 確定するようにするか
行ベクトルに確定するようにしましょう 作ったベクトルの挙動が
より分かりやすくなります この場合にはa.shape は
(5,1)を返します これは列ベクトルのように振舞いますし
実際に列ベクトルです 実際に列ベクトルですが
(5,1)の行列のように考えることができます そしてこの場合には
a.shapenbspは(1,5)を返します これは行ベクトルと同じように動作します なのでベクトルが必要なときには
これかこれのどちらかを使って ランク１配列は
やめましょう 私がコードで頻繁に行うのは
ベクトルの配列数を 完全には把握できていない時は
assert 文を入れておきます このようにしてこの場合には
(5,1)のベクトルなのを確実にします これは列ベクトルです これらのassert は
速度をほとんど犠牲にしませんし コードにドキュメントを付けるためにも
役立ちます 入れておきたいと思ったときには
assert 文を躊躇せずに入れておくように しましょう 最後に何かの原因で
ランク１配列ができてしまった場合には a.reshape(5,1)のようにして
形を変えれます (5,1)配列だったり(1,5)配列に変更して 列ベクトルか行ベクトルと
同じような挙動をするようにします 学生がバグを見つけにくい状態になっていることを
時々見かけます ランク１配列の直感的でない結果によるものです ランク１配列を排除することで
コードを簡素にすることができて コードで表現できる範囲という点では
制限されていると感じたことは ありません ランク１配列は
絶対に使いません 覚えておいてほしいのは
コードを簡素にしておくためにランク１配列は使わないで 列ベクトルとも言える(n,1)の行列を使うか 行ベクトルともいえる(1,n)の行列を
常に使うようにします 多くのassert 文を
入れて良いと考えて 行列や配列の配列数を
再確認するようにしましょう またreshape 操作も
遠慮せずに使って 行列やベクトルが必要な配列数に
なっていることを確実にしましょう これで これらの提案を使うことで
Python のコードからバグの原因を排除して あなたがプログラム演習を
より簡単に完了できるといいと思います