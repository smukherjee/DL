1
00:00:00,210 --> 00:00:03,240
在前面的影片中
我提過傳播

2
00:00:03,240 --> 00:00:07,040
是您可以使用的另一個技巧
讓您的 Python 程式跑得更快

3
00:00:07,040 --> 00:00:11,860
在這段影片中, 讓我們深入研究
Python 的傳播實際上如何作用

4
00:00:11,860 --> 00:00:14,240
讓我們用一個例子來看為什麼使用傳播

5
00:00:14,240 --> 00:00:18,730
在這個矩陣我顯示了
碳水化合物

6
00:00:18,730 --> 00:00:22,320
蛋白質, 跟‑脂肪的卡洛里在四個 100 克的食物中

7
00:00:22,320 --> 00:00:25,380
舉個例子
 100 克的蘋果

8
00:00:25,380 --> 00:00:29,690
有 56 卡從碳水化合物來
而極少從蛋白質跟脂肪來

9
00:00:29,690 --> 00:00:35,110
而相對的, 100 克
牛肉有 104 卡從蛋白質來

10
00:00:35,110 --> 00:00:37,620
135 卡從脂肪來

11
00:00:37,620 --> 00:00:43,330
現在假設您的目標是
計算卡洛里的比例

12
00:00:43,330 --> 00:00:48,440
從碳水化合物, 蛋白質
脂肪對於這四種食物

13
00:00:48,440 --> 00:00:52,338
舉個例子
如果您看這個列

14
00:00:52,338 --> 00:00:57,697
總和這列的數字
您得到 100 克的蘋果

15
00:00:57,697 --> 00:01:02,580
有 56 加 1.2 加 1.8 
 總共 59 卡

16
00:01:02,580 --> 00:01:06,806
所以卡洛里的比例

17
00:01:06,806 --> 00:01:11,800
在蘋果從碳水化合物是

18
00:01:11,800 --> 00:01:16,932
56 除以 59, 約 94.9%

19
00:01:16,932 --> 00:01:22,399
大部分蘋果的卡洛里
大部分從碳水化合物來, 而相對的

20
00:01:22,399 --> 00:01:27,630
牛肉的卡洛里大部分
從蛋白質跟脂肪來

21
00:01:27,630 --> 00:01:33,630
所以您想要的計算實際上是
總和每一個列

22
00:01:33,630 --> 00:01:38,740
在這個矩陣上得到總共的
卡洛里數目在 100 克的蘋果

23
00:01:38,740 --> 00:01:40,920
牛肉, 蛋 跟馬鈴薯

24
00:01:40,920 --> 00:01:45,090
然後逐一除上這個矩陣的元素

25
00:01:47,230 --> 00:01:51,230
如此來獲得
碳水化合物, 蛋白質

26
00:01:51,230 --> 00:01:54,870
跟脂肪的比例對於四種食物

27
00:01:54,870 --> 00:02:01,370
問題是, 您可以做這些
而不用到明顯的迴圈嗎?

28
00:02:01,370 --> 00:02:03,290
我們來看怎麼做

29
00:02:04,450 --> 00:02:08,602
我要做的是
您可以如何設定

30
00:02:08,602 --> 00:02:12,990
這個矩陣為
 3 乘 4 矩陣 A

31
00:02:12,990 --> 00:02:18,300
然後用一行 Python 程式
我們將按列總和

32
00:02:18,300 --> 00:02:22,078
我們會得到四個數字
相當於總共

33
00:02:22,078 --> 00:02:25,046
的卡洛里數字的對於這四種
不同種類的食物

34
00:02:25,046 --> 00:02:28,095
100 克的這四種
不同種類的食物

35
00:02:28,095 --> 00:02:32,113
我用第二行 Python 程式
來除以每一列

36
00:02:32,113 --> 00:02:35,390
的
相對的和

37
00:02:35,390 --> 00:02:37,250
如果語言的描述
不是很清楚

38
00:02:37,250 --> 00:02:40,670
希望等一下
當您看到 Python 程式時會比較清楚

39
00:02:40,670 --> 00:02:42,460
所以我們用 Jupyter notebook

40
00:02:42,460 --> 00:02:46,150
我已經寫了這第一個
程式來先產生

41
00:02:46,150 --> 00:02:49,860
矩陣 A 有之前那些數字
我們按 shift enter 

42
00:02:49,860 --> 00:02:51,220
來跑這個程式, 所以用這個矩陣 A

43
00:02:51,220 --> 00:02:55,080
現在有兩行
 Python 程式

44
00:02:55,080 --> 00:02:59,983
首先，我們先計算
 cal 等於 A.sum

45
00:02:59,983 --> 00:03:02,280
axis = 0 意思是垂直和

46
00:03:02,280 --> 00:03:05,280
我們等一下會談到

47
00:03:05,280 --> 00:03:06,076
然後印出 cal

48
00:03:06,076 --> 00:03:07,825
所以我們做垂直和

49
00:03:07,825 --> 00:03:13,735
59 是
蘋果的卡洛里總和, 239

50
00:03:13,735 --> 00:03:19,575
是牛肉卡洛里的總和
還有蛋跟馬鈴薯等等

51
00:03:19,575 --> 00:03:25,151
然後來計算百分比

52
00:03:25,151 --> 00:03:30,733
等於 A/cal.reshape(1,4)

53
00:03:30,733 --> 00:03:33,927
實際上我們要百分比
所以要乘以 100

54
00:03:35,913 --> 00:03:38,860
然後印出這百分比 percentage

55
00:03:40,800 --> 00:03:41,950
我們來跑這個程式

56
00:03:41,950 --> 00:03:46,870
所以
這個指令我們拿矩陣 A 然後

57
00:03:46,870 --> 00:03:50,820
除以這個 1 乘 4 矩陣

58
00:03:50,820 --> 00:03:52,672
而這給了我們
百分比的矩陣

59
00:03:52,672 --> 00:03:57,327
我們計算出了先前
用手算而現在

60
00:03:57,327 --> 00:04:02,480
在第一列 94.9% 
是從碳水化合物的卡洛里

61
00:04:02,480 --> 00:04:04,000
讓我們回到投影片

62
00:04:04,000 --> 00:04:06,310
先重複
之前的兩行程式

63
00:04:06,310 --> 00:04:09,940
這是之前我們寫在
 Jupyter notebook 上

64
00:04:09,940 --> 00:04:13,306
一點點小細節有關這參數

65
00:04:13,306 --> 00:04:18,540
(axis=0), 意思是您
要 Python 垂直和

66
00:04:18,540 --> 00:04:21,567
所以如果是 axis - 0 
意思是垂直和

67
00:04:21,567 --> 00:04:24,029
如果是水平軸就會是 axis = 1

68
00:04:24,029 --> 00:04:28,050
所以寫成 axis = 1 
就是水平和而不是垂直和

69
00:04:28,050 --> 00:04:30,670
而然後這個指令

70
00:04:30,670 --> 00:04:35,210
這是 Python 
傳播的例子, 您拿矩陣 A

71
00:04:35,210 --> 00:04:43,330
所以這是一個 3 乘 4 矩陣
您除以一個 `1 乘 4 矩陣

72
00:04:43,330 --> 00:04:47,370
技術上而言, 經過這第一行
程式, 這 cal 變數

73
00:04:47,370 --> 00:04:49,590
已經是 1 乘 4 矩陣

74
00:04:49,590 --> 00:04:52,616
所以基本上您不需要
再一次呼叫 reshape 

75
00:04:52,616 --> 00:04:54,722
這有一點多餘

76
00:04:54,722 --> 00:04:59,140
但當我寫 Python 程式時
如果我不確定這個矩陣

77
00:04:59,140 --> 00:05:04,056
這個矩陣的維度, 我通常
會寫下 reshape 指令來

78
00:05:04,056 --> 00:05:07,833
確認那是正確的
列向量或者行向量

79
00:05:07,833 --> 00:05:09,500
您所希望的

80
00:05:09,500 --> 00:05:11,840
這個 reshape 指令是常數時間

81
00:05:11,840 --> 00:05:15,150
是一個操作單元 1 的運算
非常便宜的呼叫函數

82
00:05:15,150 --> 00:05:18,404
所以不用害羞來使用 reshape
指令來確定您的矩陣

83
00:05:18,404 --> 00:05:20,830
是您需要的大小

84
00:05:21,920 --> 00:05:27,272
現在讓我來詳細解釋
這類型的運算如何運作

85
00:05:27,272 --> 00:05:33,780
我們有 3 乘 4 矩陣
我們將它除以一個 1 乘 4 矩陣

86
00:05:33,780 --> 00:05:37,840
我們要如何用 3 乘 
4矩陣除以 1 乘 4 矩陣

87
00:05:37,840 --> 00:05:38,860
或者說 1 乘 4 向量

88
00:05:40,130 --> 00:05:43,160
讓我們看一些
傳播的例子

89
00:05:43,160 --> 00:05:47,920
如果您拿 4 乘 1 向量
加上一個數字

90
00:05:47,920 --> 00:05:53,011
Python 會拿這個數字
自動展開

91
00:05:53,011 --> 00:05:58,180
變成 4 乘 1 向量
像這樣

92
00:05:58,180 --> 00:06:00,257
所以這個向量 [1,2,3,

93
00:06:00,257 --> 00:06:04,450
4] 加上數字 100 最終會是
在右邊這個向量

94
00:06:04,450 --> 00:06:09,280
您在每一個元素加 100
實際上我們用這樣的

95
00:06:09,280 --> 00:06:14,365
傳播在先前的影片中當時用的常數是
參數b

96
00:06:14,365 --> 00:06:19,414
而這樣的傳播可用
於列向量跟行向量

97
00:06:19,414 --> 00:06:24,157
實際上前面我們用了類似的
傳播使用常數

98
00:06:24,157 --> 00:06:29,330
我們加入一個向量
就是參數 b 在羅吉斯迴歸分析

99
00:06:29,330 --> 00:06:31,610
這裡有另一個例子

100
00:06:31,610 --> 00:06:35,900
假設您有 2 乘 
3 矩陣

101
00:06:35,900 --> 00:06:39,420
加上這個 1 乘 n 矩陣

102
00:06:40,950 --> 00:06:45,682
一般化以後會是如果您

103
00:06:45,682 --> 00:06:50,583
有一 (m, n) 矩陣

104
00:06:50,583 --> 00:06:55,330
加上一個 (1, n) 矩陣

105
00:06:55,330 --> 00:06:58,667
Python 會這樣複製這個矩陣 m 次

106
00:06:58,667 --> 00:07:03,672
變成一個 m 乘 n 矩陣
與其用這個 1 乘

107
00:07:03,672 --> 00:07:09,980
3 矩陣這例子它會複製兩次
變成這樣

108
00:07:09,980 --> 00:07:14,092
同樣也是 2 乘 3 矩陣
而我們相加

109
00:07:14,092 --> 00:07:18,270
您最終會得到右邊這個和
是吧?

110
00:07:18,270 --> 00:07:21,583
所以您
加 100 到第一列

111
00:07:21,583 --> 00:07:25,812
加 200 到第二列
加 300 到第三列

112
00:07:25,812 --> 00:07:28,796
基本上這是我們
在前面投影片做的

113
00:07:28,796 --> 00:07:32,810
除了我們使用除法
而不是加法

114
00:07:34,180 --> 00:07:40,402
最後一個例子
您有一個 (m, n) 矩陣

115
00:07:40,402 --> 00:07:46,260
您加這個 (m, 1) 向量
(m, 1) 矩陣

116
00:07:47,310 --> 00:07:50,760
只要水平複製這個 n 次

117
00:07:50,760 --> 00:07:53,510
您最終會得到一個 (m, n) 矩陣

118
00:07:53,510 --> 00:07:56,990
您可以想像成
水平複製它三次

119
00:07:56,990 --> 00:07:58,650
然後加起來

120
00:07:58,650 --> 00:08:01,070
當您加完之後您會得到

121
00:08:01,070 --> 00:08:06,890
我們加 100 到第一行
加 200 到第二行

122
00:08:08,270 --> 00:08:12,061
這個是
Python 傳播更一般化的原則

123
00:08:12,061 --> 00:08:17,353
如果您有一個 (m, n) 矩陣而您加或

124
00:08:17,353 --> 00:08:24,409
減或乘或除一個 (1, n) 矩陣

125
00:08:24,409 --> 00:08:31,177
那這個會複製m
次變成 (m,n) 矩陣

126
00:08:31,177 --> 00:08:33,781
然後在應用加
減

127
00:08:33,781 --> 00:08:36,140
乘, 除到每一個元素

128
00:08:37,250 --> 00:08:42,250
如果相反地, 您拿 (m,n) 
矩陣做加, 減, 乘

129
00:08:42,250 --> 00:08:49,060
除一個 (m,1) 矩陣
那這也是會複製 n 次

130
00:08:49,060 --> 00:08:54,740
變成 (m,n) 矩陣
在每個元素應用那個運算

131
00:08:54,740 --> 00:09:00,327
還有一種傳播
也就是如果您有ㄧ (m,1) 矩陣

132
00:09:00,327 --> 00:09:05,175
所以這實際上是一個列向量
像 [1,2,3] 然後您加,

133
00:09:05,175 --> 00:09:08,482
減, 乘, 或
除一個數字

134
00:09:08,482 --> 00:09:11,080
或許是一個 (1,1) 矩陣

135
00:09:11,080 --> 00:09:16,117
所以像是加 100
那您會複製

136
00:09:16,117 --> 00:09:23,512
這個實數 n 次直到您
得到另一個 (n,1)矩陣

137
00:09:23,512 --> 00:09:29,700
然後您在這個例子逐一元素地應用這個運算像是
加法

138
00:09:29,700 --> 00:09:35,823
類似的事情也適用於
行向量

139
00:09:38,281 --> 00:09:43,730
完整的傳播一般化版本
甚至可以做得更多

140
00:09:43,730 --> 00:09:49,080
如果您有興趣您可以
閱讀這些文件

141
00:09:49,080 --> 00:09:52,240
numpy, 然後找
文件中的傳播部份

142
00:09:52,240 --> 00:09:56,380
那會給稍微更多
一般化的傳播定義

143
00:09:56,380 --> 00:10:00,140
但在這投影片中是主要
型態的傳播您

144
00:10:00,140 --> 00:10:02,560
在建置神經網路時會用到的

145
00:10:03,890 --> 00:10:06,840
在總結之前
最後一個註解, 就是

146
00:10:06,840 --> 00:10:10,210
您如果使用過
程式語言像是 matlab 或

147
00:10:10,210 --> 00:10:15,760
octave, 如果您曾使用 matlab 或
 Octave 函數 bsxfun

148
00:10:15,760 --> 00:10:20,590
在神經網路程式中 bsxfun 
做類似的事, 但並不完全相同

149
00:10:20,590 --> 00:10:25,750
但它通常用在跟我們使用Python 傳播時同樣的目的

150
00:10:25,750 --> 00:10:28,505
但這真的只對
非常進階的 matlab 跟

151
00:10:28,505 --> 00:10:31,600
Octave 使用者, 如果您不曾聽過
不用擔心

152
00:10:31,600 --> 00:10:35,524
您並不需要知道這個當您
用 Python 來做神經網路的程式

153
00:10:35,524 --> 00:10:38,720
所以,這就是 Python 的傳播

154
00:10:38,720 --> 00:10:42,360
我希望當您做程式
作業時傳播會讓您

155
00:10:42,360 --> 00:10:44,580
不只讓程式跑得更快

156
00:10:44,580 --> 00:10:48,920
也幫您得到您要做的
僅用更少行的程式

157
00:10:50,360 --> 00:10:53,630
在您進入程式
作業之前, 我想分享您

158
00:10:53,630 --> 00:10:56,290
一個想法
就是一些提示

159
00:10:56,290 --> 00:11:00,700
跟技巧我發現來
減低我 Python 程式的錯誤

160
00:11:00,700 --> 00:11:02,640
我希望會幫到您

161
00:11:02,640 --> 00:11:05,550
所以
讓我們在下一段影片談這個