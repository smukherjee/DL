1
00:00:00,210 --> 00:00:03,240
在上一个视频中 我提到了

2
00:00:03,240 --> 00:00:07,040
广播是另一种能使Python代码运行得更快的技术

3
00:00:07,040 --> 00:00:11,860
在这个视频中 我们将深入研究Python中广播的运行机制

4
00:00:11,860 --> 00:00:14,240
让我们用一个例子来解释广播

5
00:00:14,240 --> 00:00:18,730
在这个矩阵中 我展示了各100克的4种不同食物中

6
00:00:18,730 --> 00:00:22,320
碳水化合物 蛋白质 脂肪的卡路里(Calorie)含量

7
00:00:22,320 --> 00:00:25,380
比如 在100克苹果中

8
00:00:25,380 --> 00:00:29,690
有56大卡的热量来自碳水化合物
而来自蛋白质和脂肪的热量就少多了

9
00:00:29,690 --> 00:00:35,110
相比之下 在100克的牛肉中
有104大卡的热量来自蛋白质

10
00:00:35,110 --> 00:00:37,620
有135大卡的热量来自脂肪

11
00:00:37,620 --> 00:00:43,330
现在 假设你的目标是计算每种食物的热量中

12
00:00:43,330 --> 00:00:48,440
来自碳水化合物 蛋白质和脂肪的比例

13
00:00:48,440 --> 00:00:52,338
举例来说 你看这一列

14
00:00:52,338 --> 00:00:57,697
将其中的数字相加 你会得到100克苹果中

15
00:00:57,697 --> 00:01:02,580
含有56+1.2+1.8=59大卡

16
00:01:02,580 --> 00:01:06,806
所以 苹果所含的热量中

17
00:01:06,806 --> 00:01:11,800
来自碳水化合物的百分比

18
00:01:11,800 --> 00:01:16,932
应该是56/59 大约是94.9%

19
00:01:16,932 --> 00:01:22,399
所以苹果中大部分的热量都来自碳水化合物

20
00:01:22,399 --> 00:01:27,630
与之相反 牛肉中大部分的热量来自蛋白质和脂肪

21
00:01:27,630 --> 00:01:33,630
所以你需要做的计算是 分别对矩阵的四列求和

22
00:01:33,630 --> 00:01:38,740
得到100克的苹果 牛肉 鸡蛋和土豆中

23
00:01:38,740 --> 00:01:40,920
含有的总热量

24
00:01:40,920 --> 00:01:45,090
并将矩阵的每个元素都除以对应列的和

25
00:01:47,230 --> 00:01:51,230
以得到每种食物中 来自碳水化合物 蛋白质和脂肪的

26
00:01:51,230 --> 00:01:54,870
热量的百分比

27
00:01:54,870 --> 00:02:01,370
问题在于 你能不用显式的for循环来完成这一操作吗？

28
00:02:01,370 --> 00:02:03,290
让我们看看应该怎么做

29
00:02:04,450 --> 00:02:08,602
我将向你展示如何做到

30
00:02:08,602 --> 00:02:12,990
比如说这个3乘4的矩阵A

31
00:02:12,990 --> 00:02:18,300
我们可以用一行Python代码对每列求和

32
00:02:18,300 --> 00:02:22,078
我们将会得到四个数字

33
00:02:22,078 --> 00:02:25,046
分别对应100克的

34
00:02:25,046 --> 00:02:28,095
4种不同食物中的总热量

35
00:02:28,095 --> 00:02:32,113
接着我用第二行Python代码

36
00:02:32,113 --> 00:02:35,390
使每一列都除以对应的列的和

37
00:02:35,390 --> 00:02:37,250
如果这些口头说明不是很清晰

38
00:02:37,250 --> 00:02:40,670
希望你在看到Python代码时会更加清楚

39
00:02:40,670 --> 00:02:42,460
现在我们进入Jupyter笔记本

40
00:02:42,460 --> 00:02:46,150
我已经写好了第一段代码

41
00:02:46,150 --> 00:02:49,860
向矩阵A填充了前面的数值
按下Shift+Enter运行

42
00:02:49,860 --> 00:02:51,220
可以看到这就是矩阵A

43
00:02:51,220 --> 00:02:55,080
接着是两行Python代码

44
00:02:55,080 --> 00:02:59,983
首先计算 cal=A.sum(axis=0)

45
00:02:59,983 --> 00:03:02,280
axis=0的意思是沿垂直方向求和

46
00:03:02,280 --> 00:03:05,280
我们很快还会提到它

47
00:03:05,280 --> 00:03:06,076
接着 print(cal)

48
00:03:06,076 --> 00:03:07,825
可以看到已经按列求和了

49
00:03:07,825 --> 00:03:13,735
这里的59是苹果的总大卡数

50
00:03:13,735 --> 00:03:19,575
239是牛肉热量的大卡数 还有鸡蛋和土豆的

51
00:03:19,575 --> 00:03:25,151
然后计算百分比

52
00:03:25,151 --> 00:03:30,733
percentage=A/cal.reshape(1,4)

53
00:03:30,733 --> 00:03:33,927
实际上我们要的是百分比数值 所以乘以100

54
00:03:35,913 --> 00:03:38,860
然后 print(percentage)

55
00:03:40,800 --> 00:03:41,950
运行一下

56
00:03:41,950 --> 00:03:46,870
在这个命令中 我们用矩阵A

57
00:03:46,870 --> 00:03:50,820
除以了这个1乘4的矩阵

58
00:03:50,820 --> 00:03:52,672
从而得到了百分比矩阵

59
00:03:52,672 --> 00:03:57,327
就像我们刚才手算得出的

60
00:03:57,327 --> 00:04:02,480
苹果中有94.9%的热量来自碳水化合物

61
00:04:02,480 --> 00:04:04,000
回到幻灯片来

62
00:04:04,000 --> 00:04:06,310
把刚才的两行代码重写如下

63
00:04:06,310 --> 00:04:09,940
就是我们刚在Jupyter笔记本上写的

64
00:04:09,940 --> 00:04:13,306
需要说明的是 这个axis=0的参数

65
00:04:13,306 --> 00:04:18,540
表示着你想让Python沿垂直方向求和

66
00:04:18,540 --> 00:04:21,567
如果axis=0 意味着垂直相加

67
00:04:21,567 --> 00:04:24,029
反之 水平轴的axis是1

68
00:04:24,029 --> 00:04:28,050
所以写axis=1就可以水平求和 而不是垂直求和

69
00:04:28,050 --> 00:04:30,670
接下来 对于这个命令

70
00:04:30,670 --> 00:04:35,210
这是一个Python广播的例子

71
00:04:35,210 --> 00:04:43,330
用一个3乘4的矩阵A 除以一个1乘4的矩阵

72
00:04:43,330 --> 00:04:47,370
严格地说 在第一行代码执行完毕之后

73
00:04:47,370 --> 00:04:49,590
cal已经是一个1乘4的矩阵

74
00:04:49,590 --> 00:04:52,616
所以严格地说 你不需要再在这里调用reshape

75
00:04:52,616 --> 00:04:54,722
这实际上有些多余

76
00:04:54,722 --> 00:04:59,140
但当我写Python代码时

77
00:04:59,140 --> 00:05:04,056
如果我不确定某个矩阵的维数
我通常会调用reshape

78
00:05:04,056 --> 00:05:07,833
以确保它是正确的列向量或者行向量

79
00:05:07,833 --> 00:05:09,500
或者任何你想要的维数

80
00:05:09,500 --> 00:05:11,840
reshape消耗常量的时间

81
00:05:11,840 --> 00:05:15,150
是一个O(1)的操作 调用的成本很低

82
00:05:15,150 --> 00:05:18,404
所以不要怕用reshape来确保

83
00:05:18,404 --> 00:05:20,830
矩阵是你想要的尺寸

84
00:05:21,920 --> 00:05:27,272
现在 我将深入解释这种操作的机制

85
00:05:27,272 --> 00:05:33,780
我们用3乘4的矩阵除以1乘4的矩阵

86
00:05:33,780 --> 00:05:37,840
怎么能用3乘4的矩阵除以1乘4的矩阵呢?

87
00:05:37,840 --> 00:05:38,860
或者说 除以1乘4的向量?

88
00:05:40,130 --> 00:05:43,160
我们再看几个广播的例子

89
00:05:43,160 --> 00:05:47,920
如果你有一个4乘1的向量 让它加一个数字

90
00:05:47,920 --> 00:05:53,011
Python会自动将这个数字

91
00:05:53,011 --> 00:05:58,180
扩展成这样一个4乘1的向量

92
00:05:58,180 --> 00:06:00,257
例如对于向量[1 2 3 4]

93
00:06:00,257 --> 00:06:04,450
加上数字100 就会得到右边那个向量

94
00:06:04,450 --> 00:06:09,280
你给每个数字都加了100
实际上我们之前使用过这种广播

95
00:06:09,280 --> 00:06:14,365
这里所加的常数就是前面视频中的参数b

96
00:06:14,365 --> 00:06:19,414
这种广播适用于行向量和列向量

97
00:06:19,414 --> 00:06:24,157
实际上 我们之前已经使用过了类似形式的广播

98
00:06:24,157 --> 00:06:29,330
之前在逻辑回归中的参数b
就相当于我们这里为向量加上的常量

99
00:06:29,330 --> 00:06:31,610
再来看一个例子

100
00:06:31,610 --> 00:06:35,900
假设有一个2乘3的矩阵

101
00:06:35,900 --> 00:06:39,420
让它加上这个1乘n的矩阵

102
00:06:40,950 --> 00:06:45,682
一般情况而言

103
00:06:45,682 --> 00:06:50,583
如果你让一个m乘n的矩阵

104
00:06:50,583 --> 00:06:55,330
加上一个1乘n的矩阵

105
00:06:55,330 --> 00:06:58,667
Python会将后者复制m次

106
00:06:58,667 --> 00:07:03,672
使其变为一个m乘n的矩阵

107
00:07:03,672 --> 00:07:09,980
所以在这个例子中
这个1乘3的矩阵会被复制两次

108
00:07:09,980 --> 00:07:14,092
成为一个2乘3的矩阵

109
00:07:14,092 --> 00:07:18,270
然后相加得到右边的和

110
00:07:18,270 --> 00:07:21,583
所以 你对第一列加了100

111
00:07:21,583 --> 00:07:25,812
对第二列加了200 对第三列加了300

112
00:07:25,812 --> 00:07:28,796
这基本上就是我们在前一页中所做的

113
00:07:28,796 --> 00:07:32,810
只不过当时我们用的是除法操作
而这里是加法操作

114
00:07:34,180 --> 00:07:40,402
再举最后一个例子
假设你有一个m乘n的矩阵

115
00:07:40,402 --> 00:07:46,260
让它加上一个m乘1的向量 或者说m乘1的矩阵

116
00:07:47,310 --> 00:07:50,760
后者会在水平方向复制n次

117
00:07:50,760 --> 00:07:53,510
所以你会得到一个m乘n的矩阵

118
00:07:53,510 --> 00:07:56,990
你可以想象它被水平地复制了三次

119
00:07:56,990 --> 00:07:58,650
然后相加

120
00:07:58,650 --> 00:08:01,070
相加后得到这个结果

121
00:08:01,070 --> 00:08:06,890
我们给第一行加了100
第二行加了200

122
00:08:08,270 --> 00:08:12,061
以下是Python广播的一些通用规则

123
00:08:12,061 --> 00:08:17,353
如果你有一个m乘n的矩阵

124
00:08:17,353 --> 00:08:24,409
让它加减乘除以一个1乘n的矩阵

125
00:08:24,409 --> 00:08:31,177
后者会被复制m次 成为一个m乘n的矩阵

126
00:08:31,177 --> 00:08:33,781
然后再逐元素地进行

127
00:08:33,781 --> 00:08:36,140
加减乘除操作

128
00:08:37,250 --> 00:08:42,250
反之 如果你让一个m乘n的矩阵

129
00:08:42,250 --> 00:08:49,060
加减乘除以一个m乘1的矩阵
后者也会复制n次

130
00:08:49,060 --> 00:08:54,740
成为一个m乘n的矩阵
然后再逐元素地进行运算操作

131
00:08:54,740 --> 00:09:00,327
广播的另一种形式是
如果你有一个m乘1的矩阵

132
00:09:00,327 --> 00:09:05,175
它实际上是一个列向量 比如[1 2 3]

133
00:09:05,175 --> 00:09:08,482
然后让它加减乘除以一个实数

134
00:09:08,482 --> 00:09:11,080
也就是一个1乘1的矩阵

135
00:09:11,080 --> 00:09:16,117
比如加上100 那么这个实数会被复制m次

136
00:09:16,117 --> 00:09:23,512
得到一个m乘1的矩阵

137
00:09:23,512 --> 00:09:29,700
然后再逐元素地进行运算 例如这个例子中的加法操作

138
00:09:29,700 --> 00:09:35,823
类似地 这也可以用于行向量

139
00:09:38,281 --> 00:09:43,730
广播的全部功能比这里介绍的还要多

140
00:09:43,730 --> 00:09:49,080
如果你感兴趣 可以去阅读NumPy的相关文档

141
00:09:49,080 --> 00:09:52,240
并查看其中关于广播的部分

142
00:09:52,240 --> 00:09:56,380
那里会给出更广泛的广播的定义

143
00:09:56,380 --> 00:10:00,140
这节课的幻灯片中给出的是 你在实现神经网络时

144
00:10:00,140 --> 00:10:02,560
需要用到的广播的主要形式

145
00:10:03,890 --> 00:10:06,840
结束之前 我最后插一句

146
00:10:06,840 --> 00:10:10,210
对于习惯使用MATLAB或Octave编程的同学

147
00:10:10,210 --> 00:10:15,760
如果你在神经网络编程中
用过MATLAB或Octave的bsxfun函数

148
00:10:15,760 --> 00:10:20,590
其实bsxfun做的事情类似 但并不完全一样

149
00:10:20,590 --> 00:10:25,750
它与我们在Python中使用广播的目的是一致的

150
00:10:25,750 --> 00:10:28,505
这只是对于非常高端的
MATLAB和Octave用户而言

151
00:10:28,505 --> 00:10:31,600
如果你没听说过 不用担心

152
00:10:31,600 --> 00:10:35,524
当你在Python中编写神经网络时 并不需要知道它

153
00:10:35,524 --> 00:10:38,720
以上就是Python的广播机制

154
00:10:38,720 --> 00:10:42,360
我希望当你在做编程作业时

155
00:10:42,360 --> 00:10:44,580
广播不仅能让你的程序跑得更快

156
00:10:44,580 --> 00:10:48,920
也帮助你用更少的代码达到目的

157
00:10:50,360 --> 00:10:53,630
在你进行编程练习之前

158
00:10:53,630 --> 00:10:56,290
我还想再和大家分享一些点子

159
00:10:56,290 --> 00:11:00,700
也就是一些能帮我减少Python代码中的bug的技巧

160
00:11:00,700 --> 00:11:02,640
希望也能帮到你

161
00:11:02,640 --> 00:11:05,550
那么 我们下个视频见