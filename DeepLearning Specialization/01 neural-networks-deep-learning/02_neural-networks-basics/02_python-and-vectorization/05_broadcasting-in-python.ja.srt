1
00:00:00,210 --> 00:00:03,240
前のビデオでは
ブロードキャストというテクニックを使うと

2
00:00:03,240 --> 00:00:07,040
Python のコードの実行速度を
速めることができると言いました

3
00:00:07,040 --> 00:00:11,860
このビデオではPython でのブロードキャストが
どう動作するのか掘り下げましょう

4
00:00:11,860 --> 00:00:14,240
ブロードキャストを
例で見てみましょう

5
00:00:14,240 --> 00:00:18,730
この行列では４種類の食べ物での
100グラムあたりのカロリーを

6
00:00:18,730 --> 00:00:22,320
炭水化物、タンパク質
脂質の別に示しました

7
00:00:22,320 --> 00:00:25,380
例えば100グラムのリンゴのカロリーは

8
00:00:25,380 --> 00:00:29,690
炭水化物からは56カロリーで
タンパク質と脂質からではかなり少ないです

9
00:00:29,690 --> 00:00:35,110
一方 牛肉ではタンパク質からは104カロリーで
脂質からは

10
00:00:35,110 --> 00:00:37,620
135カロリーです

11
00:00:37,620 --> 00:00:43,330
ここでの目標は４種類の食品での
炭水化物、タンパク質、脂質からの

12
00:00:43,330 --> 00:00:48,440
カロリーの割合を
計算することだとしましょう

13
00:00:48,440 --> 00:00:52,338
例えばこの列を見ると

14
00:00:52,338 --> 00:00:57,697
この列の数を足していくと
100グラムのリンゴは

15
00:00:57,697 --> 00:01:02,580
56+1.2+1.8で
59カロリーと分かります

16
00:01:02,580 --> 00:01:06,806
そしてリンゴでの

17
00:01:06,806 --> 00:01:11,800
炭水化物からのカロリーは
56割る59なので

18
00:01:11,800 --> 00:01:16,932
約94.9%です

19
00:01:16,932 --> 00:01:22,399
リンゴでのカロリーは
ほとんどが炭水化物からです

20
00:01:22,399 --> 00:01:27,630
一方で牛肉のカロリーは
タンパク質と脂質からです

21
00:01:27,630 --> 00:01:33,630
このためには
この行列の４つの列を合計して

22
00:01:33,630 --> 00:01:38,740
100グラムでのリンゴ
牛肉、卵、じゃがいもでの総カロリーを

23
00:01:38,740 --> 00:01:40,920
出します

24
00:01:40,920 --> 00:01:45,090
その後行列の数の全てを割り

25
00:01:47,230 --> 00:01:51,230
４種類の食品の炭水化物、タンパク質、脂質の
割合を%で

26
00:01:51,230 --> 00:01:54,870
出します

27
00:01:54,870 --> 00:02:01,370
ここでの疑問はfor loop を書くことなく
これができるかです

28
00:02:01,370 --> 00:02:03,290
どうするのか見てみましょう

29
00:02:04,450 --> 00:02:08,602
お見せします

30
00:02:08,602 --> 00:02:12,990
この行列を３ｘ４の行列Aとします

31
00:02:12,990 --> 00:02:18,300
１行のPython のコードで
列の値を合計します

32
00:02:18,300 --> 00:02:22,078
４つの食品のカロリーの合計にあたる

33
00:02:22,078 --> 00:02:25,046
４つの数字を計算します

34
00:02:25,046 --> 00:02:28,095
４種類の食品の
100グラムあたりのものです

35
00:02:28,095 --> 00:02:32,113
そして２行目のPython のコードを使って

36
00:02:32,113 --> 00:02:35,390
その列の合計に該当する数で
列の中の数を割ります

37
00:02:35,390 --> 00:02:37,250
言葉での説明が明らかでない場合には

38
00:02:37,250 --> 00:02:40,670
これから見るPython のコードを見たら
分かりやすくなると思います

39
00:02:40,670 --> 00:02:42,460
Jupyter Notebook に入ってきました

40
00:02:42,460 --> 00:02:46,150
表のカロリー数を
行列Aに入れるための最初のコードは

41
00:02:46,150 --> 00:02:49,860
書いておきました
shift+enterで実行しましょう

42
00:02:49,860 --> 00:02:51,220
行列のAが出ています

43
00:02:51,220 --> 00:02:55,080
ここに２行のPython コードを入れます

44
00:02:55,080 --> 00:02:59,983
まずcal=A.sum(axis=0)と書き

45
00:02:59,983 --> 00:03:02,280
axis=0 は縦を足すという意味です

46
00:03:02,280 --> 00:03:05,280
すぐにもっと詳しい話をします

47
00:03:05,280 --> 00:03:06,076
cal をprint します

48
00:03:06,076 --> 00:03:07,825
縦に合計しています

49
00:03:07,825 --> 00:03:13,735
59がリンゴでの総カロリーで

50
00:03:13,735 --> 00:03:19,575
239が牛肉での総カロリーで
卵、じゃがいもと続きます

51
00:03:19,575 --> 00:03:25,151
次に%を計算します

52
00:03:25,151 --> 00:03:30,733
A/cal.reshape(1,4)を

53
00:03:30,733 --> 00:03:33,927
100倍にしてパーセントを出します

54
00:03:35,913 --> 00:03:38,860
percentage をprint しましょう

55
00:03:40,800 --> 00:03:41,950
実行しましょう

56
00:03:41,950 --> 00:03:46,870
このコマンドでは
行列Aを使って

57
00:03:46,870 --> 00:03:50,820
ここの１ｘ４の行列で割っています

58
00:03:50,820 --> 00:03:52,672
これで行列でのパーセントが出ています

59
00:03:52,672 --> 00:03:57,327
手で計算したのと同じように
最初の列のリンゴでは

60
00:03:57,327 --> 00:04:02,480
94.9%が炭水化物から来ています

61
00:04:02,480 --> 00:04:04,000
スライドに戻りましょう

62
00:04:04,000 --> 00:04:06,310
使った２行のコードを振り返ります

63
00:04:06,310 --> 00:04:09,940
これがJupyter Notebook に
書いたものです

64
00:04:09,940 --> 00:04:13,306
少し詳しく説明すると
このパラメーター(axis=0)は

65
00:04:13,306 --> 00:04:18,540
Python で縦方向に合計することを
意味します

66
00:04:18,540 --> 00:04:21,567
axis 0 は
縦に足し

67
00:04:21,567 --> 00:04:24,029
一方axis 1 は
横に足すです

68
00:04:24,029 --> 00:04:28,050
axis 1 と書けば
縦ではなく横に足します

69
00:04:28,050 --> 00:04:30,670
次の命令は

70
00:04:30,670 --> 00:04:35,210
Python のブロードキャストの例です

71
00:04:35,210 --> 00:04:43,330
行列Aは３ｘ４の行列で
これを１ｘ４の行列で割ります

72
00:04:43,330 --> 00:04:47,370
技術的には１行目のコードの実行後には
変数cal は

73
00:04:47,370 --> 00:04:49,590
１ｘ４の行列になっています

74
00:04:49,590 --> 00:04:52,616
技術的にはこのreshape を
再度呼ぶ必要はありません

75
00:04:52,616 --> 00:04:54,722
実は少し冗長ですが

76
00:04:54,722 --> 00:04:59,140
わたしはPython のコードを書くときに

77
00:04:59,140 --> 00:05:04,056
行列の配列数が分からないときは
reshape コマンドを実行するようにしています

78
00:05:04,056 --> 00:05:07,833
行や列のベクトルが
確かに望んでいる形になっているように

79
00:05:07,833 --> 00:05:09,500
実行しています

80
00:05:09,500 --> 00:05:11,840
reshape 命令は
一定時間で実行できるものです

81
00:05:11,840 --> 00:05:15,150
処理量に対して一次的な命令なので
呼び出しコストが非常に低いです

82
00:05:15,150 --> 00:05:18,404
reshape を控え目に使うのではなく
行列が必要なサイズになるのを確実にするために

83
00:05:18,404 --> 00:05:20,830
積極的に使いましょう

84
00:05:21,920 --> 00:05:27,272
このような命令がどう動作するのかを
詳しく説明します

85
00:05:27,272 --> 00:05:33,780
３ｘ４の行列を
１ｘ４の行列で割ります

86
00:05:33,780 --> 00:05:37,840
どのようにして３ｘ４を
１ｘ４のベクトルで

87
00:05:37,840 --> 00:05:38,860
割るのでしょうか

88
00:05:40,130 --> 00:05:43,160
ブロードキャストの例を
もう少し見ていきましょう

89
00:05:43,160 --> 00:05:47,920
４ｘ１のベクトルに対して
ある数を足すと

90
00:05:47,920 --> 00:05:53,011
Python は自動で

91
00:05:53,011 --> 00:05:58,180
４ｘ１のベクトルに
拡張します

92
00:05:58,180 --> 00:06:00,257
ベクトル[1,2,3,4]に

93
00:06:00,257 --> 00:06:04,450
100を足すと
右側のベクトルが出来上がります

94
00:06:04,450 --> 00:06:09,280
100をすべての要素に足すことになり
この形のブロードキャストは

95
00:06:09,280 --> 00:06:14,365
これまでのビデオで
定数はbですが同じことを行っていました

96
00:06:14,365 --> 00:06:19,414
この形のブロードキャストは
列ベクトルでも行ベクトルでも動作します

97
00:06:19,414 --> 00:06:24,157
実は同じような形のブロードキャストを行っています

98
00:06:24,157 --> 00:06:29,330
ロジステック回帰で
足されるのは定数b という形で行っていました

99
00:06:29,330 --> 00:06:31,610
もう一つの例です。

100
00:06:31,610 --> 00:06:35,900
２ｘ３の行列と１ｘn のベクトルが

101
00:06:35,900 --> 00:06:39,420
足される場合です

102
00:06:40,950 --> 00:06:45,682
一般化すると

103
00:06:45,682 --> 00:06:50,583
(m,n)の行列を

104
00:06:50,583 --> 00:06:55,330
(1,n)の行列に足します

105
00:06:55,330 --> 00:06:58,667
Python が行うのは
(1,n)の行列を

106
00:06:58,667 --> 00:07:03,672
m回コピーして
mｘnの行列にします

107
00:07:03,672 --> 00:07:09,980
１ｘ３の行列をコピーして
このような形にします

108
00:07:09,980 --> 00:07:14,092
２ｘ３の行列の形になります

109
00:07:14,092 --> 00:07:18,270
その後加算を行って
右側のようになります

110
00:07:18,270 --> 00:07:21,583
１列目に100を加え

111
00:07:21,583 --> 00:07:25,812
２列目に200を
３列目に300を加えます

112
00:07:25,812 --> 00:07:28,796
これは前のスライドで
行ったこととほぼ同じです

113
00:07:28,796 --> 00:07:32,810
先ほどは割り算命令でしたが
今回は加算命令です

114
00:07:34,180 --> 00:07:40,402
最後にもう１つの例です
mｘn の行列に

115
00:07:40,402 --> 00:07:46,260
ｍｘ１の行列を足した場合には
どうなるでしょうか

116
00:07:47,310 --> 00:07:50,760
n 回分横にコピーを行って

117
00:07:50,760 --> 00:07:53,510
ｍｘn の行列ができます

118
00:07:53,510 --> 00:07:56,990
横に３列分になるまでコピーされます

119
00:07:56,990 --> 00:07:58,650
そして加算し

120
00:07:58,650 --> 00:08:01,070
このような結果になります

121
00:08:01,070 --> 00:08:06,890
最初の行に100を足し
２つ目の行に200を足します

122
00:08:08,270 --> 00:08:12,061
Python での基本的原則を
紹介します

123
00:08:12,061 --> 00:08:17,353
(m,n) の行列があり
これに

124
00:08:17,353 --> 00:08:24,409
(1,n) の行列の加算、減算
乗算、除算を行うと

125
00:08:24,409 --> 00:08:31,177
m 回分コピーして
(m,n)の行列を作ります

126
00:08:31,177 --> 00:08:33,781
その後要素ごとに
加算、減算

127
00:08:33,781 --> 00:08:36,140
乗算、除算を
適用します

128
00:08:37,250 --> 00:08:42,250
もし逆に(m,n)の行列を
(m,1)の行列で

129
00:08:42,250 --> 00:08:49,060
割るとしたら
この場合にもn 回分コピーされて

130
00:08:49,060 --> 00:08:54,740
(m,n)行列になり
要素ごとに計算を適用します

131
00:08:54,740 --> 00:09:00,327
他のブロードキャストを紹介します
(m,1)の行列があるとします

132
00:09:00,327 --> 00:09:05,175
列ベクトルで[1,2,3]となっています

133
00:09:05,175 --> 00:09:08,482
これに実数を加算、減算
乗算、除算すると

134
00:09:08,482 --> 00:09:11,080
(1,1)の行列で

135
00:09:11,080 --> 00:09:16,117
プラス100するとすると
この実数を

136
00:09:16,117 --> 00:09:23,512
m 回分コピーして
(m,1)の行列ができるまで繰り返します

137
00:09:23,512 --> 00:09:29,700
そこにここの加算の例のように
演算を実行します

138
00:09:29,700 --> 00:09:35,823
行ベクトルに対しても
同じように動作します

139
00:09:38,281 --> 00:09:43,730
もし関数化されたブロードキャストを使うと
これ以上のこともできます

140
00:09:43,730 --> 00:09:49,080
もし興味があれば
numpy のドキュメントを読んで

141
00:09:49,080 --> 00:09:52,240
ブロードキャストを
見てみるとよいです

142
00:09:52,240 --> 00:09:56,380
より汎用的なブロードキャストの定義が
書いてあります

143
00:09:56,380 --> 00:10:00,140
このスライドに書いてある形のものが
ニューラルネットワークを実装するときには

144
00:10:00,140 --> 00:10:02,560
必要になってくるものです

145
00:10:03,890 --> 00:10:06,840
まとめるまえに
最後にひとこと

146
00:10:06,840 --> 00:10:10,210
Matlab やOctave で
プログラムするのに慣れてる人は

147
00:10:10,210 --> 00:10:15,760
bsxfun を使ったことがあれば

148
00:10:15,760 --> 00:10:20,590
ニューラルネットワークプログラムでは
完全に同じではありませんが似た動きをします

149
00:10:20,590 --> 00:10:25,750
bsxfun はPython での
ブロードキャストと同様の目的に使われます

150
00:10:25,750 --> 00:10:28,505
この情報は
Matlab とOctave の

151
00:10:28,505 --> 00:10:31,600
上級者向けのものです
聞いたことがなくても気にしないでください

152
00:10:31,600 --> 00:10:35,524
Python でコードを組むには
知る必要がないことです

153
00:10:35,524 --> 00:10:38,720
これがPython での
ブロードキャストです

154
00:10:38,720 --> 00:10:42,360
あなたがプログラムアサインメントを
実施するときにブロードキャストを使って

155
00:10:42,360 --> 00:10:44,580
コードを速く動作させるだけでなく

156
00:10:44,580 --> 00:10:48,920
より少ない行数のコードで
実施できる手助けになればと思います

157
00:10:50,360 --> 00:10:53,630
プログラム演習を始めるまえに
１つ共有しておきたいです

158
00:10:53,630 --> 00:10:56,290
私が見つけてきたPython のコードでの

159
00:10:56,290 --> 00:11:00,700
バグを減らすコツです

160
00:11:00,700 --> 00:11:02,640
これが役立てばと思います

161
00:11:02,640 --> 00:11:05,550
ではこれで終わりです
あとは次のビデオで話します