我们已经谈过向量化能够
大大地加速你的代码 在本节课中 我们会讲讲逻辑回归的 向量化实现 使得它们可以被用于处理整个训练集 也就是说 可以用梯度下降法的一次迭代来处理 整个训练集 甚至不需要使用任何一个for循环 我对于这个技术兴奋不已 后面当我们讨论神经网络时 也不需要使用任何一个for循环 那么就让我们开始吧
首先让我们看看逻辑回归的前向传播 假设我们有m个训练样本 为了预测第一个样本 你需要计算这个 计算z 使用这个我们熟悉的公式 来计算激活函数 即计算第一个例子的y值 然后预测第二个样本 你需要做同样的计算 然后预测第三个样本 你还需要做这个计算 以此类推 如果你有m个训练样本 你可能需要重复m次 不过为了实现前向传播 即计算出m个训练样本的预测结果 有一种实现方法 可以不需要for循环 让我们看看如何做到 首先回忆一下 我们曾把矩阵X
定义为训练的输入值 就像这样排列在不同的列中 这就是一个矩阵 一个nx乘m的矩阵 我现在用Python numpy的shape形式来写 这是说X是一个nx乘m维的矩阵 现在我先告诉你如何计算z(1)和z(2) 以及z(3)等等 以上全部在一个步骤中完成 实际上 仅用一行代码即可实现 所以我要先构造一个 1xm维的行向量 方便计算z(1) z(2)等等 直到z(m) 都是在同一时间内(完成计算) 实际上它可以表达成 W的转置矩阵(W^T)与矩阵X相乘
再加上这个向量 b b b ... 其中这个[b b ... b b]的东西 其中这个[b b ... b b]的东西 是个1*m维的向量 或者称为一个1*m维的矩阵
或一个m维的行向量 如果你比较熟悉矩阵乘法的话
你可能就能看出 W的转置乘上X 其实就等价于
W的转置乘上x(1) x(2)等等直到x(m) 其中W^T应该是一个行向量 W^T应该是一个这样的行向量 所以第一项就等于W^T*x(1) W^T*x(2)等等... 直到W^T*x(m) 而当你加上第二项 [b b ... b]时 就等同于你把每一项加上b 所以你得到了另一个1*m的向量 这是第一个元素 这是第二个元素 等等 这是第m个元素 如果你参照上面的定义 第1个元素就是z(1)的定义 第2个元素就是z(2)的定义 等等 就如同我们构造X那样 把你的训练样本水平排列在一起 把你的训练样本水平排列在一起 我将把Z定义为把z(1) z(2) ... z(m)们 水平排列在一起 所以当你把代表着不同训练样本的x们 水平排列在一起 你得到了X 当你用同样的方法把这些z们 水平排列在一起 你会得到Z 为了实现这些计算 numpy命令为Z=np.dot(W.T,X)+b 其中W.T为W的转置 这里有一个python的精妙的地方 这里b是一个实数 或者说一个1*1的矩阵 即一个普通的实数 但是 当你把这个实数b
加到这个向量上的时候 python自动把这个实数b
扩展为一个1*m的行向量 为了防止你觉得这个运算难以理解 这个在python中叫做广播(broadcasting) 现在你不需要担心这个 我们会在下一个视频中详细讨论 这里值得学习的是 你可以用这一行代码 来计算Z 其中Z是一个包含z(1) z(2) ... z(m)的1*m矩阵 其中Z是一个包含z(1) z(2) ... z(m)的1*m矩阵 所以这是求z的过程 那我们怎么求这些a们的值呢 我们下一步要做的 就是找到一个同时求 a(1), a(2), ..., a(m) 的方法 就像把所有x排列在一起可以得到X 把所有z排列在一起可以得到Z 把所有a排列在一起 可以得到一个新的变量 我们将它定义为A 在程序作业中 你会看到如何实现一个
(输入输出为)向量值的sigmoid函数 所以将这个Z作为sigmoid函数的输入值 会非常高效地得到A 你将在程序作业中看到细节 复习一下 我们在这个幻灯片中学到的是 我们不需要遍历m个训练样本来一次一次计算z和a 你可以用一行代码来实现 同时计算所有的z 用这一行代码 以及sigma函数的恰当实现 来同时计算所有的a 这就是你如何通过向量化同时实现 这就是你如何通过向量化同时实现 所有m个训练样本的前向传播 总结一下 你刚刚看到了你如何使用向量化 来高效同时计算所有的激活函数 所有a(1) a(2) ... a(m) 下一步 我们会证明你还可以用向量化来 高效计算反向传播 计算导数 让我们在下一节课中学习如何实现它
GTC字幕组翻译