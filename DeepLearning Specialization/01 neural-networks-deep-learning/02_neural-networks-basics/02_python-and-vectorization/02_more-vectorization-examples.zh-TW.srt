1
00:00:00,000 --> 00:00:05,340
在前一段影片您見到一些
如何向量化的例子

2
00:00:05,340 --> 00:00:07,770
使用內建函數來
避免明顯的

3
00:00:07,770 --> 00:00:11,130
迴圈讓您加快
您的程式

4
00:00:11,130 --> 00:00:13,558
讓我們看更多的例子

5
00:00:13,558 --> 00:00:16,110
重要的法則謹記在心是當

6
00:00:16,110 --> 00:00:19,792
您設計您的神經網路程式
或是您的羅吉斯迴歸分析時

7
00:00:19,792 --> 00:00:23,190
儘可能避免
明顯的迴圈

8
00:00:23,190 --> 00:00:27,285
當然不可能完全
不使用迴圈

9
00:00:27,285 --> 00:00:29,520
但當您可以使用內建函數或者

10
00:00:29,520 --> 00:00:32,710
找到其他方法來計算您所需要的

11
00:00:32,710 --> 00:00:36,555
通常會
比您使用明顯的迴圈更快

12
00:00:36,555 --> 00:00:38,445
讓我們看另一個例子

13
00:00:38,445 --> 00:00:44,412
假設您想計算一個向量
U 是矩陣 A 乘上

14
00:00:44,412 --> 00:00:46,144
另一個向量，V

15
00:00:46,144 --> 00:00:50,840
矩陣乘法的定義是您的 Ui

16
00:00:50,840 --> 00:00:55,830
等於 總和於 j, A(i, j), Vj

17
00:00:55,830 --> 00:00:57,050
好是吧。

18
00:00:57,050 --> 00:00:58,445
這是 Ui 的定義

19
00:00:58,445 --> 00:01:01,500
所以
非向量化建置是

20
00:01:01,500 --> 00:01:06,140
設 U 等於  np.zeros

21
00:01:06,140 --> 00:01:08,105
這會是 n 乘 1

22
00:01:08,105 --> 00:01:11,745
然後 for i 等等

23
00:01:11,745 --> 00:01:14,250
for j 等等

24
00:01:14,250 --> 00:01:22,950
然後 Ui += Aij 乘上 Vj

25
00:01:22,950 --> 00:01:27,725
所以這是兩個
迴圈經過 i 跟 j

26
00:01:27,725 --> 00:01:29,269
這是非向量化版本

27
00:01:29,269 --> 00:01:37,355
向量化建置是
 u = np.dot(Ａ,v)

28
00:01:37,355 --> 00:01:39,160
這樣在右邊的向量化建置

29
00:01:39,160 --> 00:01:41,655
現在消除了

30
00:01:41,655 --> 00:01:44,628
兩個不同的迴圈且會快很多

31
00:01:44,628 --> 00:01:46,655
讓我們看下一個例子

32
00:01:46,655 --> 00:01:50,900
假設您已經有一個向量 
v 在記憶體中您想要

33
00:01:50,900 --> 00:01:55,190
應用指數函數到
v 的每一個元素

34
00:01:55,190 --> 00:01:59,250
您計算 U 是一個向量
即 e 的 v1次方, e 的 v2次方

35
00:01:59,250 --> 00:02:04,085
等等直到 e 的 vn次方

36
00:02:04,085 --> 00:02:10,370
這是一個非向量化
的建置, 就是首先

37
00:02:10,370 --> 00:02:13,700
初始化 U 為零向量，然後你

38
00:02:13,700 --> 00:02:18,260
然後您用一個迴圈來
計算一次一個元素

39
00:02:18,260 --> 00:02:24,110
實際上 Python numpy 有
很多內建函數讓您

40
00:02:24,110 --> 00:02:31,160
計算這些向量就只用
一個單一的函數呼叫

41
00:02:31,160 --> 00:02:40,180
所以我會這樣建置
導入 numpy 為 np

42
00:02:40,180 --> 00:02:50,110
然後您只要呼叫 U 等於
np.exp(v), 注意到前面

43
00:02:50,110 --> 00:02:53,600
您用了一個明顯的迴圈
現在用一行程式

44
00:02:53,600 --> 00:02:57,317
這裡 v 是一個輸入向量

45
00:02:57,317 --> 00:02:58,840
u 是一個輸出向量

46
00:02:58,840 --> 00:03:02,340
您消除了明顯得迴圈
而在右邊的建置

47
00:03:02,340 --> 00:03:06,275
會比用明顯的迴圈快很多

48
00:03:06,275 --> 00:03:10,310
實際上, numpy 函數庫有很多
向量值的函數

49
00:03:10,310 --> 00:03:15,175
像 np.log(v) 會計算
逐元素的對數函數

50
00:03:15,175 --> 00:03:19,220
np.abs 計算絕對值

51
00:03:19,220 --> 00:03:24,935
np.maximum 計算
元素中的極大值

52
00:03:24,935 --> 00:03:29,850
所以您取
每一個元素 v 跟 0 的最大值

53
00:03:29,850 --> 00:03:31,290
v 星號 星號 2

54
00:03:31,290 --> 00:03:38,214
v**2 算每一個元素
的平方對於每個元素

55
00:03:38,214 --> 00:03:42,932
1/v 取每個元素的倒數
等等

56
00:03:42,932 --> 00:03:45,635
每當您試著寫
迴圈時

57
00:03:45,635 --> 00:03:48,440
先看一下，看看是否可以呼叫

58
00:03:48,440 --> 00:03:53,069
numpy 內建函式
來做它而不需要用到迴圈

59
00:03:53,069 --> 00:03:55,640
讓我們將所有學到的應用到

60
00:03:55,640 --> 00:03:59,105
羅吉斯迴歸分析
梯度下降建置

61
00:03:59,105 --> 00:04:02,955
看是否我們可以去除
至少兩個迴圈之一

62
00:04:02,955 --> 00:04:07,980
這是我們的程式來計算
羅吉斯迴歸分析的導數

63
00:04:07,980 --> 00:04:09,335
我們有兩個迴圈

64
00:04:09,335 --> 00:04:13,065
一個是在這裡, 
第二個是在這裡

65
00:04:13,065 --> 00:04:15,422
所以在我們的例子

66
00:04:15,422 --> 00:04:17,810
我們有 n 或者說 nx 等於 2

67
00:04:17,810 --> 00:04:19,910
但如果您有更多的特徵

68
00:04:19,910 --> 00:04:23,865
比兩個多的特徵,
那您需要用一個迴圈對於 dw1

69
00:04:23,865 --> 00:04:25,676
dw2, dw3 等等

70
00:04:25,676 --> 00:04:30,305
假設這裡是 for j 等於 1 到 nx

71
00:04:30,305 --> 00:04:37,395
dwj 做更新, 是吧?

72
00:04:37,395 --> 00:04:41,745
所以我們想消除這
第二個 for 迴圈

73
00:04:41,745 --> 00:04:43,745
這是我們在這裡要做的

74
00:04:43,745 --> 00:04:48,725
所以我們要做的方式是
與其用明顯的初始化 dw1

75
00:04:48,725 --> 00:04:51,390
dw2 等等為零

76
00:04:51,390 --> 00:04:58,100
我們將去掉這個,
而是將 dw 用成一個向量

77
00:04:58,100 --> 00:05:05,600
我們設 dw 等於np.zeros, 然後

78
00:05:05,600 --> 00:05:10,490
做一個 nx 乘 1 維度的零向量

79
00:05:10,490 --> 00:05:13,175
然後這裡, 與其使用

80
00:05:13,175 --> 00:05:15,941
迴圈經過每一個元素

81
00:05:15,941 --> 00:05:19,190
我們只用這個向量值運算

82
00:05:19,190 --> 00:05:22,350
dw +=

83
00:05:22,350 --> 00:05:32,031
xi 乘 dZi, 最後

84
00:05:32,031 --> 00:05:33,620
取代這個, 我們用

85
00:05:33,620 --> 00:05:42,562
dw /= m, 現在我們將兩個
迴圈變成一個迴圈

86
00:05:42,562 --> 00:05:48,864
我們還有這一個迴圈
經過每一個訓練例子

87
00:05:48,864 --> 00:05:51,030
我希望這段影片給您
一些感覺有關

88
00:05:51,030 --> 00:05:54,165
向量化 以及去掉一個迴圈

89
00:05:54,165 --> 00:05:56,505
您的程式已經可以跑更快

90
00:05:56,505 --> 00:05:58,320
但實際上我們可以做得更好

91
00:05:58,320 --> 00:05:59,418
因此,在下一段影片,

92
00:05:59,418 --> 00:06:03,237
我將談到如何更深入向量化
羅吉斯迴歸分析

93
00:06:03,237 --> 00:06:07,365
您看到相當驚訝的結果
不使用任何迴圈

94
00:06:07,365 --> 00:06:10,695
不需要一個迴圈
經過這些訓練例子

95
00:06:10,695 --> 00:06:14,760
您可以用程式來處理
整個訓練集

96
00:06:14,760 --> 00:06:17,060
幾乎在一個時間內

97
00:06:17,060 --> 00:06:19,000
讓我們下一段影片見