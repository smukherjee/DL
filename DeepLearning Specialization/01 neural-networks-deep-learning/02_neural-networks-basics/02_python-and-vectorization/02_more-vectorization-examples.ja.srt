1
00:00:00,676 --> 00:00:04,870
前回のビデオでは
組み込み関数を使って

2
00:00:04,870 --> 00:00:08,140
for loop を避けて
ベクトル化することで

3
00:00:08,140 --> 00:00:11,210
コードをかなり高速化できる例を
見てきました

4
00:00:11,210 --> 00:00:12,870
もう少し例を見てみましょう

5
00:00:13,960 --> 00:00:17,898
覚えておくべき教訓は
ニューラルネットワークをプログラムする時や

6
00:00:17,898 --> 00:00:20,061
ロジステック回帰をプログラムするときは
可能な限り

7
00:00:20,061 --> 00:00:22,341
for loop を避けることです

8
00:00:22,341 --> 00:00:27,337
for loop を避けるのは
いつも可能なわけではないですが

9
00:00:27,337 --> 00:00:32,580
組み込み関数を使ったり
可能なかぎり他の計算方法を探すと

10
00:00:32,580 --> 00:00:37,120
for loop を使うよりも
たいがいは速くなります

11
00:00:37,120 --> 00:00:38,640
開始点から theta を増加させるというのは、これも意図通りの動作のようです。

12
00:00:38,640 --> 00:00:45,227
ベクトルu を行列AとベクトルVの

13
00:00:45,227 --> 00:00:50,757
積を求めたいとすると
行列積の定義は

14
00:00:50,757 --> 00:00:56,659
uiはjで合計した
AijとVjの積です

15
00:00:56,659 --> 00:00:58,406
このようにuiの式を作ります

16
00:00:58,406 --> 00:01:03,851
これをベクトル化しない方法で
実装すると

17
00:01:03,851 --> 00:01:09,750
u=np.zeros((n,1))となり

18
00:01:09,750 --> 00:01:12,280
for i と続き

19
00:01:12,280 --> 00:01:15,600
for j と続きます

20
00:01:16,670 --> 00:01:23,050
そしてu[i]+=A[i][j]*v[j]です

21
00:01:23,050 --> 00:01:26,971
これにはi とj を
繰り返す２重のループがあります

22
00:01:26,971 --> 00:01:30,864
これがベクトル化しないコードです

23
00:01:30,864 --> 00:01:37,467
ベクトル化するコードでは
u=np.dot(A,v)です

24
00:01:37,467 --> 00:01:40,726
右側のベクトル化版の実装では

25
00:01:40,726 --> 00:01:45,040
２つのfor loop を排除できるので
かなり速いでしょう

26
00:01:45,040 --> 00:01:46,790
もう１つ例を見てみましょう

27
00:01:46,790 --> 00:01:50,720
ベクトルv がメモリ上にあるとします

28
00:01:50,720 --> 00:01:55,420
ベクトルv の全要素に
指数演算を実行しようとしています

29
00:01:55,420 --> 00:02:00,370
uにはベクトルのv1の指数関数e

30
00:02:00,370 --> 00:02:05,700
v2の指数関数eから
vnの指数関数eまで続きます

31
00:02:05,700 --> 00:02:09,390
ベクトル化しない実装は
こんなコードになります

32
00:02:09,390 --> 00:02:13,342
最初にu を
０で初期化されたベクトルにします

33
00:02:13,342 --> 00:02:18,350
次にfor loop を使って
要素を１つずつ計算します

34
00:02:18,350 --> 00:02:23,890
Python のnumpy には
多くの組み込み関数があり

35
00:02:23,890 --> 00:02:31,270
ただ１つの関数を１度呼ぶだけで
ベクトルを計算できます

36
00:02:31,270 --> 00:02:34,720
このため私だったら
このように実装します

37
00:02:36,500 --> 00:02:41,640
import numpy as np と書き

38
00:02:41,640 --> 00:02:47,250
u = np.exp(v) を
呼ぶだけです

39
00:02:47,250 --> 00:02:52,029
このように前の例では
for loop を書きましたが

40
00:02:52,029 --> 00:02:56,879
こちらのたった１行のコードでは
v を入力のベクトルに指定しu を出力のベクトルに指定しました

41
00:02:56,879 --> 00:03:01,438
for loop の部分を排除しました

42
00:03:01,438 --> 00:03:06,030
右側の実装のほうがfor loop を必要とする実装よりも
かなり高速です

43
00:03:06,030 --> 00:03:10,360
実はnumpy ライブラリには
他にも多くのベクトル値処理関数があります

44
00:03:10,360 --> 00:03:16,124
np.log(v) は
要素ごとのlog を実行します

45
00:03:16,124 --> 00:03:20,260
np.abs は
要素ごとの絶対値を計算し

46
00:03:20,260 --> 00:03:25,525
np.maximum は
要素ごとにmaximum を計算します

47
00:03:25,525 --> 00:03:30,207
v の各要素に対して
0以上の最大値を出します

48
00:03:30,207 --> 00:03:36,230
v**2 では各要素に対して
v の２乗を出します

49
00:03:36,230 --> 00:03:42,950
1/v では各要素の逆数を
計算します

50
00:03:42,950 --> 00:03:47,390
なのでfor loop を
書きたいと思った時は

51
00:03:47,390 --> 00:03:52,022
for loop なしで出来ないか
numpy の組み込み関数がないか常に確認しましょう

52
00:03:53,200 --> 00:03:55,387
これらの学習したことを使って

53
00:03:55,387 --> 00:03:59,036
ロジステック回帰の勾配降下法の実装に
適用してみましょう

54
00:03:59,036 --> 00:04:03,240
for loop を１つでも２つでも
排除できないかやってみましょう

55
00:04:03,240 --> 00:04:04,310
このコードが

56
00:04:04,310 --> 00:04:09,350
ロジステック回帰の微分を計算するもので
２つのfor loop があります

57
00:04:09,350 --> 00:04:12,430
１つ目はここで
２つ目はここです

58
00:04:12,430 --> 00:04:15,736
この例では
nx=2ですが

59
00:04:15,736 --> 00:04:20,406
もし３以上の特徴量が
あったとしたら

60
00:04:20,406 --> 00:04:25,194
for loop を使って
dw1、dw2、dw3 と計算する必要があります

61
00:04:25,194 --> 00:04:31,397
実際にはfor i=1からnxのように
書いているのと同じです

62
00:04:31,397 --> 00:04:37,490
そしてdwj を更新します

63
00:04:37,490 --> 00:04:41,850
この２つ目のfor loop を
排除したいと思います

64
00:04:41,850 --> 00:04:43,940
このスライドで実行します

65
00:04:43,940 --> 00:04:49,214
これのやり方は
dw1、dw2を

66
00:04:49,214 --> 00:04:54,120
それぞれ０に初期化するコードを
書くのではなく

67
00:04:54,120 --> 00:05:00,267
これを排除して
dw をベクトルにします

68
00:05:00,267 --> 00:05:04,884
dw=np.zeros((n_x,1))と書き

69
00:05:04,884 --> 00:05:10,000
次元を持つ配列にします

70
00:05:11,020 --> 00:05:14,527
個々の要素に対して

71
00:05:14,527 --> 00:05:18,663
実行するここのloop の替わりに

72
00:05:18,663 --> 00:05:23,551
このベクトル演算命令を使います

73
00:05:23,551 --> 00:05:27,080
dw+=x(i)かけるdz(i)と
書きます

74
00:05:27,080 --> 00:05:33,017
そして最後に
これの替わりに

75
00:05:33,017 --> 00:05:39,160
dw/=m と書きます

76
00:05:39,160 --> 00:05:42,540
このように２つのfor loop から
１つに変えました

77
00:05:42,540 --> 00:05:47,270
まだこのfor loop があり
トレーニングデータをループしています

78
00:05:49,180 --> 00:05:52,190
このビデオによって
ベクトル化を理解してもらいたいです

79
00:05:52,190 --> 00:05:56,442
１つのfor loop を排除することで
コードは速く動作するはずです

80
00:05:56,442 --> 00:05:58,370
ただもっと良くすることができます

81
00:05:58,370 --> 00:06:02,432
次のビデオでは ロジステック回帰を
さらにベクトル化する方法を話します

82
00:06:02,432 --> 00:06:03,420
ひどくはね

83
00:06:03,420 --> 00:06:07,430
かなり驚きの結果を見ることになります

84
00:06:07,430 --> 00:06:10,890
for loop を使う方法で
トレーニングデータを処理する必要なく

85
00:06:10,890 --> 00:06:14,850
全トレーニングデータを処理するコードを
書けるのです

86
00:06:14,850 --> 00:06:17,170
いつでも同じ方法で
使うことができます

87
00:06:17,170 --> 00:06:18,880
次のビデオでは
これを見てみましょう