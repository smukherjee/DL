Можливість використовувати в Python операції посіву і, взагалі, гнучкість мови програмування Python/NumPy, на мою думку, є одночасно перевагою і недолікам мови програмування. Я думаю, що перевага в тому, що мові надали виразності. Висока гнучкість мови дозволяє багато чого зробити 
за допомогою лише одного рядка коду. Проте, є й недолік, бо посів (а це теж належить до гнучкості) інколи створює характерні помилки, що видаються дуже дивними, якщо тобі невідомі тонкощі роботи посіву чи схожих технік. Наприклад, якщо взяти вектор-стовпець і вектор-рядок, то ми очікуватимемо 
помилку співвідношення розмірів або типу, або щось таке. Але можна отримати і матрицю як результат суми вектора-стовпця і вектора-рядка. Проте, у цієї дивної властивості Python є внутрішня логіка. Але якщо ти не знайомий з Python, то, 
як я бачив у деяких студентів, може бути дуже важко знайти помилки. Тож в цьому відео я хочу поділитись кількома хитрощами, які були дуже корисними для мене і допомогли позбутись, чи то спростити і позбутись деяких дивних помилок в моєму коді. Надіюсь, що з цими хитрощами ти теж зможеш набагато легше писати безпомилковий код Python і NumPy. Щоб проілюструвати не дуже зрозумілий ефект Python/NumPy, особливо при побудові векторів в Python/NumPy, 
я зроблю коротку демонстрацію. Встановимо a=np.random.randn(5). Це створить 5 випадкових Гаусівських змінних в масиві a. Давай виведемо a: ptint(a). Тепер, виявляється, що shape.a, якщо вивести, матиме структуру (5,). Це називається масивом 1-ого порядку в Python і не являється ні вектором-рядком, ні вектором-стовпцем. І це важко інтуїтивно зрозуміти. Тож, наприклад, якщо я виведу транспоноване a, 
то воно буде таким же як і a. Тож a і aᵀ мають однаковий вигляд. Якщо я виведу скалярний добуток a і aᵀ, то ти, можливо, подумаєш, що a*aᵀ буде векторним добутком і дасть в результаті матрицю. Проте, якщо я виведу це, то отримаю число. Тож я рекомендую при написанні коду нейронної мережі (НМ) не використовувати структури даних, що є масивами 1-ого порядку. Натомість, якщо встановити a ось так, (5, 1), то це обов'язково буде вектором-стовпцем. І якщо в попередньому випадку a і aᵀ мають однаковий вигляд, то тепер aᵀ буде вектором-рядком. Відміть, одну тонку відмінність. В цій структурі даних ми маємо подвійні квадратні дужки 
коли виводимо aᵀ. В той час як раніше ми мали одинарні квадратні дужки. Ось яка між ними різниця. Ось це - справді матриця 1*5, а це - масив 1-ого порядку. Якщо ми виведемо добуток a і aᵀ, то отримаємо векторний добуток, правильно? Тож, векторний добуток дає нам матрицю. Давай детальніше розглянемо те, що щойно побачили. Ось перша команда, яку ми виконали. Вона створює структуру даних, де a.shape було оцим дивним "(5,)". Це називається масивом 1-ого порядку. Це досить дивна структура даних. Вона не веде себе ні як вектор-рядок, ні як вектор-стовпець, тому інколи ми отримуємо незрозумілий результат. Тому я рекомендую, при виконанні програмувальних завдань або при реалізації логістичної регресії (ЛР) чи НМ, не користуватись масивами 1-ого порядку. Натомість, при створенні масиву, слід будувати вектор-стовпець (буде створено вектор 5*1) або слід будувати вектор-рядок. В такому випадку поведінку вектора буде легше зрозуміти. Тож в цьому випадку a.shape буде = 5*1 і буде вести себе і, фактично, буде вектором-стовпцем. Тому можна вважати це матрицею 5*1, 
хоча це й вектор-стовпець. А тут a.shape буде 1*5 і вести себе буде повністю як вектор-рядок. Тож коли тобі потрібен вектор, 
я раджу використовувати або цей, або цей, але не масив 1-ого порядку. Ще одна річ, яку я використовую в своєму коді, 
це якщо я не впевнений якого розміру один з моїх векторів, 
то я часто виводжу підтверджувальні команди такого типу, щоб впевнитись (в цьому випадку), що це - вектор 5*1. Тож це - вектор-стовпець. Ці операції досить недорогі для виконання. Вони також допомагають вести документацію коду. Тож не соромся вивести підтверджувальні команди (як ось ця), якщо відчуваєш потребу. І, нарешті, 
якщо з якихось причин ти отримаєш масив 1-ого порядку, ти можеш трансформувати його - a.reshape(...) - в масив 5*1 або 1*5, щоб змусити його поводитись як вектор-стовпець або вектор-рядок. Інколи я помічаю як студентам дуже важко знайти помилки, тому що масиви 1-ого порядку поводяться незрозуміло. Видаливши масиви 1-ого порядку зі свого коду, 
я вважаю, що він став простішим. І я ще не помічав щоб це обмежувало якось можливості мого коду. Я взагалі ніколи не використовую масиви 1-ого порядку. Тож, запам'ятай, що щоб спростити код - 
ніколи не використовуй масиви 1-ого порядку. Завжди використовуй або матриці n*1, тобто вектори-стовпці, або матриці 1*n, тобто вектори-рядки. Вільно додавай багато підтверджувальних команд, щоб перепровірити розміри матриць і масивів. Також не соромся, викликати операцію reshape(), 
щоб пересвідчитись, що твої матриці або вектори мають той розмір, який потрібно. Отже, надіюсь, ці поради допоможуть тобі видалити причину помилок з коду Python і дозволять легше впоратись із вправами.