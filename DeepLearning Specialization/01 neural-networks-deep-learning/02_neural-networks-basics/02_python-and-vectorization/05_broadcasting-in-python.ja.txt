前のビデオでは
ブロードキャストというテクニックを使うと Python のコードの実行速度を
速めることができると言いました このビデオではPython でのブロードキャストが
どう動作するのか掘り下げましょう ブロードキャストを
例で見てみましょう この行列では４種類の食べ物での
100グラムあたりのカロリーを 炭水化物、タンパク質
脂質の別に示しました 例えば100グラムのリンゴのカロリーは 炭水化物からは56カロリーで
タンパク質と脂質からではかなり少ないです 一方 牛肉ではタンパク質からは104カロリーで
脂質からは 135カロリーです ここでの目標は４種類の食品での
炭水化物、タンパク質、脂質からの カロリーの割合を
計算することだとしましょう 例えばこの列を見ると この列の数を足していくと
100グラムのリンゴは 56+1.2+1.8で
59カロリーと分かります そしてリンゴでの 炭水化物からのカロリーは
56割る59なので 約94.9%です リンゴでのカロリーは
ほとんどが炭水化物からです 一方で牛肉のカロリーは
タンパク質と脂質からです このためには
この行列の４つの列を合計して 100グラムでのリンゴ
牛肉、卵、じゃがいもでの総カロリーを 出します その後行列の数の全てを割り ４種類の食品の炭水化物、タンパク質、脂質の
割合を%で 出します ここでの疑問はfor loop を書くことなく
これができるかです どうするのか見てみましょう お見せします この行列を３ｘ４の行列Aとします １行のPython のコードで
列の値を合計します ４つの食品のカロリーの合計にあたる ４つの数字を計算します ４種類の食品の
100グラムあたりのものです そして２行目のPython のコードを使って その列の合計に該当する数で
列の中の数を割ります 言葉での説明が明らかでない場合には これから見るPython のコードを見たら
分かりやすくなると思います Jupyter Notebook に入ってきました 表のカロリー数を
行列Aに入れるための最初のコードは 書いておきました
shift+enterで実行しましょう 行列のAが出ています ここに２行のPython コードを入れます まずcal=A.sum(axis=0)と書き axis=0 は縦を足すという意味です すぐにもっと詳しい話をします cal をprint します 縦に合計しています 59がリンゴでの総カロリーで 239が牛肉での総カロリーで
卵、じゃがいもと続きます 次に%を計算します A/cal.reshape(1,4)を 100倍にしてパーセントを出します percentage をprint しましょう 実行しましょう このコマンドでは
行列Aを使って ここの１ｘ４の行列で割っています これで行列でのパーセントが出ています 手で計算したのと同じように
最初の列のリンゴでは 94.9%が炭水化物から来ています スライドに戻りましょう 使った２行のコードを振り返ります これがJupyter Notebook に
書いたものです 少し詳しく説明すると
このパラメーター(axis=0)は Python で縦方向に合計することを
意味します axis 0 は
縦に足し 一方axis 1 は
横に足すです axis 1 と書けば
縦ではなく横に足します 次の命令は Python のブロードキャストの例です 行列Aは３ｘ４の行列で
これを１ｘ４の行列で割ります 技術的には１行目のコードの実行後には
変数cal は １ｘ４の行列になっています 技術的にはこのreshape を
再度呼ぶ必要はありません 実は少し冗長ですが わたしはPython のコードを書くときに 行列の配列数が分からないときは
reshape コマンドを実行するようにしています 行や列のベクトルが
確かに望んでいる形になっているように 実行しています reshape 命令は
一定時間で実行できるものです 処理量に対して一次的な命令なので
呼び出しコストが非常に低いです reshape を控え目に使うのではなく
行列が必要なサイズになるのを確実にするために 積極的に使いましょう このような命令がどう動作するのかを
詳しく説明します ３ｘ４の行列を
１ｘ４の行列で割ります どのようにして３ｘ４を
１ｘ４のベクトルで 割るのでしょうか ブロードキャストの例を
もう少し見ていきましょう ４ｘ１のベクトルに対して
ある数を足すと Python は自動で ４ｘ１のベクトルに
拡張します ベクトル[1,2,3,4]に 100を足すと
右側のベクトルが出来上がります 100をすべての要素に足すことになり
この形のブロードキャストは これまでのビデオで
定数はbですが同じことを行っていました この形のブロードキャストは
列ベクトルでも行ベクトルでも動作します 実は同じような形のブロードキャストを行っています ロジステック回帰で
足されるのは定数b という形で行っていました もう一つの例です。 ２ｘ３の行列と１ｘn のベクトルが 足される場合です 一般化すると (m,n)の行列を (1,n)の行列に足します Python が行うのは
(1,n)の行列を m回コピーして
mｘnの行列にします １ｘ３の行列をコピーして
このような形にします ２ｘ３の行列の形になります その後加算を行って
右側のようになります １列目に100を加え ２列目に200を
３列目に300を加えます これは前のスライドで
行ったこととほぼ同じです 先ほどは割り算命令でしたが
今回は加算命令です 最後にもう１つの例です
mｘn の行列に ｍｘ１の行列を足した場合には
どうなるでしょうか n 回分横にコピーを行って ｍｘn の行列ができます 横に３列分になるまでコピーされます そして加算し このような結果になります 最初の行に100を足し
２つ目の行に200を足します Python での基本的原則を
紹介します (m,n) の行列があり
これに (1,n) の行列の加算、減算
乗算、除算を行うと m 回分コピーして
(m,n)の行列を作ります その後要素ごとに
加算、減算 乗算、除算を
適用します もし逆に(m,n)の行列を
(m,1)の行列で 割るとしたら
この場合にもn 回分コピーされて (m,n)行列になり
要素ごとに計算を適用します 他のブロードキャストを紹介します
(m,1)の行列があるとします 列ベクトルで[1,2,3]となっています これに実数を加算、減算
乗算、除算すると (1,1)の行列で プラス100するとすると
この実数を m 回分コピーして
(m,1)の行列ができるまで繰り返します そこにここの加算の例のように
演算を実行します 行ベクトルに対しても
同じように動作します もし関数化されたブロードキャストを使うと
これ以上のこともできます もし興味があれば
numpy のドキュメントを読んで ブロードキャストを
見てみるとよいです より汎用的なブロードキャストの定義が
書いてあります このスライドに書いてある形のものが
ニューラルネットワークを実装するときには 必要になってくるものです まとめるまえに
最後にひとこと Matlab やOctave で
プログラムするのに慣れてる人は bsxfun を使ったことがあれば ニューラルネットワークプログラムでは
完全に同じではありませんが似た動きをします bsxfun はPython での
ブロードキャストと同様の目的に使われます この情報は
Matlab とOctave の 上級者向けのものです
聞いたことがなくても気にしないでください Python でコードを組むには
知る必要がないことです これがPython での
ブロードキャストです あなたがプログラムアサインメントを
実施するときにブロードキャストを使って コードを速く動作させるだけでなく より少ない行数のコードで
実施できる手助けになればと思います プログラム演習を始めるまえに
１つ共有しておきたいです 私が見つけてきたPython のコードでの バグを減らすコツです これが役立てばと思います ではこれで終わりです
あとは次のビデオで話します