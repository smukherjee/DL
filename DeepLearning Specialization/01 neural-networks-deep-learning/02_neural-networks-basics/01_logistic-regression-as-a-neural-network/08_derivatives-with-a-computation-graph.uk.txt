В останньому відео ми розглянули приклад використання Діаграми обчислень 
для функції J. Тепер давай розглянемо зворотну версію Діаграми обчислень і подивимось як її можна використовувати для обчислення похідних функції J. Ось Діаграма обчислень. Скажімо, ми хочемо обчислити [часткову] похідну J по v. Що це означає? Це значить, що якщо ми візьмемо значення v і трохи змінимо його... Як же зміниться значення J? Що ж, J визначається як 3v і в даний момент v=11. Тож якщо ми трохи збільшимо v до 11,001, то J, яка =3v, тобто 33, збільшиться до 33,003. Тож ми збільшили v на 0,001 і в результаті J збільшується на втричі більше. Тож [часткова] похідна J по v =3. Тому що збільшення J втричі більше збільшення v. І це дуже схоже на приклад з попереднього відео, де ми мали f(a)=3a. І ми тоді вивели, що df(a)/da (при дещо спрощеному, дещо недбалому записі) 
можна записати як df/da=3 Зараз у нас J=3v, тож dJ/dv=3. Тож J тут грає роль f(a), а v грає роль a з попереднього прикладу попереднього відео. Тож, справді, згідно термінології зворотного поширення, як бачимо, якщо ми хочемо обчислити [часткову] похідну по остаточній змінній (яка, як правило, є найбільш потрібною), по v, то це можна зробити одним кроком зворотного поширення. Це ми називаємо одним кроком назад на цій діаграмі. Тепер давай розглянемо інший приклад. Що таке dJ/da? Іншими словами, 
якщо ми трохи змінимо значення a, то як це вплине на J? Що ж, давай рухатись далі. Зараз a=5. Давай збільшимо його до 5,001. В результаті v, яке =a+u, що =11, збільшиться до 11,001. І далі, як ми вже бачили вище, J збільшиться до 33,003. То ж ми бачимо, що 
якщо збільшити a на 0,001, J збільшиться на 0,003. І під збільшенням я маю на увазі, що ми можемо замість 5 підставити для a нове значення. Далі зміна a пошириться вправо по Діаграмі обчислень, і J стане 33,003. І, отже, збільшення J втричі більше збільшення a. А це значить, що ця похідна =3. Якщо розбити це на частини, то ми побачимо, що зміна a веде до зміни v, а зміна v веде до зміни J. Тож остаточна зміна значення J, коли ми збільшуємо, коли ми дещо підштовхуємо значення a догори, це те, що зміна a збільшує [змінює] v. Що ж, наскільки v збільшується [змінюється]? Воно збільшується [змінюється] на величину визначену dv/da. І зміна v приведе також до збільшення [зміни] J. Тож в диф.численні це називається ланцюговим правилом 
[правило диференціювання складної функції]. Тобто, якщо a впливає на v, а це впливає на J, 
то величина, на яку змінюється J при зміні a, буде добутком величини зміни v при зміні a і величини зміни J при зміні v. Тож в диф.численні це зветься ланцюговим правилом. Тож, як ми бачимо з цих обчислень, якщо збільшити a на 0,001, v збільшиться на цю ж величину. Тож dv/da=1. Тож, якщо підставити те, що ми записали щойно - dJ/dv=3 і dv/da=1 - то добуток 3 і 1 дасть нам правильне значення dJ/da=3. Тож ця маленька ілюстрація показує як, маючи обчислене dJ/dv (що є [частковою] похідною по цій змінній), 
це може допомогти обчислити dJ/da. Тож це наступний крок - зворотне обчислення. Хочу представити ще одну нотативну конвенцію. Це коли ми пишемо код реалізації зворотного поширення, ми зазвичай маємо певну остаточну дуже важливу змінну. Певну остаточну дуже важливу змінну, яку ми хочемо оптимізувати. В цьому випадку ця остаточна змінна - J. Це останній вузол в нашій Діаграмі обчислень. І, отже, багато обчислень намагатимуться обчислити похідну остаточної змінної. Тож d цієї остаточної змінної по деякій іншій змінній, ми називаємо dvar. Тож багато обчислень, 
які нас чекають, будуть обчислювати [часткові] похідні остаточної змінної (J в даному випадку) по різних проміжних змінних, таких як a, b, c, u або v. І коли ми почнемо реалізувати це в програмі, 
як нам назвати цю змінну? Одним зі способів у Python може бути довжелезне ім'я типу dFinalOutputVar/dvar. Проте, це дуже довге ім'я для змінної. Ти можеш назвати її, думаю, dJdvar. Але через те, що ми завжди братимемо похідні від dJ, від цієї остаточної змінної, я представлю нове позначення. Згідно якого, 
в коді (при обчисленні ось цього), який ми будемо писати, ми будемо просто використовувати dvar 
для позначення цього виразу. Тож dvar в коді, який ми будемо писати, буде позначати похідну, остаточну дуже важливу змінну типу J. А інколи - Втрату L по відношенню до різних проміжних рівнянь, які ти обчислюватимеш в коді. Тож ось це в коді буде позначатись dv. Тобто dv буде =3. А в коді буде позначатись як da. І воно теж буде =3. Тож з допомогою цієї Діаграми обчислень 
ми частково здійснили зворотне поширення. Давай завершимо розглядати цей приклад на наступному слайді. Тож давай зробимо чисту копію Діаграми обчислень і резюмуємо, що ми зробили до цього моменту. Ми повернулись сюди і знайшли, що dv=3. І, знову ж, за визначенням dv - це просто назва змінної, а в коді - це справді dJ/dv. Ми знайшли, що da=3. І, знову ж, da - це назва змінної в коді, а насправді - значення dJ/da. Ми, ніби, подаємо руку у відповідь 
[в зворотному напрямку] стосовно цих двох блоків. Тепер давай продовжимо обчислювати похідні. Давай подивимось на значення u. Тож чому =dJ/du? Що ж, скористаємось схожими обчисленнями, які ми вже робили. Почнемо з того, що u=6. Якщо ми трохи збільшимо його до 6,001, то v, що =11, збільшиться до 11,001. І, отже, J зміниться з 33 до 33,003. Тож збільшення J - трикратне і =3. А аналіз u дуже схожий до аналізу, який ми робили для a. Воно обчислюється як dJ/dv помножити на dv/du, а ми вже обчислили, що це буде 3. А ось це буде =1. Тож ми закінчили ще один крок зворотного поширення. В результаті обчислень ми отримали, що du також =3. Під du ми, звичайно, маємо на увазі dJ/du. І тепер востаннє детально пройдемо наступний крок. Тож чому =dJ/db? Уявімо, що ми можемо змінювати значення b, тобто налаштовувати його так, щоб мінімізувати або максимізувати значення J. Тож яка похідна чи який нахил цієї функції J, якщо ми трохи змінимо значення b? Виявляється, 
що, використовуючи ланцюгове правило диф.числення, це можна записати як добуток двох виразів: dJ/du і du/db. Міркування наступні. Якщо трохи змінити b, скажімо з 3 до 3,001, то перед тим як змінити J, це спочатку змінить u. Наскільки це змінить u? Що ж, u визначається як b*c. Тож воно зміниться від 6 (бо b=3) до 6,002, тому c=2 в даному прикладі. Тобто ми отримаємо, що du/db=2. Тому що коли збільшуємо b на 0,001, 
u збільшується на вдвічі більшу величину. Тож du/db=2. Тож тепер ми знаємо, 
що u збільшиться на вдвічі більшу величину ніж b. Тож чому =dJ/du? Ми вже визначили, що воно =3. І, отже, перемноживши ось ці 2 вирази, ми отримаємо, що dJ/db=6. І, знову ж, це міркування щодо 2-ої частини аргументу. Давай дізнаємось як зміниться J, якщо ми збільшимо u на 0,002. Те, що dJ/du=3, каже нам, що якщо збільшити u на 0,002, то J збільшиться на втричі більшу величину. Тобто J повинно збільшитись на 0,006. Це ми бачимо з того, що dJ/du=3. Якщо ти проведеш детальні обчислення, то побачиш, що коли b стає 3,001, то u стає 6,002, v стає 11,002. А це - a+u, тобто 5+u. А J, яке =3v, буде =33,006. Ось як ми отримуємо, що dJ/db=6. Тож підставимо це, підемо в зворотньому напрямку. Тож db=6. db - це назва змінної в Python для dJ/db. Я не буду вдаватись в деталі в останньому кроці, бо, обчислюючи dJ [/dc], ми побачимо, що це - dJ/du помножене на du/dc. А це буде 9, тобто 3*3. Не будемо вдаватись в деталі. Тож в цьому останньому кроці, ми зможемо виявити, що dc=9. Що ми повинні винести з цього відео, з цього прикладу, 
це те, що обчислюючи всі ці [часткові] похідні, найбільш ефективно буде робити це справа-наліво, в напрямку червоних стрілок. В цьому конкретному випадку 
ми спочатку обчислюємо [часткову] похідну по v, і далі це допоможе нам обчислити [часткову] похідну по a і [часткову] похідну по u. А потім [часткова] похідна по u, наприклад, ось цей вираз і ось цей вираз в свою чергу допоможуть обчислити [часткову] похідну по b і [часткову] похідну по c. Тож це була Діаграма обчислень, 
що спочатку обчислюється зліва-направо, щоб обчислити функцію Витрат, 
таку як J, яку ми хочемо оптимізувати. А потім - у зворотному напрямку, 
тобто справа-наліво, щоб обчислити похідні. Якщо ти недостатньо ознайомлений/а з диф.численням 
чи ланцюговим правилом (я розумію, що деякі деталі ми швиденько пробігли), якщо ти не зрозумів/ла всій деталей, не переймайся. У наступному відео ми ще раз пройдемось по них в контексті логістичної регресії (ЛР). І покажемо що саме необхідно робити, щоб реалізувати обчислення, які потрібні для обчислення похідних моделі ЛР.