1
00:00:00,450 --> 00:00:04,786
Можливість використовувати в Python операції посіву і,

2
00:00:04,786 --> 00:00:09,944
взагалі, гнучкість мови програмування Python/NumPy,

3
00:00:09,944 --> 00:00:14,748
на мою думку, є одночасно перевагою і недолікам мови програмування.

4
00:00:14,748 --> 00:00:18,393
Я думаю, що перевага в тому, що мові надали виразності.

5
00:00:18,393 --> 00:00:22,547
Висока гнучкість мови дозволяє багато чого зробити 
за допомогою лише одного

6
00:00:22,547 --> 00:00:24,165
рядка коду.

7
00:00:24,165 --> 00:00:28,530
Проте, є й недолік, бо посів (а це теж належить до

8
00:00:28,530 --> 00:00:32,610
гнучкості) інколи створює характерні помилки, що

9
00:00:32,610 --> 00:00:36,530
видаються дуже дивними, якщо тобі невідомі тонкощі

10
00:00:36,530 --> 00:00:39,800
роботи посіву чи схожих технік.

11
00:00:39,800 --> 00:00:44,500
Наприклад, якщо взяти вектор-стовпець і вектор-рядок, то

12
00:00:44,500 --> 00:00:48,700
ми очікуватимемо 
помилку співвідношення розмірів або типу, або щось таке.

13
00:00:48,700 --> 00:00:52,620
Але можна отримати і матрицю як результат суми вектора-стовпця і

14
00:00:52,620 --> 00:00:54,030
вектора-рядка.

15
00:00:54,030 --> 00:00:58,370
Проте, у цієї дивної властивості Python є внутрішня логіка.

16
00:00:58,370 --> 00:01:03,370
Але якщо ти не знайомий з Python, то, 
як я бачив у деяких студентів, може

17
00:01:03,370 --> 00:01:05,680
бути дуже важко знайти помилки.

18
00:01:05,680 --> 00:01:09,380
Тож в цьому відео я хочу поділитись кількома хитрощами,

19
00:01:09,380 --> 00:01:12,800
які були дуже корисними для мене і допомогли позбутись,

20
00:01:12,800 --> 00:01:17,320
чи то спростити і позбутись деяких дивних помилок в моєму коді.

21
00:01:17,320 --> 00:01:19,280
Надіюсь, що з цими хитрощами

22
00:01:19,280 --> 00:01:24,193
ти теж зможеш набагато легше писати безпомилковий код Python і NumPy.

23
00:01:25,430 --> 00:01:30,200
Щоб проілюструвати не дуже зрозумілий ефект Python/NumPy,

24
00:01:30,200 --> 00:01:34,990
особливо при побудові векторів в Python/NumPy, 
я зроблю коротку демонстрацію.

25
00:01:34,990 --> 00:01:40,817
Встановимо a=np.random.randn(5).

26
00:01:40,817 --> 00:01:45,699
Це створить 5 випадкових

27
00:01:45,699 --> 00:01:49,640
Гаусівських змінних в масиві a.

28
00:01:49,640 --> 00:01:55,420
Давай виведемо a: ptint(a). Тепер, виявляється, що

29
00:01:55,420 --> 00:02:02,740
shape.a, якщо вивести, матиме структуру (5,).

30
00:02:02,740 --> 00:02:06,320
Це називається масивом 1-ого порядку в Python і

31
00:02:06,320 --> 00:02:09,750
не являється ні вектором-рядком, ні вектором-стовпцем.

32
00:02:09,750 --> 00:02:12,570
І це важко інтуїтивно зрозуміти.

33
00:02:12,570 --> 00:02:17,180
Тож, наприклад, якщо я виведу транспоноване a, 
то воно буде таким же як і a.

34
00:02:17,180 --> 00:02:20,220
Тож a і aᵀ мають однаковий вигляд.

35
00:02:20,220 --> 00:02:25,800
Якщо я виведу скалярний добуток a і aᵀ, то ти, можливо, подумаєш,

36
00:02:25,800 --> 00:02:30,190
що a*aᵀ буде векторним добутком і дасть в результаті матрицю.

37
00:02:30,190 --> 00:02:34,170
Проте, якщо я виведу це, то отримаю число.

38
00:02:34,170 --> 00:02:39,612
Тож я рекомендую при написанні коду нейронної мережі (НМ)

39
00:02:39,612 --> 00:02:46,115
не використовувати структури даних, що є масивами 1-ого порядку.

40
00:02:46,115 --> 00:02:52,134
Натомість, якщо встановити a ось так,

41
00:02:52,134 --> 00:02:58,764
(5, 1), то це обов'язково буде вектором-стовпцем.

42
00:02:58,764 --> 00:03:02,399
І якщо в попередньому випадку a і aᵀ мають однаковий вигляд,

43
00:03:02,399 --> 00:03:06,590
то тепер aᵀ буде вектором-рядком.

44
00:03:06,590 --> 00:03:08,437
Відміть, одну тонку відмінність.

45
00:03:08,437 --> 00:03:12,213
В цій структурі даних ми маємо подвійні квадратні дужки 
коли виводимо aᵀ.

46
00:03:12,213 --> 00:03:14,460
В той час як раніше ми мали одинарні квадратні дужки.

47
00:03:14,460 --> 00:03:19,393
Ось яка між ними різниця. Ось це - справді

48
00:03:19,393 --> 00:03:23,481
матриця 1*5, а це - масив 1-ого порядку.

49
00:03:23,481 --> 00:03:28,129
Якщо ми виведемо добуток a і aᵀ,

50
00:03:28,129 --> 00:03:32,444
то отримаємо векторний добуток, правильно?

51
00:03:32,444 --> 00:03:35,795
Тож, векторний добуток дає нам матрицю.

52
00:03:35,795 --> 00:03:40,305
Давай детальніше розглянемо те, що щойно побачили.

53
00:03:40,305 --> 00:03:43,185
Ось перша команда, яку ми виконали.

54
00:03:43,185 --> 00:03:47,839
Вона створює структуру даних, де

55
00:03:47,839 --> 00:03:52,930
a.shape було оцим дивним "(5,)".

56
00:03:52,930 --> 00:03:57,270
Це називається масивом 1-ого порядку.

57
00:03:57,270 --> 00:03:58,960
Це досить дивна структура даних.

58
00:03:58,960 --> 00:04:04,000
Вона не веде себе ні як вектор-рядок, ні як вектор-стовпець,

59
00:04:04,000 --> 00:04:06,750
тому інколи ми отримуємо незрозумілий результат.

60
00:04:06,750 --> 00:04:10,770
Тому я рекомендую, при виконанні програмувальних

61
00:04:10,770 --> 00:04:14,050
завдань або при реалізації логістичної регресії (ЛР) чи

62
00:04:14,050 --> 00:04:19,740
НМ, не користуватись масивами 1-ого порядку.

63
00:04:21,020 --> 00:04:24,098
Натомість, при створенні масиву,

64
00:04:24,098 --> 00:04:27,500
слід будувати вектор-стовпець

65
00:04:27,500 --> 00:04:32,360
(буде створено вектор 5*1) або слід будувати вектор-рядок.

66
00:04:32,360 --> 00:04:36,670
В такому випадку поведінку вектора буде легше зрозуміти.

67
00:04:36,670 --> 00:04:43,115
Тож в цьому випадку a.shape буде = 5*1

68
00:04:43,115 --> 00:04:48,510
і буде вести себе і, фактично, буде вектором-стовпцем.

69
00:04:48,510 --> 00:04:53,233
Тому можна вважати це матрицею 5*1, 
хоча це й вектор-стовпець.

70
00:04:53,233 --> 00:04:56,880
А тут a.shape буде 1*5

71
00:04:56,880 --> 00:05:01,000
і вести себе буде повністю як вектор-рядок.

72
00:05:02,150 --> 00:05:06,258
Тож коли тобі потрібен вектор, 
я раджу використовувати або цей, або цей, але

73
00:05:06,258 --> 00:05:07,538
не масив 1-ого порядку.

74
00:05:07,538 --> 00:05:12,061
Ще одна річ, яку я використовую в своєму коді, 
це якщо я не впевнений якого

75
00:05:12,061 --> 00:05:17,029
розміру один з моїх векторів, 
то я часто виводжу підтверджувальні команди

76
00:05:17,029 --> 00:05:21,720
такого типу, щоб впевнитись (в цьому випадку), що це - вектор 5*1.

77
00:05:21,720 --> 00:05:23,730
Тож це - вектор-стовпець.

78
00:05:23,730 --> 00:05:26,900
Ці операції досить недорогі для виконання.

79
00:05:26,900 --> 00:05:30,250
Вони також допомагають вести документацію коду.

80
00:05:30,250 --> 00:05:34,160
Тож не соромся вивести підтверджувальні команди (як ось ця), якщо

81
00:05:34,160 --> 00:05:35,320
відчуваєш потребу.

82
00:05:35,320 --> 00:05:39,510
І, нарешті, 
якщо з якихось причин ти отримаєш масив 1-ого порядку,

83
00:05:39,510 --> 00:05:43,960
ти можеш трансформувати його - a.reshape(...) -

84
00:05:43,960 --> 00:05:48,900
в масив 5*1 або 1*5, щоб

85
00:05:48,900 --> 00:05:53,750
змусити його поводитись як вектор-стовпець або вектор-рядок.

86
00:05:53,750 --> 00:05:57,626
Інколи я помічаю як студентам дуже важко знайти помилки,

87
00:05:57,626 --> 00:06:01,119
тому що масиви 1-ого порядку поводяться незрозуміло.

88
00:06:01,119 --> 00:06:06,246
Видаливши масиви 1-ого порядку зі свого коду, 
я вважаю, що він став простішим.

89
00:06:06,246 --> 00:06:09,463
І я ще не помічав щоб це обмежувало якось

90
00:06:09,463 --> 00:06:10,335
можливості мого коду.

91
00:06:10,335 --> 00:06:12,469
Я взагалі ніколи не використовую масиви 1-ого порядку.

92
00:06:12,469 --> 00:06:17,090
Тож, запам'ятай, що щоб спростити код - 
ніколи не використовуй масиви 1-ого порядку.

93
00:06:17,090 --> 00:06:19,437
Завжди використовуй або матриці n*1,

94
00:06:19,437 --> 00:06:24,510
тобто вектори-стовпці, або матриці 1*n, тобто вектори-рядки.

95
00:06:24,510 --> 00:06:26,599
Вільно додавай багато підтверджувальних команд, щоб

96
00:06:26,599 --> 00:06:29,590
перепровірити розміри матриць і масивів.

97
00:06:29,590 --> 00:06:34,480
Також не соромся, викликати операцію reshape(), 
щоб пересвідчитись, що твої

98
00:06:34,480 --> 00:06:38,780
матриці або вектори мають той розмір, який потрібно.

99
00:06:38,780 --> 00:06:39,420
Отже,

100
00:06:39,420 --> 00:06:44,770
надіюсь, ці поради допоможуть тобі видалити причину помилок

101
00:06:44,770 --> 00:06:48,840
з коду Python і дозволять легше впоратись із вправами.