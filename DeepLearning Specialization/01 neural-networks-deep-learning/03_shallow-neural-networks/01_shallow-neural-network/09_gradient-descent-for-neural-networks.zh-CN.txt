我相信这会是一个令人激动的视频 在本期视频中我们将学习 如何在神经网络中 使用一个隐含层实现梯度下降 本视频中 我将写出所有方程 你需要使用这些方程 来实现梯度下降法中 梯度的逆传播 在之后的视频中 我会解释为什么这些方程 是精确的 换句话说 正确的 它们可以用于计算 神经网络中需要用到的梯度 神经网络中需要用到的梯度 现在 你的神经网络 只包含一个隐含层 且有参数 W1 b1 W2 b2 回顾一下 它有nx(即n0)个 输入特征 n1个隐藏单元和n2个输出单元 在我们的例子中 n2=1 那么矩阵W1就是n1*n0的 b1是一个n1维向量 可以视作n1*1矩阵 即一个列向量 W2的维度是n2*n1 b2的维度是n2*1 我们目前只考虑 n2=1的情况 也就是说只有一个隐藏单元 而且在这种神经网络中 我们还有一个损失函数 现在假设我们在做 二分类问题 那么参数整体的损失 就是m分之一倍的 平均损失函数 这里的L表示 当模型预测为y帽(即a2) 但真实标签为y时的损失 而且如果做二分类 损失函数可以 与逻辑回归完全一致 所以为了训练算法的参数 我们需要采用梯度下降法 当我们训练神经网络时 初始化参数 随机在全0附近十分重要   我们之后再讨论其中的原因 初始化完参数后 梯度下降的每一次循环 都要对样本做预测 所以我们计算y帽i i取从1到m 之后需要计算导数 计算dW1 也就是 损失函数 对W1求导数 我们还需计算另一个参数 db1 也就是 损失函数 对b1求导 亦称为求斜率 依此类推 同样对W2和b2求导 最后梯度下降的更新就是 W1更新为W1减去𝛼 即学习率 乘上dW1 b1更新为b1减去学习率乘db1 类似地还要更新W2和b2 有时我写"冒号等号" 有时我还写"等号" 两种写法都可以 这就是梯度下降的单次循环 然后重复这个循环很多遍 直到参数看似收敛了 在之前的视频中 我们讨论了如何计算预测值 即如何计算输出 我们还介绍了如何向量化 所以关键只需了解 如何计算这些 偏导数dW1 db1 以及偏导数dW2 db2 我希望直接给你们 计算这些导数的方程 我将在下一个视频中 那是个选修视频 深入介绍我们如何推导 这些公式 那么我们总结一下 用于传播的公式 我们有Z1=W1X+b1 A1等于那一层的激励函数 作用于Z1的每一个元素 然后Z2=W2A1+B2 最后 这些都是 对训练集做了向量化的 A2=g2(Z2) 我们假定在做二分类 那么激励函数 应当就是sigmoid函数 所以我就直接写在这儿 所以这些就是前向传播 也就是神经网络 从左向右进行前向计算 我们来计算导数 也就是逆向传播步骤 dZ2等于A2减去真实标签Y 我再提醒一下 本例中 我们做了向量化 所以矩阵Y是这个1*m矩阵 其中水平拼接了所有的m个样例 所以dW2就等于这个公式 其实这里的前三个公式 与逻辑回归的梯度下降十分类似 与逻辑回归的梯度下降十分类似 axis=1, keepdims=True 这里我说一个小细节 这个np.sum是一个Python numpy指令 它作用于矩阵的某一维度 在这里是水平方向求和 而这里的keepdims是用于 防止输出奇怪的 一阶数组 也就是说 数组的维度会是(n,) 所以设定keepdims=True 我们可以保证Python的db2输出为(n,1)维 严格地说这里应写作 n2*1 而这里则是一个 1*1的数 可能现在看来无所谓 但我们之后就会解释这里很重要 到此为止我们做的和逻辑回归很像 但是当你继续计算 梯度逆传播的时候 你需计算这个 [读公式] 所以这里的g1'就是 你隐含层所使用的 激励函数的导数 对于输出层 我假定你在做 二分类问题 用的是sigmoid函数 我已经把它代入了 得到这里的dZ2公式 而这个乘号是指每个元素对应相乘 所以这里应当是n1*m的矩阵 而这里是对每一个元素 代入求导 所以同样也是 n1*m的矩阵 所以这里的乘号指矩阵对应元素相乘 最后dW1就等于这个 而db1就等于这个 [读公式] 所以尽管之前 这里的keepdims可能不重要 因为n2=1 这里只是个1*1矩阵 是个实数 这里db1是n1*1向量 所以我们希望Python的 np.sum输出这种维度 而不是一个奇怪的 如此处所示维度的矩阵 那会导致之后的计算很混乱 另一种方法就是 你无需保留这些参数 但需要显式地调用一个reshape函数 来把np.sum的输出转变为 你希望的db的维度 所以这些就是前向传播的 四个方程 以及逆向传播的 六个方程 我直接写出了这些方程 但在下一个选修视频中 我们将回顾 逆向传播算法的六个方程 直觉上是如何推导的 请自己决定是否观看 但是无论如何 只要你实现我写的算法 你就能实现正确的前向和逆向传播 而且你将能够计算 梯度下降法所需要的导数 从而学出你的神经网络参数 你同样可以实现这个算法并使其生效 你同样可以实现这个算法并使其生效 即使你没有深入理解 背后的代数计算 许多成功的深度学习实践者就这么做的 但如果你想理解 你可以看下一个视频 从中学习这些方程导数 的推导方法 的推导方法