여러분이 broadcasting operations사용하게 할 수 있게 해주는 파이썬의 능력과 그그리고 더 일반적으로, 파이썬 넘파이 프로그램 언어의
큰 유동성은, 프로그램 언어에서 장점과 동시에 단점이 
동시 있습니다. 이것이 강점인 이유는 언어의 표현 성을 생성하기 때문이죠. 언어의 유동성은 여러분이 단순히 한 줄의 코드로도 많은 것을 해낼 수 있게 해줍니다. 그렇지만, broadcasting에서 약점도 있는데요, 이런 큰 유동성 때문에, 
아주 감지하기 힘든 버그나 또는 매우 이상하게 생긴 버그를 들여올 수 있습니다. 만약 broadcasting의 복잡한 구조와 
특성에 대해서 익숙하지 않으면 말이죠. 예를 들어, 세로줄 벡터를 가져서 
가로줄 벡터에 더하면, 다이멘션의 불일치가 생기거나 
오류가 생길 것으로 예상할 텐데요, 반면에 가로벡터와 세로벡터의 함을 통해 매트릭스 값이 나올 수도 있겠죠. 이러한 특이한 파이썬의 특성에는 그에 상응하는 내부 로직이 있는데요. 만약 파이썬에 익숙지 않은 경우, 
저는 몇몇의 학생들이 정말 이상하거나, 매우 찾기 힘든 버그들을 갖는 것을
직접 보았습니다. 그러므로 이 비디오에서는 
몇 가지 팁을 공유하고, 저희 코드에 있는 이상하게 생긴 버그를 제거하거나 심플하게 만드는 비법을 공개하겠습니다. 그리고 이러한 팀과 비법을 통해서 여러분이 버그로부터 자유로운 
파이썬 그리고 넘파이 코드를 만들 수 있을 것입니다. 파이썬-넘파이의 조금 덜 직관적인 효과를 보여드리자면, 특히, 벡터를 파이썬-넘파이에서 만드는 방법에 대해서 말이죠. 
빠른 데모를 보여드리죠. a를 np.random.randn(5)로 설정하겠습니다. 이것은 그러면 임의로 5개으 Gaussian 변수를 만들어 주는데요 이 값들은 array a에 보관됩니다. 이제 print(a)를 해보죠, a의 shape은 이렇게 하면, 
5개의 콤마구조를 갖습니다. 파이썬에서 이것은 랭크 1 array라고 하는데요, 이것은 row 벡터도 아니고 
column 벡터도 아닙니다. 이런 것이 조금 더 직관적이지 않은 부분으로 이어지는데요, 예를 들거, 제가 만약 a transpose 를
print 하면, 이것은 a와 동일하게 보입니다. 그러면 a와 a transpose는 똑같이 보이고 있죠. 그리고 만약 제가 a와 a transpose의 
안쪽 프로덕트들을 프린트하면, 여기서 a 곱하기 a transpose는 밖았쪽 프로덕트라고 생각할 수도 있는데요, 
매트릭스를 줄 수도 있다고 생각할 수 있는데요, 그러나 이렇게 하면, 
대신에 이러한 숫자 값을 갖게 됩니다. 그러므로 제가 추천 드리는 것은, 
만약 여러분이 신경망을 코딩 하는 경우에는, 데이터구조를 사용하는 것이 아니라, 
모양이 5 콤마나, n 콤마나, rank 1 array등과 같은 것이 아니라, 이렇게 a를 np.random.randn(5, 1)로 지정해서 그러면 a가 5, 1 세로 벡터가 되게끔 해주는데요, 이전에는 a 와 a transpose가 똑같이 생겼었지만, 이제는 a transpose를 print하면, 
a transpose는 row vector죠, 이제 작은 차이를 보겠습니다. 여기 데이터 구조를 보시면, 
2개의 대괄호가 있습니다. a transpose를 프린트하는 
경우에 말이죠. 이전에는 1개의 대괄호가 있었죠. 이것이 바로 여기 1 x 5 매트릭스와 여기 rank 1 array중의 하나와의 차이입니다. 그리고 만약 여러분이 
a 와 a transpose의 프로덕트를 프린트하면, 이것은 그러면 벡터의 밖았쪽 프로덕트를 줍니다. 맞죠? 그래서 벡터의 밖았쪽 프로덕트들이 
매트릭스를 만드는 것이죠. 여기서 본 것에 대해 조금 더 자세히 다루겠습니다 방금 명령한 것은, 이거 였습니다. 이것은 a.shape라는 데이터 구조를 만들었고요, 이것은 조금 우습게 생긴 (5, ) 라는 것을 주었습니다. 이것은 rank 1 array라고 부릅니다. 아주 우스운 모양의 데이터 구조인데요 이것은 row vector 나 column vector와 같이 
균일하게 행동하지 않습니다. 그렇기 때문에 이 특성이 직관적이지 않은 것이죠. 그러므로 제가 여러분에게 추천 드리는 것은 
프로그래밍 연습 과제를 할 때, 아니면 로지스틱 회귀분석을 도입할 때, 또는 이런 rank 1 array를 이용하지 말라는 것입니다. 대신에, array를 생성할 때마다, 여기와 같이 세로줄 벡터를 만듭니다. 그러면 (5, 1) 벡터가 생성되는데요, 
또는 row vector를 만듭니다. 그렇게 되면 여러분의 벡터는 
이해하기 쉽게 행동할 것입니다. 이 경우, a.shape는 5, 1이 될 것입니다. 이것은 column vector와 같이 행동할 텐데요, 
사실 이것이 column vector입니다. 그리고, 그렇기 때문에 이것을 
(5, 1) 매트릭스로 생각할 수 있는 것입니다.
이것은 column vector이기도 하죠. 그리고 여기서는 a.shape가 1, 5일 것입니다. 이것은 일관되게 row vector처럼 행동할 것입니다. 그러므로 여러분이 벡터가 필요한 경우, 
이것이나 이것을 이용하길 권장 드립니다. rank 1 array는 말고 말이죠. 또 한가지 제가 제 코드에서 많이 할 것은 벡터의 다이멘션이 정확히 무엇인지 모르는 경우, 
assertion 문구를 이렇게 넣어서, 이 경우, (5, 1) 벡터가 되도록 말이죠. column 벡터 말이죠. 이런 assertion은 실행을 목적으로 하는데요 코드를 기록화하는 역할도 있습니다. 그러므로 이렇게 assertion 문구를 넣고 싶을 때, 주저하지 마시고 넣으십시오. 마지막으로, 어떤 이유에서든, 
rank 1 array를 갖게 되면, 이것을 다시 만들 수 있는데요, a=a.reshape ( (5, 1))처럼 말이죠, 또는 (1, 5) array로 변형해서 column vector 또는 row vector와 조금 더 맞게 
행동할 수 있도록 해줄 수 있습니다. 저는 그래서 가끔식 학생들이 아주 타자내기 어려운 버그를 갖게 되는 경우를 봤는데요, 
그 이유는 이러한 rank 1 array에 직관적이지 않은 부분 때문입니다. 이전 코드에서 rank 1 array를 제거함을 써, 
저의 코드는 더욱 간소화됐습니다. 그리고 코드를 표현하는데 딱히 제한을 느끼거나 그러지는 않았습니다. 저는 그냥 절대로 rank 1 array를 사용하지 않습니다. 그러면 코드를 심플하게 만들려면 
rank 1 array들을 사용하지 말라는 게 이번 강의의 주요 포인트입니다. 항상 n x 1 매트릭스를 이용하고, 즉 column vector 또는 1xn 매트릭스를 이용, 즉
row vector를 이용합니다. 그리고 assertion 문구는 언제든지 사용해도 좋으며, 여러분의 매트릭스의 다이멘션 이나 array는
더블체크하십시요. 그리고 reshape operation을 부르는 것을 
두려워하지 마십시요. 매트릭스 또는 벡터의 다이멘션이 
원하는 형을 갖추도록 말이죠. 그럼 이 내용이, 이러한 제안들이 여러분의 버그 원인들을 파이썬에서 알아내고 없애는데 도움이 됐으면 합니다. 
그리고 연습문제로 더 쉽게 풀 수 있기를 희망합니다.