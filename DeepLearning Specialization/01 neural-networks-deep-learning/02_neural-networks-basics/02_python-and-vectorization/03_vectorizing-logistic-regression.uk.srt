1
00:00:00,860 --> 00:00:05,760
Ми поговорили 
як векторизація дає змогу значно пришвидшити код.

2
00:00:05,760 --> 00:00:08,160
В цьому відео ми поговоримо як можна векторизувати

3
00:00:08,160 --> 00:00:10,545
реалізацію логістичної регресії (ЛР).

4
00:00:10,545 --> 00:00:12,960
Тож ти зможеш обробити весь тренувальний набір,

5
00:00:12,960 --> 00:00:15,930
тобто застосувати одну ітерацію Градієнтного спуску для

6
00:00:15,930 --> 00:00:22,330
всього тренувального набору, 
не використовуючи жодного явного циклу for.

7
00:00:22,330 --> 00:00:24,039
Я дуже захоплююсь цією методикою.

8
00:00:24,039 --> 00:00:26,670
І пізніше ми поговоримо про нейронні мережі (НМ)

9
00:00:26,670 --> 00:00:30,050
без використання жодного явного циклу for.

10
00:00:30,050 --> 00:00:35,965
Давай почнемо. Давай спочатку розглянемо кроки прямого поширення ЛР.

11
00:00:35,965 --> 00:00:37,860
Тож, якщо ми маємо m тренувальних зразків,

12
00:00:37,860 --> 00:00:40,605
то щоб зробити передбачення для першого зразка

13
00:00:40,605 --> 00:00:42,105
нам потрібно обчислити ось це.

14
00:00:42,105 --> 00:00:45,480
Обчислити z, використовуючи цю знайому вже формулу.

15
00:00:45,480 --> 00:00:47,370
Потім обчислити активатори,

16
00:00:47,370 --> 00:00:49,485
обчислити ŷ першого зразка.

17
00:00:49,485 --> 00:00:52,705
Потім, щоб зробити передбачення для другого тренувального зразка,

18
00:00:52,705 --> 00:00:54,405
потрібно обчислити ось це.

19
00:00:54,405 --> 00:00:57,085
Потім, щоб зробити передбачення для третього зразка,

20
00:00:57,085 --> 00:00:59,045
потрібно обчислити ось це і т.д.

21
00:00:59,045 --> 00:01:01,020
І це потрібно зробити m разів,

22
00:01:01,020 --> 00:01:03,855
якщо ми маємо m тренувальних зразків.

23
00:01:03,855 --> 00:01:08,250
А, виявляється, що щоб реалізувати кроки прямого поширення,

24
00:01:08,250 --> 00:01:13,435
які обчислюють передбачення для наших m тренувальних зразків,

25
00:01:13,435 --> 00:01:14,865
є спосіб, що дозволяє це зробити

26
00:01:14,865 --> 00:01:17,925
без використання явного циклу for.

27
00:01:17,925 --> 00:01:20,450
Давай подивимось як це зробити.

28
00:01:20,450 --> 00:01:26,455
Спочатку, згадаймо, що ми визначили матрицю 
вхідних тренувальних даних і позначили її великою буквою X.

29
00:01:26,455 --> 00:01:30,895
Ці дані розміщені ось так в окремих стовпцях.

30
00:01:30,895 --> 00:01:33,810
Тож це - матриця

31
00:01:33,810 --> 00:01:38,425
розміру (nₓ, m).

32
00:01:38,425 --> 00:01:41,885
Я записав розмір як в Python NumPy.

33
00:01:41,885 --> 00:01:50,350
Це позначає те саме - матрицю розміру nₓ*m.

34
00:01:50,350 --> 00:01:54,670
Тепер, спочатку ми покажемо як можна обчислити z⁽¹⁾, z⁽²⁾,

35
00:01:54,670 --> 00:01:56,512
z⁽³⁾ і т.д.

36
00:01:56,512 --> 00:01:58,665
в одному кроці.

37
00:01:58,665 --> 00:02:01,195
Фактично, одним рядком коду.

38
00:02:01,195 --> 00:02:06,930
Тож я побудую

39
00:02:06,930 --> 00:02:13,100
матрицю розміру 1*m, що насправді є вектором, 
в якому я обчислюватиму z⁽¹⁾,

40
00:02:13,100 --> 00:02:15,405
z⁽²⁾ і т.д.

41
00:02:15,405 --> 00:02:18,480
до z⁽ᵐ⁾ одночасно.

42
00:02:18,480 --> 00:02:22,175
Виявляється, що це можна записати як

43
00:02:22,175 --> 00:02:29,225
wᵀ [транспоноване], велика X + ось такий вектор:

44
00:02:29,225 --> 00:02:31,040
b, b, b і т.д.,

45
00:02:31,040 --> 00:02:33,315
де ось це,

46
00:02:33,315 --> 00:02:34,480
ось це b-b-b-b-b,

47
00:02:34,480 --> 00:02:38,980
є вектором розміру 1*m або

48
00:02:38,980 --> 00:02:46,725
матрицею 1*m, точніше m-розмірним вектором-рядком.

49
00:02:46,725 --> 00:02:50,495
Залежно від того наскільки ти обізнаний/а з множенням матриць,

50
00:02:50,495 --> 00:02:56,300
ти можеш побачити, що wᵀ, x⁽¹⁾,

51
00:02:56,300 --> 00:02:58,760
x⁽²⁾ і т.д.

52
00:02:58,760 --> 00:03:05,755
до x⁽ᵐ⁾... wᵀ може бути вектором-рядком.

53
00:03:05,755 --> 00:03:10,655
Тож wᵀ буде ось таким вектором-рядком.

54
00:03:10,655 --> 00:03:18,614
І, отже, цей перший вираз буде обчислюватись як wᵀx⁽¹⁾,

55
00:03:18,614 --> 00:03:22,970
wᵀx⁽²⁾ і т.д.

56
00:03:22,970 --> 00:03:29,840
крапка-крапка-крапка, wᵀx⁽ᵐ⁾. І тепер ми додаємо другий вираз -

57
00:03:29,840 --> 00:03:30,960
b-b-b і т.д. -

58
00:03:30,960 --> 00:03:33,565
додаємо b до кожного елементу.

59
00:03:33,565 --> 00:03:37,650
Тож, в результаті отримуємо інший вектор розміру 1*m.

60
00:03:37,650 --> 00:03:38,955
Ось це - перший елемент,

61
00:03:38,955 --> 00:03:40,590
ось це - другий елемент і т.д.,

62
00:03:40,590 --> 00:03:42,810
а це - m-ий елемент.

63
00:03:42,810 --> 00:03:45,605
І якщо ми глянемо на визначення вгорі,

64
00:03:45,605 --> 00:03:51,250
то цей перший елемент - це точне визначення z⁽¹⁾,

65
00:03:51,250 --> 00:03:57,305
другий елемент - точне визначення z⁽²⁾ і т.д.

66
00:03:57,305 --> 00:04:00,035
Тож, аналогічно, як було отримано X,

67
00:04:00,035 --> 00:04:02,870
коли ми брали тренувальні зразки і

68
00:04:02,870 --> 00:04:07,400
складали їх один до одного горизонтально,

69
00:04:07,400 --> 00:04:11,069
я визначу отак велике Z.

70
00:04:11,069 --> 00:04:16,385
Ми візьмемо малі z і складемо їх горизонтально.

71
00:04:16,385 --> 00:04:21,080
Тож, складаючи малі x, що відповідають окремим тренувальним зразкам

72
00:04:21,080 --> 00:04:24,350
горизонтально, ми отримуємо велике X.

73
00:04:24,350 --> 00:04:27,420
І, аналогічно, ми беремо ці малі змінні z

74
00:04:27,420 --> 00:04:28,805
і складаємо їх горизонтально,

75
00:04:28,805 --> 00:04:34,050
щоб отримати змінну, яку ми позначаємо великим Z.

76
00:04:34,050 --> 00:04:37,400
І виявляється, що це можна реалізувати

77
00:04:37,400 --> 00:04:45,773
командою NumPy: "Z=np.dot(w.T,"

78
00:04:45,773 --> 00:04:51,095
(що позначає транспоноване w) і далі "X)+b".

79
00:04:51,095 --> 00:04:53,645
В Python є деякі тонкощі. Одна з них

80
00:04:53,645 --> 00:04:59,405
це те, що b - дійсне число або ж матриця розміру 1*1,

81
00:04:59,405 --> 00:05:01,330
що і є дійсним числом.

82
00:05:01,330 --> 00:05:06,230
Проте, якщо додавати цей вектор до цього дійсного числа,

83
00:05:06,230 --> 00:05:13,235
Python автоматично бере це дійсне число b і 
розширює його до вектора-рядка розміру 1*m.

84
00:05:13,235 --> 00:05:16,490
Тож, якщо ця операція виглядає дещо таємниче

85
00:05:16,490 --> 00:05:20,120
(це називається посівом [broadcasting] в Python),

86
00:05:20,120 --> 00:05:22,210
то тобі не треба поки цим перейматись,

87
00:05:22,210 --> 00:05:25,760
ми поговоримо про це більше в наступному відео.

88
00:05:25,760 --> 00:05:29,180
Потрібно запам'ятати, що лише одним рядком коду, 
ось цим рядком,

89
00:05:29,180 --> 00:05:33,290
ми можемо обчислити велике Z, а велике Z

90
00:05:33,290 --> 00:05:37,698
буде матрицею розміру 1*m, яка містить малі z

91
00:05:37,698 --> 00:05:41,200
(від маленького z⁽¹⁾ до маленького z⁽ᵐ⁾).

92
00:05:41,200 --> 00:05:46,255
Тож це було Z. Що ж відносно оцих значень A?

93
00:05:46,255 --> 00:05:48,260
Далі ми спробуємо

94
00:05:48,260 --> 00:05:52,685
знайти спосіб обчислення a⁽¹⁾,

95
00:05:52,685 --> 00:05:57,220
a⁽²⁾ і т.д. до a⁽ᵐ⁾

96
00:05:57,220 --> 00:05:58,700
одночасно.

97
00:05:58,700 --> 00:06:03,350
Тож, аналогічно, як ми складали малі x в результуюче

98
00:06:03,350 --> 00:06:08,870
велике X і як складали (горизонтально) малі z в результуюче велике Z,

99
00:06:08,870 --> 00:06:10,810
складаючи малі A,

100
00:06:10,810 --> 00:06:12,470
ми повинні отримати нову змінну,

101
00:06:12,470 --> 00:06:15,200
яка буде визначена як велике A.

102
00:06:15,200 --> 00:06:18,075
В програмувальному завданні

103
00:06:18,075 --> 00:06:22,790
ти побачиш як реалізувати векторизовану сигмоїду так,

104
00:06:22,790 --> 00:06:24,480
щоб ця сигмоїда

105
00:06:24,480 --> 00:06:32,380
прийняла на вхід це велике Z і дуже швидко віддала велике A.

106
00:06:32,380 --> 00:06:36,620
Тож ти побачиш це детально в програмувальному завданні.

107
00:06:36,620 --> 00:06:38,110
Тож резюмуємо.

108
00:06:38,110 --> 00:06:42,655
На цьому слайді ми побачили, що замість проходження циклу

109
00:06:42,655 --> 00:06:47,515
по m тренувальних зразках, щоб обчислити малі z і малі a

110
00:06:47,515 --> 00:06:52,090
по черзі, ми можемо записати це ось цим одним рядком коду,

111
00:06:52,090 --> 00:06:54,290
щоб обчислити всі z одночасно.

112
00:06:54,290 --> 00:06:57,100
А потім ось цим рядком коду

113
00:06:57,100 --> 00:06:59,260
правильно використати

114
00:06:59,260 --> 00:07:04,115
малу σ, щоб обчислити всі малі a одночасно.

115
00:07:04,115 --> 00:07:05,965
Отже, ось так реалізується

116
00:07:05,965 --> 00:07:07,948
векторизована версія

117
00:07:07,948 --> 00:07:11,560
прямого поширення для всіх m тренувальних зразків одночасно.

118
00:07:11,560 --> 00:07:13,985
Тож підіб'ємо підсумки. Ти щойно побачив/ла як можна використати

119
00:07:13,985 --> 00:07:18,100
векторизацію, щоб дуже ефективно обчислити всі активатори

120
00:07:18,100 --> 00:07:21,700
(всі малі a) одночасно.

121
00:07:21,700 --> 00:07:24,860
Далі, виявляється, можна також використати векторизацію,

122
00:07:24,860 --> 00:07:27,910
щоб дуже ефективно обчислити зворотне поширення,

123
00:07:27,910 --> 00:07:29,650
обчислити градієнти.

124
00:07:29,650 --> 00:07:32,000
Давай подивимось як це зробити в наступному відео.