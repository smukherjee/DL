vectorization이 여러분의 코드 속도를 어떻게 높힐 수 있는지 이야기 했었는데요, 이번 비디오에서는 로지스틱 회귀분석 도입을 어떻게 vectorize 할 수 있는지 이야기 해보겠습니다. 전체 트레이닝 세트를 처리할 수 있게 말이죠. 기울기 강하의 single iteration을 도입하는 것이죠 전체 트레이닝 세트에 대해서, for loop의 사용없이 말이죠. 이 기술이 매우 기대됩니다. 나중에 신경망에서 이야기할텐데요, 하나의 for loop를 이용해서 말이죠. 시작해보겠습니다. 로지스틱 회귀분석의 전 방향전파 단계를 먼저 보겠습니다. m 트레이닝 예시가 있는 경우, 첫번째 예시에 대해 예측하자면, 이것을 산출해야하는데요, z를 산출합니다. 여기 이 익숙한 공식을 써서 말이죠. 그리고 activation을 계산하고, 첫번째 예시의 ŷ 을 계산하고, 두번째 트레이닝 예시에 대해 예측값을 구하고, 이것을 계산해야되죠, 그 다음에 세번째 예시에 대해 예측값을 구합니다. 그리고 이 값을 계산해야죠, 등등. 이것을 m번 진행해야 할텐데요, 여러분이 m 트레이닝 예시가 있는 경우 말이죠. 여러분이 전 방향전파 단계를 실행하기 위해서는, m 트레이닝 예시에 대해서 예측값을 산출해야 합니다. 진행하는 방법이 있는데요 explicit for loop 없이도 말이죠. 어떻게 하는지 보겠습니다. 첫번째로, 대문자 X 매트릭스를 트레이닝 입력값으로 정의했었는데요, 이 값들을 줄별로 쌓았었습니다. 이것은 매트릭스인데요, 이것은 (nx, m) 매트릭스입니다. 이것은 파이썬 넘파이 모양으로 적고 있습니다. 이것은 x가 nx, m 다이멘션의 매트릭스라는 것입니다. 첫번째로 제가 하고 싶은 것은 z1, z2, z3를 어떻게 계산하는지 보여주는 것입니다. 한번에 말이죠. 그것도 한줄의 코드로 말이죠. 저는 1 x m 매트릭스는 만들건데요, 이것은 가로 벡터인데요, z1, z2 등등을 계산할 것입니다. zm 까지 말이죠, 한번에 계산합니다. 이것은 w transpose 대문자 X 매트릭스 더하기 벡터 b, b등으로 표현할 수 있습니다. b는, 이것은 즉, 여기 b, b, b, b, 는 1 x m 벡터입니다. 또는 1 x m 매트릭스입니다. 또는 m차원의 가로 벡터이기도 하죠. 여러분이 얼마나 매트릭스 곱셈에 익숙한지에 따라서, w transpose x1, x2 등등 xm 까지 w transpose 가 가로 벡터인 것을 확인할 수 있을 것입니다. 그러면 여기 w transpose는 이와 같이 행 벡터가 될텐데요, 그리고 여기 첫번째 항은 w transpose x1, w transpose x2, 그리고 등등... w tanspose xm 으로 계산될 것입니다. 그 다름에, 
여기 두번째b항을 더합니다. b, b, b등등 과 같이 말이죠. 그리하여, 각각의 element에 b를 더하게 되는 것이죠. 그렇게 하면 또 하나의 1 x m 벡터가 남게되는데요, 이것은 첫번째 element이고 이것이 두번째 element이고, 이것은 n번째 element 입니다. 그리고 여기 정의를 보면, 첫번째 element는 정확히 Z1의 정의입니다. 그리고 두번째 element는 정확히 Z2의 정의이구요, 그러면 X값을 얻은 것과 같이, 여러분의 트레이닝 예시 를 가지고 쌓아올린 것 처럼, 가로로 쌓은 거처럼 말이죠. 여기 대문자 Z를 정의할텐데요, 소문자 z들을 가지고 가로로 쌓아올리는 것입니다. 그리고 다른 트레이닝 예시에 대해서 소문자 x를 쌓는 경우, 가로로 쌓으면 이런 대문자 X 변수를 갖게되는데요, 여기 소문자 z 변수를 가지고 가로로 쌓는 것과 같이 말이죠. 여기 대문자 Z로 표현한 변수를 갖게 됩니다. 이것을 도입하기 위해서는 넘파이 명령은 대문자 Z = np 점 w 점 T입니다. 이것은 w transpose x 그리고 더하기 b 입니다. 파이썬에서는 미묘한 부분이 있는데요, 여기서 b는 실수를 나타내는데요, 만약 1 x 1 매트릭스인 경우, 그냥 실수를 나타냅니다. 하지만 여기 벡터에 더하는 경우엔 파이썬은 자동으로 이 b라는 실수를 가지고 여기 1 X m 줄 벡터에 확장시킵니다. 이 운영이 조금 이해하기 힘든 경우엔, 이것은 파이썬에서 broadcasting이라고 합니다. 아직은 걱정 안하셔도 됩니다. 나중에 비디오 강의에서 이야기하겠습니다. 이해하셔야 할 부분은, 한줄의 코드로, 여기 있는 코드로, 대문자 Z를 계산하고, 이 값은 1Xm 매트릭스인데요, 모든 소문자 z의 값을 내포하고 있습니다. 소문자 z1에서 zm 까지 말이죠. 이것이 z에 대한 내용이였는데요, 그럼 a는 어떨까요. 다음으로는, a1을 계산하는 방법을 보겠습니다. a2도 보고, am까지 알아보겠습니다. 모두 한번에 말이죠. 그리고 소문자 x들을 쌓아서 나온 대문자 X처럼, 소문자 z를 가로로 쌓아서 대문자 Z가 나왔는데요, 소문자 a를 쌓는 경우에는, 새로운 변수가 결과값으로 나올 것입니다. 새로운 변수가 결과값으로 나올 것입니다. 프로그램 연습 과제에서, vector valued sigmoid 함수를 도입하는 방법을 보겠습니다. 그러면 여기 시그모이드 함수는 대문자 Z를 변수로 입력하고, 효율적으로 대문자 A값을 산출하게 됩니다. 이것에 대한 상세내용은 프로그램 과제에서 볼 것입니다. 복습하자면, 이번 슬라이드에서 본 것은, 소문자 z와 소문자a를 계산하는데
m 트레이닝 샘플에 대해서 하나하나씩 loop over할 필요없이, 이것과 같은 한줄의 코드를 도입하면 된다는 것입니다. 모든 z의 값들을 한번에 산출하기 위해서 말이죠. 그런 다음, 이런 한줄의 코드는 소문자 시그마의 적합한 도입을 통해 소문자 a를 모두 한꺼번에 산출할 수 있도록 해줍니다. 이렇게 하여 m 개의 트레이닝 예시에 대한 전 방향전파 에서의 vectorized 된 도입을 한꺼번에 하는 방법을 알아봤습니다. 요약하자면, 방금 본 것은 vectorization을 사용하여 효율적으로 모든 activation을 산출하는 방법을 알아냈습니다. 즉, 소문자 a를 한번에 계산하는 방법을 말이죠. 다음으로는, vectorization을 사용해서 후 방향전파 효율적으로 산출하는 방법을 알아보겠습니다. 기울기를 계산하기 위해서 말이죠. 이것을 어떻게 하는지 다음 비디오에서 보겠습니다.