1
00:00:00,000 --> 00:00:03,195
З поверненням! Векторизація, по суті, -

2
00:00:03,195 --> 00:00:07,315
це мистецтво позбутись від явних циклів for в коді.

3
00:00:07,315 --> 00:00:11,835
В еру глибокого навчання (ГН) і, зокрема, в практиці ГН

4
00:00:11,835 --> 00:00:15,210
ми часто змушені тренувати відносно великі набори даних,

5
00:00:15,210 --> 00:00:18,475
тому що ГН найкраще себе в цьому проявляє.

6
00:00:18,475 --> 00:00:22,790
Тож, дуже важливо, щоб наш код був швидким. Інакше,

7
00:00:22,790 --> 00:00:24,525
якщо він обробляє великий набір даних,

8
00:00:24,525 --> 00:00:27,000
він буде виконуватись дуже довго і ми будемо змушені

9
00:00:27,000 --> 00:00:30,255
просто довго чекати поки отримаємо результат.

10
00:00:30,255 --> 00:00:32,035
Тож в еру ГН,

11
00:00:32,035 --> 00:00:37,490
думаю, уміння застосовувати векторизацію стало ключовою навичкою.

12
00:00:37,490 --> 00:00:40,010
Давай почнемо з прикладу.

13
00:00:40,010 --> 00:00:42,225
Що ж таке векторизація?

14
00:00:42,225 --> 00:00:48,780
Для логістичної регресії (ЛР) нам треба було обчислити z=w.T*x+b,

15
00:00:48,780 --> 00:00:55,405
де w - ось цей стовпчиковий вектор, а x - ось цей вектор.

16
00:00:55,405 --> 00:00:58,000
Вони можуть бути дуже великими векторами, якщо у тебе є багато ознак.

17
00:00:58,000 --> 00:01:07,080
Отже, w та x були отакими векторами R 
(множина дійсних чисел) розміром n або nₓ.

18
00:01:07,080 --> 00:01:10,170
Тож, щоб обчислити w транспоноване і помножене на x

19
00:01:10,170 --> 00:01:15,660
невекторизованим способом,

20
00:01:15,660 --> 00:01:18,725
ми мали зробити щось таке: z=0;

21
00:01:18,725 --> 00:01:24,860
далі for i in range(n_x)

22
00:01:24,860 --> 00:01:27,330
для i = 1,2..n_x;

23
00:01:27,330 --> 00:01:34,040
z+=w[i]*x[i];

24
00:01:34,040 --> 00:01:37,100
і далі, вкінці, щось типу z+=b.

25
00:01:37,100 --> 00:01:39,855
Тож це - невекторизований спосіб.

26
00:01:39,855 --> 00:01:43,090
Далі ми помічаємо, що це виконується досить повільно.

27
00:01:43,090 --> 00:01:48,560
На противагу йому, векторизований спосіб безпосередньо обчислює wᵀx.

28
00:01:48,560 --> 00:01:52,085
В Python, або numpy,

29
00:01:52,085 --> 00:02:01,428
ми можемо використати команду z=np.dot(w, x),

30
00:02:01,428 --> 00:02:06,270
яка обчислить wᵀx.

31
00:02:06,270 --> 00:02:09,075
І ми також можемо просто безпосередньо додати b.

32
00:02:09,075 --> 00:02:12,400
Ти помітиш, що це набагато швидше.

33
00:02:12,400 --> 00:02:17,075
Давай проведемо невеличку демонстрацію.

34
00:02:17,075 --> 00:02:21,960
Отже, ось мій записник Jupyter, в якому я збираюсь написати трохи Python коду.

35
00:02:21,960 --> 00:02:28,041
Тож, спочатку, я імпортую бібліотеку numpy:

36
00:02:28,041 --> 00:02:30,000
import numpy as np. І, для прикладу,

37
00:02:30,000 --> 00:02:36,570
я можу створити масив a ось так.

38
00:02:36,570 --> 00:02:39,560
Давай виведемо a.

39
00:02:39,560 --> 00:02:41,160
Тепер, коли цей шматок коду написано,

40
00:02:41,160 --> 00:02:43,170
якщо я натисну Shift+Enter,

41
00:02:43,170 --> 00:02:44,847
Jupiter виконає цей код.

42
00:02:44,847 --> 00:02:47,970
Тож він створив масив a і вивів його.

43
00:02:47,970 --> 00:02:50,580
Тепер давай продемонструємо векторизацію.

44
00:02:50,580 --> 00:02:51,990
Я імпортую бібліотеку time.

45
00:02:51,990 --> 00:02:53,580
оскільки вона необхідна

46
00:02:53,580 --> 00:02:56,565
для обчислення скільки часу займають операції.

47
00:02:56,565 --> 00:02:59,139
Далі можу створити масив a,

48
00:02:59,139 --> 00:03:02,905
що =np.random.rand(1000000).

49
00:03:02,905 --> 00:03:10,065
Це створить масив випадкових чисел розміром 1 000 000.

50
00:03:10,065 --> 00:03:13,300
b=np.random.rand(1000000).

51
00:03:13,300 --> 00:03:16,120
Ще один масив розміром 1 000 000.

52
00:03:16,120 --> 00:03:20,810
Тепер tic=time.time(), що повертає поточний час.

53
00:03:20,810 --> 00:03:26,395
c=np.dot(a,b).

54
00:03:26,395 --> 00:03:28,649
toc=time.time().

55
00:03:28,649 --> 00:03:31,950
І print().

56
00:03:31,950 --> 00:03:34,857
Це - векторизований спосіб.

57
00:03:34,857 --> 00:03:37,685
Vectorized version:

58
00:03:37,685 --> 00:03:41,985
І, давай виведемо це.

59
00:03:41,985 --> 00:03:45,060
Обчислимо тривалість.

60
00:03:45,060 --> 00:03:48,330
А це - (toc-tic)*1000

61
00:03:48,330 --> 00:03:52,075
(щоб ми могли виразити результат в мілісекундах).

62
00:03:52,075 --> 00:03:54,075
Тож ms - це мілісекунди.

63
00:03:54,075 --> 00:03:56,435
І я натискаю Shift+Enter.

64
00:03:56,435 --> 00:04:01,890
Отож, цей код виконувався приблизно 3 мілісекунди. Цього разу 1,5мс.

65
00:04:01,890 --> 00:04:06,170
Добре. Тож виконання коду триває 1,5-3,5мс.

66
00:04:06,170 --> 00:04:08,370
Час дещо відрізняється кожного разу,

67
00:04:08,370 --> 00:04:12,085
але схоже на те, що ця операція триває приблизно 1,5мс.

68
00:04:12,085 --> 00:04:15,665
Можливо, 2мс.

69
00:04:15,665 --> 00:04:16,967
Добре.

70
00:04:16,967 --> 00:04:19,005
Давай допишемо в цей блок ще

71
00:04:19,005 --> 00:04:22,270
використання невекторизованого способу.

72
00:04:22,270 --> 00:04:24,151
c=0.

73
00:04:24,151 --> 00:04:27,750
тоді tic=time.time().

74
00:04:27,750 --> 00:04:29,335
Тепер додамо цикл for:

75
00:04:29,335 --> 00:04:35,348
for i in range(1000000).

76
00:04:35,348 --> 00:04:38,676
Так, я правильно підібрав кількість нулів.

77
00:04:38,676 --> 00:04:43,936
c+=a[i]*b[i].

78
00:04:43,936 --> 00:04:50,775
Тоді toc=time.time().

79
00:04:50,775 --> 00:04:57,725
І, нарешті: print, явний цикл for,

80
00:04:57,725 --> 00:05:15,225
тривалість 1000*(toc-tic) плюс "ms"

81
00:05:15,225 --> 00:05:17,505
(щоб позначити те, що ми робимо мілісекундами).

82
00:05:17,505 --> 00:05:19,735
Ну і давай зробимо ще одну річ.

83
00:05:19,735 --> 00:05:22,802
Давай виведемо значення c, яке ми

84
00:05:22,802 --> 00:05:27,960
обчислюємо, щоб бути впевненими, що воно однакове в обох випадках.

85
00:05:27,960 --> 00:05:35,770
Добре. Отже, зараз я натисну Shift+Enter, щоб виконати і перевірити.

86
00:05:35,770 --> 00:05:38,305
В обох випадках, векторизованому

87
00:05:38,305 --> 00:05:41,125
і невекторизованому способах обчислення, - однакові значення -

88
00:05:41,125 --> 00:05:45,355
250286,989 і далі.

89
00:05:45,355 --> 00:05:48,670
Векторизований спосіб зайняв 1,5мс.

90
00:05:48,670 --> 00:05:57,555
Явний цикл for (невекторизований спосіб) зайняв 400, майже 500мс.

91
00:05:57,555 --> 00:06:01,285
Невекторизований спосіб зайняв приблизно в 300

92
00:06:01,285 --> 00:06:05,660
більше часу ніж векторизований.

93
00:06:05,660 --> 00:06:11,230
На цьому прикладі ми бачимо, що якщо не забувати векторизувати свій код,

94
00:06:11,230 --> 00:06:15,120
він буде виконуватись більш ніж у 300 разів швидше.

95
00:06:15,120 --> 00:06:16,540
Давай ще раз його виконаємо.

96
00:06:16,540 --> 00:06:18,930
І ще раз.

97
00:06:18,930 --> 00:06:22,235
Так, векторизований спосіб - 1,5мс, а цикл for

98
00:06:22,235 --> 00:06:25,960
зайняв 481мс. Тож знову

99
00:06:25,960 --> 00:06:29,535
приблизно в 300 разів повільніше користуватись явним циклом for.

100
00:06:29,535 --> 00:06:30,980
Отже, якщо якийсь комп'ютер x працює повільно

101
00:06:30,980 --> 00:06:33,880
(а є різниця коли твій код виконується 1 хвилину,

102
00:06:33,880 --> 00:06:37,615
а не, скажімо, 5 годин)...

103
00:06:37,615 --> 00:06:41,410
Коли ми застосовуємо алгоритми ГН,

104
00:06:41,410 --> 00:06:43,300
то можемо отримувати результат швидше,

105
00:06:43,300 --> 00:06:46,590
значно швидше, якщо векторизуємо свій код.

106
00:06:46,590 --> 00:06:49,300
Дехто з вас може чув, що багато

107
00:06:49,300 --> 00:06:54,260
масштабних застосувань ГН виконуються на GPU, або графічному процесорі.

108
00:06:54,260 --> 00:06:59,515
Проте, все, що я щойно продемонстрував в записнику Jupyter, виконувалось на CPU.

109
00:06:59,515 --> 00:07:04,530
Виявляється, що і GPU і CPU мають інструкції паралелізації.

110
00:07:04,530 --> 00:07:07,530
Вони ще називаються інструкціями SIMD.

111
00:07:07,530 --> 00:07:11,190
Що означає "одна інструкція - багато даних" [Single Instruction Multiple Data].

112
00:07:11,190 --> 00:07:13,045
По суті, це означає, що

113
00:07:13,045 --> 00:07:16,835
якщо використовувати вбудовані функції як

114
00:07:16,835 --> 00:07:23,495
np.function() або інші функції, які не вимагають використання явного циклу for,

115
00:07:23,495 --> 00:07:28,150
це дозволяє Python numpy скористатись

116
00:07:28,150 --> 00:07:33,640
перевагами паралелізму, щоб прискорити обчислення.

117
00:07:33,640 --> 00:07:38,610
І це справджується для обчислень як на GPU, так і на CPU.

118
00:07:38,610 --> 00:07:41,070
Просто GPU дуже добре справляються з

119
00:07:41,070 --> 00:07:44,980
інструкціями SIMD, але CPU теж непогано це роблять.

120
00:07:44,980 --> 00:07:47,510
Просто, можливо, не так добре як GPU.

121
00:07:47,510 --> 00:07:51,660
Тепер ти переконався/лась, що векторизація значно прискорює код.

122
00:07:51,660 --> 00:07:54,685
Варто пам'ятати, що якщо можливо, то

123
00:07:54,685 --> 00:07:57,425
треба уникати використання явних циклів for.

124
00:07:57,425 --> 00:07:59,980
Давай перейдемо до наступного відео, що побачити більше прикладів

125
00:07:59,980 --> 00:08:04,000
векторизації і також почати векторизувати ЛР.