1
00:00:00,450 --> 00:00:04,786
Python 能夠讓您
使用傳播運算

2
00:00:04,786 --> 00:00:09,944
更一般來說, Python numpy 的強大靈活性是

3
00:00:09,944 --> 00:00:14,748
有強處
也有弱點的程式語言

4
00:00:14,748 --> 00:00:18,393
它的長處是因為
它的表達力

5
00:00:18,393 --> 00:00:22,547
它極大的靈活性
讓您即使用一行程式也可以

6
00:00:22,547 --> 00:00:24,165
做很多事

7
00:00:24,165 --> 00:00:28,530
但它的弱點也因為
傳播的極大

8
00:00:28,530 --> 00:00:32,610
靈活性有時候
您會有微妙的臭蟲或者

9
00:00:32,610 --> 00:00:36,530
莫名其妙的臭蟲, 如果您不
熟悉錯綜複雜的

10
00:00:36,530 --> 00:00:39,800
傳播跟
傳播的特徵如何作用

11
00:00:39,800 --> 00:00:44,500
舉個例子, 舉個例子如果您拿列向量
加到行向量，您會

12
00:00:44,500 --> 00:00:48,700
期望它丟出維度
不匹配或是類型錯誤等等

13
00:00:48,700 --> 00:00:52,620
但您也許真的得到
一個矩陣是行向量跟

14
00:00:52,620 --> 00:00:54,030
列向量的和

15
00:00:54,030 --> 00:00:58,370
所以這是一個有很奇怪影響的Python 內部邏輯

16
00:00:58,370 --> 00:01:03,370
但如果您不熟悉 Python 
我看過很多學生有很奇怪

17
00:01:03,370 --> 00:01:05,680
很難發現的臭蟲

18
00:01:05,680 --> 00:01:09,380
所以我想在這一段影片
分享您一些提示跟

19
00:01:09,380 --> 00:01:12,800
技巧已經很有用的
為我消除或

20
00:01:12,800 --> 00:01:17,320
簡化跟去掉所有我的程式奇怪
的臭蟲

21
00:01:17,320 --> 00:01:19,280
我希望這些提示跟技巧

22
00:01:19,280 --> 00:01:24,193
您也能夠更容易
寫出沒有臭蟲的 Python, numpy 程式

23
00:01:25,430 --> 00:01:30,200
為了描述一個比較不
直觀的影響對於 Python Numpy

24
00:01:30,200 --> 00:01:34,990
尤其是您如何建立
Python Numpy 向量, 讓我做一個快速的展示

25
00:01:34,990 --> 00:01:40,817
假設 a = np.random.randn(5)

26
00:01:40,817 --> 00:01:45,699
這會建立一個 5 個隨機高斯亂數

27
00:01:45,699 --> 00:01:49,640
儲存在陣列 a 中

28
00:01:49,640 --> 00:01:55,420
讓我們 print(a)
它會印出

29
00:01:55,420 --> 00:02:02,740
而它的 shape 當您這樣做時
是 5 逗點結構

30
00:02:02,740 --> 00:02:06,320
而這在 Python 是稱為等級
1陣列

31
00:02:06,320 --> 00:02:09,750
它既不是行向量
也不是列向量

32
00:02:09,750 --> 00:02:12,570
而這會導致一些
輕微非直觀的效果

33
00:02:12,570 --> 00:02:17,180
舉個例子, 如果我印轉置
它會跟 a 看起來一樣

34
00:02:17,180 --> 00:02:20,220
所以 a 跟
a 轉置看起來一樣

35
00:02:20,220 --> 00:02:25,800
如果我印 a 跟 a 轉置的內積
您也許想

36
00:02:25,800 --> 00:02:30,190
a 乘 a 轉置也許是外積
應該或許給您一個矩陣

37
00:02:30,190 --> 00:02:34,170
但如果我這樣做
您會得到一個數字取而代之

38
00:02:34,170 --> 00:02:39,612
所以我會這樣建議
當您做神經網路程式時

39
00:02:39,612 --> 00:02:46,115
您盡量不用這種資料結構
這種 5, 或 n, 等級1陣列

40
00:02:46,115 --> 00:02:52,134
取而代之, 如果您設它為 (5,1)

41
00:02:52,134 --> 00:02:58,764
這個會保證是
一個 (5,1) 列向量

42
00:02:58,764 --> 00:03:02,399
而之前, a 跟
a 轉置看起來一樣

43
00:03:02,399 --> 00:03:06,590
如果現在您印 a 轉置
a轉置會是一個行向量

44
00:03:06,590 --> 00:03:08,437
請注意一個細微的差別

45
00:03:08,437 --> 00:03:12,213
在這種資料結構，有兩個
方括弧當我們列印轉置

46
00:03:12,213 --> 00:03:14,460
而之前
只有一個方括弧

47
00:03:14,460 --> 00:03:19,393
這個就是不同點
介於一個真的 1 乘

48
00:03:19,393 --> 00:03:23,481
5 矩陣跟一個
等級1陣列

49
00:03:23,481 --> 00:03:28,129
如果您列印
a 跟a 轉置的乘積

50
00:03:28,129 --> 00:03:32,444
這會給您一個
向量的內積, 是吧?

51
00:03:32,444 --> 00:03:35,795
一個向量的外積
給您ㄧ個矩陣

52
00:03:35,795 --> 00:03:40,305
讓我們更詳細地
看一下我們剛剛看到的

53
00:03:40,305 --> 00:03:43,185
我們執行第一個指令
是這個

54
00:03:43,185 --> 00:03:47,839
而這個建立一個資料結構

55
00:03:47,839 --> 00:03:52,930
a.shape 是這個有趣的 (5,)

56
00:03:52,930 --> 00:03:57,270
這個稱為等級1陣列

57
00:03:57,270 --> 00:03:58,960
這是一個非常有趣的資料結構

58
00:03:58,960 --> 00:04:04,000
它表現得並不一致為
行向量或者列向量

59
00:04:04,000 --> 00:04:06,750
而使得它的一些
影響並不直觀

60
00:04:06,750 --> 00:04:10,770
我的建議是
當您做您的程式

61
00:04:10,770 --> 00:04:14,050
作業或者當您
建置羅吉斯迴歸分析或

62
00:04:14,050 --> 00:04:19,740
神經網路時
不要用這個等級1陣列

63
00:04:21,020 --> 00:04:24,098
取而代之, 如果每次
您建立一個矩陣

64
00:04:24,098 --> 00:04:27,500
您保證建立
一個列向量

65
00:04:27,500 --> 00:04:32,360
像是 (5,1) 向量
或者保證建一個行向量

66
00:04:32,360 --> 00:04:36,670
那您的向量的行為
會比較容易懂

67
00:04:36,670 --> 00:04:43,115
所以在這個例子
 a.shape 會是 5,1

68
00:04:43,115 --> 00:04:48,510
這個的表現會很像
實際上就是一個列向量

69
00:04:48,510 --> 00:04:53,233
而這是為什麼您可以將它想成
(5,1)矩陣, 就是一個列向量

70
00:04:53,233 --> 00:04:56,880
這裡 a.shape 會是 1,5

71
00:04:56,880 --> 00:05:01,000
而這會是表現一致的
行向量

72
00:05:02,150 --> 00:05:06,258
當您需要一個向量
我會說用這個或是這個

73
00:05:06,258 --> 00:05:07,538
而不要用等級1陣列

74
00:05:07,538 --> 00:05:12,061
還有一件事我常常在我的
程式中如果我不完全肯定

75
00:05:12,061 --> 00:05:17,029
我的向量的維度時
我通常會用判定敘述

76
00:05:17,029 --> 00:05:21,720
像這樣, 來確保, 這個例子來講
這是一個 (5,1)向量

77
00:05:21,720 --> 00:05:23,730
這是一個列向量

78
00:05:23,730 --> 00:05:26,900
這些判定
可以不費力的執行

79
00:05:26,900 --> 00:05:30,250
也可以當成是
您程式的註解文件

80
00:05:30,250 --> 00:05:34,160
所以請不要遲疑的使用判定
敘述像這樣當您

81
00:05:34,160 --> 00:05:35,320
覺得需要時

82
00:05:35,320 --> 00:05:39,510
最後, 如果出於某種原因
您用了等級1陣列

83
00:05:39,510 --> 00:05:43,960
您可以 reshape 它, a 等於 a.reshape

84
00:05:43,960 --> 00:05:48,900
變成 (5,1) 陣列或者 (1,5) 陣列

85
00:05:48,900 --> 00:05:53,750
讓它的行為成為比較一致的
列向量或者行向量

86
00:05:53,750 --> 00:05:57,626
有時候我看到學生們
很難去追臭蟲

87
00:05:57,626 --> 00:06:01,119
因為有這些非直觀的
等級1陣列影響

88
00:06:01,119 --> 00:06:06,246
通過去除等級1陣列在我的
程式中, 我的程式變得更簡單

89
00:06:06,246 --> 00:06:09,463
我並沒發現到這樣做
會限制我可以

90
00:06:09,463 --> 00:06:10,335
在程式中做的事

91
00:06:10,335 --> 00:06:12,469
我就是從不使用等級1 陣列

92
00:06:12,469 --> 00:06:17,090
所以請謹記要簡化
您的程式, 不要用等級1陣列

93
00:06:17,090 --> 00:06:19,437
永遠使用 n 乘 1 矩陣

94
00:06:19,437 --> 00:06:24,510
基本上是列向量, 或者 1 乘
n矩陣, 或者基本上行向量

95
00:06:24,510 --> 00:06:26,599
盡量用很多的
判定敘述來

96
00:06:26,599 --> 00:06:29,590
仔細檢查
您矩陣跟陣列的維度

97
00:06:29,590 --> 00:06:34,480
而且, 不要害羞的使用 
reshape 運算來確保您的

98
00:06:34,480 --> 00:06:38,780
矩陣或陣列
是您要的維度

99
00:06:38,780 --> 00:06:39,420
所以

100
00:06:39,420 --> 00:06:44,770
我希望這些建議
幫助您去除可能的臭蟲

101
00:06:44,770 --> 00:06:48,840
從 python 程式, 讓您更容易完成
您個程式作業