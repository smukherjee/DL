1
00:00:00,450 --> 00:00:04,786
Python で
ブロードキャストの操作ができることや

2
00:00:04,786 --> 00:00:09,944
より一般的に言えば
Python やNumpy に高いレベルの柔軟性があることは

3
00:00:09,944 --> 00:00:14,748
プログラム言語としての
強みでもあり弱みでもあります

4
00:00:14,748 --> 00:00:18,393
強みの面としては
言語が高い表現性と柔軟性をもっていることで

5
00:00:18,393 --> 00:00:22,547
たった１行のコードでも
多くのことができるように

6
00:00:22,547 --> 00:00:24,165
なるからです

7
00:00:24,165 --> 00:00:28,530
弱みでもあります
ブロードキャストや

8
00:00:28,530 --> 00:00:32,610
高い柔軟性があることで
時として見つけにくいバグや

9
00:00:32,610 --> 00:00:36,530
見たことのない挙動をするバグを
混入させてしまう可能性があるからです

10
00:00:36,530 --> 00:00:39,800
ブロードキャストのような機能の動作や
全体の複雑さに詳しくないと起こります

11
00:00:39,800 --> 00:00:44,500
例えば列ベクトルに
行ベクトルを足すと

12
00:00:44,500 --> 00:00:48,700
配列不一致や型のエラーなどを
期待するものだと思いますが

13
00:00:48,700 --> 00:00:52,620
実は行ベクトルと
列ベクトルの合計が

14
00:00:52,620 --> 00:00:54,030
返ってきます

15
00:00:54,030 --> 00:00:58,370
Python の奇妙な動作には
内部的なロジックが関わっています

16
00:00:58,370 --> 00:01:03,370
しかしPython に詳しくない場合で
非常に奇妙で見つけにくいバグを作った学生を

17
00:01:03,370 --> 00:01:05,680
見てきました

18
00:01:05,680 --> 00:01:09,380
このビデオでは
コードに生まれうる奇妙なバグを排除して

19
00:01:09,380 --> 00:01:12,800
簡素にコード書くために
非常に役立ってきたコツを

20
00:01:12,800 --> 00:01:17,320
共有したいと思います

21
00:01:17,320 --> 00:01:19,280
これらのコツを使って

22
00:01:19,280 --> 00:01:24,193
バグのないPython やnumpy のコードを
容易に書けるようになればと思います

23
00:01:25,430 --> 00:01:30,200
直感では分かりにくい
Python や numpyの結果をお見せする目的で

24
00:01:30,200 --> 00:01:34,990
ベクトルを作る方法について
デモを行います

25
00:01:34,990 --> 00:01:40,817
では
a = np.random.randn(5)と書いて

26
00:01:40,817 --> 00:01:45,699
ガウス分布の乱数を
５つ作り

27
00:01:45,699 --> 00:01:49,640
array a に記録します

28
00:01:49,640 --> 00:01:55,420
print(a) を実行します
またa.shapeは

29
00:01:55,420 --> 00:02:02,740
(5,)の構造になっています

30
00:02:02,740 --> 00:02:06,320
これはランク１の配列と
呼ばれています

31
00:02:06,320 --> 00:02:09,750
行ベクトルでも
列ベクトルでもありません

32
00:02:09,750 --> 00:02:12,570
このことが
やや直感的でない結果を生みます

33
00:02:12,570 --> 00:02:17,180
例えばaの転置をprint すると
a とまったく同じ結果になります

34
00:02:17,180 --> 00:02:20,220
a とa.T が同じ結果に
なってしまいます

35
00:02:20,220 --> 00:02:25,800
そしてa とa.T の内積を
print すると

36
00:02:25,800 --> 00:02:30,190
a×a.Tは外積になり
行列を返すことを期待するかもしれませんが

37
00:02:30,190 --> 00:02:34,170
これを実行すると
替わりに１つの数が返ってきます

38
00:02:34,170 --> 00:02:39,612
このためニューラルネットワークを
コードするときには

39
00:02:39,612 --> 00:02:46,115
(5,)や(n,)やランク１配列のような形の構造を
使わないことをお勧めします

40
00:02:46,115 --> 00:02:52,134
そのかわりに
a を(5,1)に指定すれば

41
00:02:52,134 --> 00:02:58,764
a が(5,1)の列ベクトルになることを
確定させることができます

42
00:02:58,764 --> 00:03:02,399
先ほどはa×a.Tは
同一結果になりましたが

43
00:03:02,399 --> 00:03:06,590
a.T をprintすると
列ベクトルになっています

44
00:03:06,590 --> 00:03:08,437
微妙な違いに注目してください

45
00:03:08,437 --> 00:03:12,213
print したa.Tのこのデータ構造には
[が２つあります

46
00:03:12,213 --> 00:03:14,460
先ほどは
[は１つでした

47
00:03:14,460 --> 00:03:19,393
これが
この(1,5)の行列と

48
00:03:19,393 --> 00:03:23,481
このランク１の配列との違いでした

49
00:03:23,481 --> 00:03:28,129
aとa.Tの積をprint すると

50
00:03:28,129 --> 00:03:32,444
ベクトルの外積を
計算してくれます

51
00:03:32,444 --> 00:03:35,795
ベクトルの外積が 行列を返します

52
00:03:35,795 --> 00:03:40,305
非常に細かなところまで
見てきました

53
00:03:40,305 --> 00:03:43,185
最初に実行した１つ目のコマンドは
これでした

54
00:03:43,185 --> 00:03:47,839
このコマンドは
不思議な構造を作りました

55
00:03:47,839 --> 00:03:52,930
a.shapenbspで表示すると
(5,)になり

56
00:03:52,930 --> 00:03:57,270
ランク１配列と呼ばれます

57
00:03:57,270 --> 00:03:58,960
これは非常におかしなデータ構造で

58
00:03:58,960 --> 00:04:04,000
行ベクトルや列ベクトルのどちらとしても動作せず

59
00:04:04,000 --> 00:04:06,750
直感的でない結果を
生みます

60
00:04:06,750 --> 00:04:10,770
あなたがプログラム演習をする際に
私がおすすめするのは

61
00:04:10,770 --> 00:04:14,050
ニューラルネットワークに
ロジステック回帰を実装する演習では

62
00:04:14,050 --> 00:04:19,740
ランク１配列を使わないことを
お勧めします

63
00:04:21,020 --> 00:04:24,098
かわりに
配列を作るときはいつでも

64
00:04:24,098 --> 00:04:27,500
このように(5,1)の列ベクトルに

65
00:04:27,500 --> 00:04:32,360
確定するようにするか
行ベクトルに確定するようにしましょう

66
00:04:32,360 --> 00:04:36,670
作ったベクトルの挙動が
より分かりやすくなります

67
00:04:36,670 --> 00:04:43,115
この場合にはa.shape は
(5,1)を返します

68
00:04:43,115 --> 00:04:48,510
これは列ベクトルのように振舞いますし
実際に列ベクトルです

69
00:04:48,510 --> 00:04:53,233
実際に列ベクトルですが
(5,1)の行列のように考えることができます

70
00:04:53,233 --> 00:04:56,880
そしてこの場合には
a.shapenbspは(1,5)を返します

71
00:04:56,880 --> 00:05:01,000
これは行ベクトルと同じように動作します

72
00:05:02,150 --> 00:05:06,258
なのでベクトルが必要なときには
これかこれのどちらかを使って

73
00:05:06,258 --> 00:05:07,538
ランク１配列は
やめましょう

74
00:05:07,538 --> 00:05:12,061
私がコードで頻繁に行うのは
ベクトルの配列数を

75
00:05:12,061 --> 00:05:17,029
完全には把握できていない時は
assert 文を入れておきます

76
00:05:17,029 --> 00:05:21,720
このようにしてこの場合には
(5,1)のベクトルなのを確実にします

77
00:05:21,720 --> 00:05:23,730
これは列ベクトルです

78
00:05:23,730 --> 00:05:26,900
これらのassert は
速度をほとんど犠牲にしませんし

79
00:05:26,900 --> 00:05:30,250
コードにドキュメントを付けるためにも
役立ちます

80
00:05:30,250 --> 00:05:34,160
入れておきたいと思ったときには
assert 文を躊躇せずに入れておくように

81
00:05:34,160 --> 00:05:35,320
しましょう

82
00:05:35,320 --> 00:05:39,510
最後に何かの原因で
ランク１配列ができてしまった場合には

83
00:05:39,510 --> 00:05:43,960
a.reshape(5,1)のようにして
形を変えれます

84
00:05:43,960 --> 00:05:48,900
(5,1)配列だったり(1,5)配列に変更して

85
00:05:48,900 --> 00:05:53,750
列ベクトルか行ベクトルと
同じような挙動をするようにします

86
00:05:53,750 --> 00:05:57,626
学生がバグを見つけにくい状態になっていることを
時々見かけます

87
00:05:57,626 --> 00:06:01,119
ランク１配列の直感的でない結果によるものです

88
00:06:01,119 --> 00:06:06,246
ランク１配列を排除することで
コードを簡素にすることができて

89
00:06:06,246 --> 00:06:09,463
コードで表現できる範囲という点では
制限されていると感じたことは

90
00:06:09,463 --> 00:06:10,335
ありません

91
00:06:10,335 --> 00:06:12,469
ランク１配列は
絶対に使いません

92
00:06:12,469 --> 00:06:17,090
覚えておいてほしいのは
コードを簡素にしておくためにランク１配列は使わないで

93
00:06:17,090 --> 00:06:19,437
列ベクトルとも言える(n,1)の行列を使うか

94
00:06:19,437 --> 00:06:24,510
行ベクトルともいえる(1,n)の行列を
常に使うようにします

95
00:06:24,510 --> 00:06:26,599
多くのassert 文を
入れて良いと考えて

96
00:06:26,599 --> 00:06:29,590
行列や配列の配列数を
再確認するようにしましょう

97
00:06:29,590 --> 00:06:34,480
またreshape 操作も
遠慮せずに使って

98
00:06:34,480 --> 00:06:38,780
行列やベクトルが必要な配列数に
なっていることを確実にしましょう

99
00:06:38,780 --> 00:06:39,420
これで

100
00:06:39,420 --> 00:06:44,770
これらの提案を使うことで
Python のコードからバグの原因を排除して

101
00:06:44,770 --> 00:06:48,840
あなたがプログラム演習を
より簡単に完了できるといいと思います