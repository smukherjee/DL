1
00:00:00,450 --> 00:00:04,786
여러분이 broadcasting operations사용하게 할 수 있게 해주는 파이썬의 능력과

2
00:00:04,786 --> 00:00:09,944
그그리고 더 일반적으로, 파이썬 넘파이 프로그램 언어의
큰 유동성은,

3
00:00:09,944 --> 00:00:14,748
프로그램 언어에서 장점과 동시에 단점이 
동시 있습니다.

4
00:00:14,748 --> 00:00:18,393
이것이 강점인 이유는 언어의 표현 성을 생성하기 때문이죠. 

5
00:00:18,393 --> 00:00:22,547
언어의 유동성은 여러분이 단순히 한 줄의 코드로도

6
00:00:22,547 --> 00:00:24,165
많은 것을 해낼 수 있게 해줍니다.

7
00:00:24,165 --> 00:00:28,530
그렇지만, broadcasting에서 약점도 있는데요, 

8
00:00:28,530 --> 00:00:32,610
이런 큰 유동성 때문에, 
아주 감지하기 힘든 버그나 

9
00:00:32,610 --> 00:00:36,530
또는 매우 이상하게 생긴 버그를 들여올 수 있습니다.

10
00:00:36,530 --> 00:00:39,800
만약 broadcasting의 복잡한 구조와 
특성에 대해서 익숙하지 않으면 말이죠.

11
00:00:39,800 --> 00:00:44,500
예를 들어, 세로줄 벡터를 가져서 
가로줄 벡터에 더하면, 

12
00:00:44,500 --> 00:00:48,700
다이멘션의 불일치가 생기거나 
오류가 생길 것으로 예상할 텐데요, 

13
00:00:48,700 --> 00:00:52,620
반면에 가로벡터와 세로벡터의 함을 통해

14
00:00:52,620 --> 00:00:54,030
매트릭스 값이 나올 수도 있겠죠. 

15
00:00:54,030 --> 00:00:58,370
이러한 특이한 파이썬의 특성에는 그에 상응하는 내부 로직이 있는데요.

16
00:00:58,370 --> 00:01:03,370
만약 파이썬에 익숙지 않은 경우, 
저는 몇몇의 학생들이 

17
00:01:03,370 --> 00:01:05,680
정말 이상하거나, 매우 찾기 힘든 버그들을 갖는 것을
직접 보았습니다.

18
00:01:05,680 --> 00:01:09,380
그러므로 이 비디오에서는 
몇 가지 팁을 공유하고, 

19
00:01:09,380 --> 00:01:12,800
저희 코드에 있는 이상하게 생긴 버그를

20
00:01:12,800 --> 00:01:17,320
제거하거나 심플하게 만드는 비법을 공개하겠습니다.

21
00:01:17,320 --> 00:01:19,280
그리고 이러한 팀과 비법을 통해서

22
00:01:19,280 --> 00:01:24,193
여러분이 버그로부터 자유로운 
파이썬 그리고 넘파이 코드를 만들 수 있을 것입니다.

23
00:01:25,430 --> 00:01:30,200
파이썬-넘파이의 조금 덜 직관적인 효과를 보여드리자면, 

24
00:01:30,200 --> 00:01:34,990
특히, 벡터를 파이썬-넘파이에서 만드는 방법에 대해서 말이죠. 
빠른 데모를 보여드리죠. 

25
00:01:34,990 --> 00:01:40,817
a를 np.random.randn(5)로 설정하겠습니다.

26
00:01:40,817 --> 00:01:45,699
이것은 그러면 임의로 5개으 Gaussian 변수를

27
00:01:45,699 --> 00:01:49,640
만들어 주는데요 이 값들은 array a에 보관됩니다.

28
00:01:49,640 --> 00:01:55,420
이제 print(a)를 해보죠, 

29
00:01:55,420 --> 00:02:02,740
a의 shape은 이렇게 하면, 
5개의 콤마구조를 갖습니다.

30
00:02:02,740 --> 00:02:06,320
파이썬에서 이것은 랭크 1 array라고 하는데요, 

31
00:02:06,320 --> 00:02:09,750
이것은 row 벡터도 아니고 
column 벡터도 아닙니다.

32
00:02:09,750 --> 00:02:12,570
이런 것이 조금 더 직관적이지 않은 부분으로 이어지는데요, 

33
00:02:12,570 --> 00:02:17,180
예를 들거, 제가 만약 a transpose 를
print 하면, 이것은 a와 동일하게 보입니다.

34
00:02:17,180 --> 00:02:20,220
그러면 a와 a transpose는 똑같이 보이고 있죠. 

35
00:02:20,220 --> 00:02:25,800
그리고 만약 제가 a와 a transpose의 
안쪽 프로덕트들을 프린트하면, 

36
00:02:25,800 --> 00:02:30,190
여기서 a 곱하기 a transpose는 밖았쪽 프로덕트라고 생각할 수도 있는데요, 
매트릭스를 줄 수도 있다고 생각할 수 있는데요, 

37
00:02:30,190 --> 00:02:34,170
그러나 이렇게 하면, 
대신에 이러한 숫자 값을 갖게 됩니다.

38
00:02:34,170 --> 00:02:39,612
그러므로 제가 추천 드리는 것은, 
만약 여러분이 신경망을 코딩 하는 경우에는, 

39
00:02:39,612 --> 00:02:46,115
데이터구조를 사용하는 것이 아니라, 
모양이 5 콤마나, n 콤마나, rank 1 array등과 같은 것이 아니라, 

40
00:02:46,115 --> 00:02:52,134
이렇게 a를 np.random.randn(5, 1)로 지정해서

41
00:02:52,134 --> 00:02:58,764
그러면 a가 5, 1 세로 벡터가 되게끔 해주는데요, 

42
00:02:58,764 --> 00:03:02,399
이전에는 a 와 a transpose가 똑같이 생겼었지만, 

43
00:03:02,399 --> 00:03:06,590
이제는 a transpose를 print하면, 
a transpose는 row vector죠, 

44
00:03:06,590 --> 00:03:08,437
이제 작은 차이를 보겠습니다.

45
00:03:08,437 --> 00:03:12,213
여기 데이터 구조를 보시면, 
2개의 대괄호가 있습니다. a transpose를 프린트하는 
경우에 말이죠. 

46
00:03:12,213 --> 00:03:14,460
이전에는 1개의 대괄호가 있었죠. 

47
00:03:14,460 --> 00:03:19,393
이것이 바로 여기 1 x 5 매트릭스와

48
00:03:19,393 --> 00:03:23,481
여기 rank 1 array중의 하나와의 차이입니다.

49
00:03:23,481 --> 00:03:28,129
그리고 만약 여러분이 
a 와 a transpose의 프로덕트를 프린트하면, 

50
00:03:28,129 --> 00:03:32,444
이것은 그러면 벡터의 밖았쪽 프로덕트를 줍니다. 맞죠?

51
00:03:32,444 --> 00:03:35,795
그래서 벡터의 밖았쪽 프로덕트들이 
매트릭스를 만드는 것이죠.

52
00:03:35,795 --> 00:03:40,305
여기서 본 것에 대해 조금 더 자세히 다루겠습니다

53
00:03:40,305 --> 00:03:43,185
방금 명령한 것은, 이거 였습니다.

54
00:03:43,185 --> 00:03:47,839
이것은 a.shape라는 데이터 

55
00:03:47,839 --> 00:03:52,930
구조를 만들었고요, 이것은 조금 우습게 생긴

56
00:03:52,930 --> 00:03:57,270
(5, ) 라는 것을 주었습니다. 이것은 rank 1 array라고 부릅니다.

57
00:03:57,270 --> 00:03:58,960
아주 우스운 모양의 데이터 구조인데요 

58
00:03:58,960 --> 00:04:04,000
이것은 row vector 나 column vector와 같이 
균일하게 행동하지 않습니다. 

59
00:04:04,000 --> 00:04:06,750
그렇기 때문에 이 특성이 직관적이지 않은 것이죠. 

60
00:04:06,750 --> 00:04:10,770
그러므로 제가 여러분에게 추천 드리는 것은 
프로그래밍 연습 과제를 할 때, 

61
00:04:10,770 --> 00:04:14,050
아니면 로지스틱 회귀분석을 도입할 때, 또는

62
00:04:14,050 --> 00:04:19,740
이런 rank 1 array를 이용하지 말라는 것입니다.

63
00:04:21,020 --> 00:04:24,098
대신에, array를 생성할 때마다, 

64
00:04:24,098 --> 00:04:27,500
여기와 같이 세로줄 벡터를 만듭니다.

65
00:04:27,500 --> 00:04:32,360
그러면 (5, 1) 벡터가 생성되는데요, 
또는 row vector를 만듭니다.

66
00:04:32,360 --> 00:04:36,670
그렇게 되면 여러분의 벡터는 
이해하기 쉽게 행동할 것입니다.

67
00:04:36,670 --> 00:04:43,115
이 경우, a.shape는 5, 1이 될 것입니다.

68
00:04:43,115 --> 00:04:48,510
이것은 column vector와 같이 행동할 텐데요, 
사실 이것이 column vector입니다.

69
00:04:48,510 --> 00:04:53,233
그리고, 그렇기 때문에 이것을 
(5, 1) 매트릭스로 생각할 수 있는 것입니다.
이것은 column vector이기도 하죠. 

70
00:04:53,233 --> 00:04:56,880
그리고 여기서는 a.shape가 1, 5일 것입니다.

71
00:04:56,880 --> 00:05:01,000
이것은 일관되게 row vector처럼 행동할 것입니다.

72
00:05:02,150 --> 00:05:06,258
그러므로 여러분이 벡터가 필요한 경우, 
이것이나 이것을 이용하길 권장 드립니다.

73
00:05:06,258 --> 00:05:07,538
rank 1 array는 말고 말이죠. 

74
00:05:07,538 --> 00:05:12,061
또 한가지 제가 제 코드에서 많이 할 것은 

75
00:05:12,061 --> 00:05:17,029
벡터의 다이멘션이 정확히 무엇인지 모르는 경우, 
assertion 문구를 이렇게 넣어서, 

76
00:05:17,029 --> 00:05:21,720
이 경우, (5, 1) 벡터가 되도록 말이죠. 

77
00:05:21,720 --> 00:05:23,730
column 벡터 말이죠. 

78
00:05:23,730 --> 00:05:26,900
이런 assertion은 실행을 목적으로 하는데요

79
00:05:26,900 --> 00:05:30,250
코드를 기록화하는 역할도 있습니다.

80
00:05:30,250 --> 00:05:34,160
그러므로 이렇게 assertion 문구를 넣고 싶을 때, 

81
00:05:34,160 --> 00:05:35,320
주저하지 마시고 넣으십시오. 

82
00:05:35,320 --> 00:05:39,510
마지막으로, 어떤 이유에서든, 
rank 1 array를 갖게 되면, 

83
00:05:39,510 --> 00:05:43,960
이것을 다시 만들 수 있는데요, a=a.reshape ( (5, 1))처럼 

84
00:05:43,960 --> 00:05:48,900
말이죠, 또는 (1, 5) array로 변형해서 

85
00:05:48,900 --> 00:05:53,750
column vector 또는 row vector와 조금 더 맞게 
행동할 수 있도록 해줄 수 있습니다.

86
00:05:53,750 --> 00:05:57,626
저는 그래서 가끔식 학생들이

87
00:05:57,626 --> 00:06:01,119
아주 타자내기 어려운 버그를 갖게 되는 경우를 봤는데요, 
그 이유는 이러한 rank 1 array에 직관적이지 않은 부분 때문입니다.

88
00:06:01,119 --> 00:06:06,246
이전 코드에서 rank 1 array를 제거함을 써, 
저의 코드는 더욱 간소화됐습니다.

89
00:06:06,246 --> 00:06:09,463
그리고 코드를 표현하는데 딱히

90
00:06:09,463 --> 00:06:10,335
제한을 느끼거나 그러지는 않았습니다.

91
00:06:10,335 --> 00:06:12,469
저는 그냥 절대로 rank 1 array를 사용하지 않습니다.

92
00:06:12,469 --> 00:06:17,090
그러면 코드를 심플하게 만들려면 
rank 1 array들을 사용하지 말라는 게 이번 강의의 주요 포인트입니다.

93
00:06:17,090 --> 00:06:19,437
항상 n x 1 매트릭스를 이용하고, 

94
00:06:19,437 --> 00:06:24,510
즉 column vector 또는 1xn 매트릭스를 이용, 즉
row vector를 이용합니다.

95
00:06:24,510 --> 00:06:26,599
그리고 assertion 문구는 언제든지 사용해도 좋으며, 

96
00:06:26,599 --> 00:06:29,590
여러분의 매트릭스의 다이멘션 이나 array는
더블체크하십시요.

97
00:06:29,590 --> 00:06:34,480
그리고 reshape operation을 부르는 것을 
두려워하지 마십시요. 

98
00:06:34,480 --> 00:06:38,780
매트릭스 또는 벡터의 다이멘션이 
원하는 형을 갖추도록 말이죠. 

99
00:06:38,780 --> 00:06:39,420
그럼 이 내용이, 

100
00:06:39,420 --> 00:06:44,770
이러한 제안들이 여러분의 버그 원인들을 

101
00:06:44,770 --> 00:06:48,840
파이썬에서 알아내고 없애는데 도움이 됐으면 합니다. 
그리고 연습문제로 더 쉽게 풀 수 있기를 희망합니다.