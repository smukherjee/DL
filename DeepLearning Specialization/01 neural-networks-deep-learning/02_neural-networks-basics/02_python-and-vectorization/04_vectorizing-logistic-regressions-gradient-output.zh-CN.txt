在上一节课中 你已经看到如何通过向量化计算预测 同时计算出整个训练集的激活值a 在这个视频中你将看到如何使用向量化 计算全部m个训练样本的梯度 强调一下 是同时计算 在本视频的末尾 我们会将之前讲的结合起来 展示如何非常高效地实现逻辑回归 你也许记得在讲梯度计算时 计算第一个样本的dz_(1)的步骤 即dz^(1)=a^(1)-y^(1) dz^(2)=a^(2)-y^(2) 以此类推 如此对所有m个训练样本进行同样的计算 然后我们可以定义一个新变量 dZ=[dz^(1) dz^(2) ... dz^(m)] 注意 所有dz横向排列 所以这是一个1乘m的矩阵
也可以说是一个m维行向量 回想一下在之前的幻灯片中 我们已经了解了如何计算A 即A=[a^(1)...a^(m)] 我们也已经定义了Y 即Y=[y^(1) ... y^(m)] 它们也是横向排列的 那么基于这些定义 你也许会发现 我们可以这样计算dZ dZ=A-Y 这等同于 dZ=[a^(1)-y^(1), a^(2)-y^(2) ...] 以此类推 这里的第一个元素a^(1)-y^(1)就是dz^(1) 第二个元素就是dz^(2) 等等 所以仅需要一行代码 你就可以同时完成这所有的计算 在之前的实现中 我们已经去掉了一个for循环 但是 我们仍然有一个遍历训练集的循环 我们将dw初始化为0向量 但是我们还是需要遍历训练样本 对第一个训练样本 计算dw+=x^(1)*dz^(1) 对第二个训练样本 计算dw+=x^(2)*dz^(2) 等等 我们重复m次 接着计算dw/=m 对于b也类似 db被初始化为0向量 然后db+=dz^(1) db+=dz^(2) 这样重复到dz^(m) 接着计算db/=m 这就是我们在之前的实现中做的 我们已经去掉了一个for循环 至少现在dw是个向量了 然后我们分别 更新dw_1和dw_2等等 我们去掉了这个for循环 但还有个for循环用于遍历训练集中的m个样本 让我们通过如下的操作把它们向量化 我们要做的是 对于计算db的向量化的实现 只需要对这些dz求和 然后除以m 即db等于1/m乘以 dz^(i)到dz^(m)的和 所有的dz组成了一个行向量 在Python中 你只需要使用 1/m*np.sum(dZ) 你只要把这个变量传给np.sum()函数 就可以得到db 那么dw呢 这里先给出正确的公式
以确保我们做的是正确的 dw的公式就是 dw=1/m*X*dZ^T 让我们看看这样写的原因 这等于1/m乘以X矩阵 X矩阵是由x^(1)到x^(m)按列堆叠起来的 dZ的转置是从dz^(1)到dz^(m) 如果你清楚这个矩阵乘以这个向量的结果 这等于 1/m*[x^(1)*dz^(1)+...+x^(m)*dz^(m)] 这是一个n乘1的向量 也就是你得到的最终结果 因为dw中包括了这些 x^(i)*dz^(i) 然后把它们加起来 这就是这个矩阵和向量的乘法所做的 只要一行代码你就可以计算出dw 计算导数的向量化实现方法如下 你可以用这一行来实现db的计算 用这一行来实现dw的计算
注意我们没有在训练集上使用for循环 你现在就可以计算参数的更新了 现在 我们总结一下
看看到底应该如何实现逻辑回归 这是我们原来的 非常低效 没有向量化的实现 在前一个视频中 我们首先做的是去掉这一堆 不用循环遍历 dw_1 dw_2 等等 我们把它替换为向量dw 即dw+=x^(i)*dz^(i) 其中x^(i)是一个向量 现在 我们不仅要摆脱下面的这个循环 还要消灭掉这个for循环 你要做的是 通过前面幻灯片得到的结果 你会得到 Z=w^TX+b 写成代码就是Z=np.dot(w.T,X)+b 然后 A=sigmoid(Z) 你已经对所有i完成了这些计算 在前面的幻灯片的下一步中 我们知道你还应该计算dZ=A-Y 就对所有i完成了这步计算 最后我们得到 dw=1/m*XdZ^T db=1/m*np.sum(dZ) db=1/m*np.sum(dZ) 至此你已经完成了前向传播和反向传播 完成了对所有m个训练样本的预测和求导 并且没有使用一个for循环 然后更新梯度下降参数 w的更新为w=w-alpha*dw b的更新为b=b-alpha*db 其中alpha是学习率 有时候这里会有一个冒号 表示这是一个赋值操作 但是我前后对这个符号的使用可能并不一致 有了这些 你就实现了逻辑回归梯度下降的一次迭代 虽然我之前说过我们要尽量 避免使用显式的for循环 但如果要实现梯度下降的多次迭代 那么你仍然需要使用for循环 去迭代指定的次数 如果你想让梯度下降迭代1000次 你可能还是需要一个for循环 来迭代指定的次数 像这个最外面的for循环 我认为没有办法能把它也去掉 不过我还是觉得 不使用for循环 就能实现梯度下降的一个迭代 这很cool 现在你得到了一个高度向量化 且非常高效的逻辑回归的梯度下降算法 在下个视频中我还想讨论一些细节 这里简单一提 这种技术称为广播 广播是Python和Numpy提供的一种 能够使特定代码更加高效的技术 我们将在下个视频中学习关于广播的更多细节