1
00:00:00,450 --> 00:00:04,786
Python提供了广播操作的能力

2
00:00:04,786 --> 00:00:09,944
更广泛地说 Python和NumPy带来了极佳的灵活性

3
00:00:09,944 --> 00:00:14,748
我认为这既是Python作为一门编程语言的优势
也是它的劣势

4
00:00:14,748 --> 00:00:18,393
其优势在于增加了语言的表达性

5
00:00:18,393 --> 00:00:22,547
凭借其强大的灵活性 你只用仅仅一行代码就能

6
00:00:22,547 --> 00:00:24,165
完成大量的工作

7
00:00:24,165 --> 00:00:28,530
但这也带来一些缺点 因为广播操作和其强大的灵活性

8
00:00:28,530 --> 00:00:32,610
有时会引入十分微妙 或者非常奇怪的bug

9
00:00:32,610 --> 00:00:36,530
如果你并不熟悉诸如广播等特性的

10
00:00:36,530 --> 00:00:39,800
各种复杂的工作机制的话

11
00:00:39,800 --> 00:00:44,500
例如 如果你将一个列向量与行向量相加

12
00:00:44,500 --> 00:00:48,700
你可能会期望它抛出维度不匹配
或者类型错误之类的报错

13
00:00:48,700 --> 00:00:52,620
但实际上 你会得到一个行向量和列向量

14
00:00:52,620 --> 00:00:54,030
求和后的矩阵

15
00:00:54,030 --> 00:00:58,370
Python的这些奇怪表现有其内在的逻辑

16
00:00:58,370 --> 00:01:03,370
但如果你对Python不熟悉
就会像我见过的一些学生 写出非常奇怪

17
00:01:03,370 --> 00:01:05,680
非常难以发现的bug

18
00:01:05,680 --> 00:01:09,380
所以我想在这个视频里和你们分享一些技巧

19
00:01:09,380 --> 00:01:12,800
它们在排除各种奇怪的bug

20
00:01:12,800 --> 00:01:17,320
和简化代码方面 对我帮助很大

21
00:01:17,320 --> 00:01:19,280
我也希望 在这些技巧的帮助下

22
00:01:19,280 --> 00:01:24,193
你们也能更容易的写出
没有bug的Python和NumPy代码

23
00:01:25,430 --> 00:01:30,200
为了说明Python和NumPy中 尤其是在构建向量时

24
00:01:30,200 --> 00:01:34,990
的一些不太直观的效果 让我来做个快速演示

25
00:01:34,990 --> 00:01:40,817
令a=np.random.randn(5)

26
00:01:40,817 --> 00:01:45,699
这会产生5个高斯随机变量

27
00:01:45,699 --> 00:01:49,640
并储存在数组a中

28
00:01:49,640 --> 00:01:55,420
输入print(a) 结果表明

29
00:01:55,420 --> 00:02:02,740
a的形状是这种(5,)的结构

30
00:02:02,740 --> 00:02:06,320
这在Python中叫做秩为1的数组

31
00:02:06,320 --> 00:02:09,750
它既不是行向量 也不是列向量

32
00:02:09,750 --> 00:02:12,570
这会略微导致一些不直观的影响

33
00:02:12,570 --> 00:02:17,180
比如 我打印a的转置
它的结果看上去和a一样

34
00:02:17,180 --> 00:02:20,220
所以 a和a的转置看起来一样

35
00:02:20,220 --> 00:02:25,800
又如 打印a和a转置的内积

36
00:02:25,800 --> 00:02:30,190
你也许认为a乘以a转置 或者说a的外积 是一个矩阵

37
00:02:30,190 --> 00:02:34,170
但如果我这样写 得到的却是一个数字

38
00:02:34,170 --> 00:02:39,612
所以 我建议你在编写神经网络时

39
00:02:39,612 --> 00:02:46,115
不要使用这种数据结构
即形如(5,)或者(n,)这样的秩为1的数组

40
00:02:46,115 --> 00:02:52,134
而是令a的形状为(5,1)

41
00:02:52,134 --> 00:02:58,764
这会使a成为一个5乘1的列向量

42
00:02:58,764 --> 00:03:02,399
在之前 a和a转置看起来是一样的

43
00:03:02,399 --> 00:03:06,590
而现在a的转置是一个行向量

44
00:03:06,590 --> 00:03:08,437
要注意这个细微的差别

45
00:03:08,437 --> 00:03:12,213
使用这种数据结构时
打印a转置的结果中有两个方括号

46
00:03:12,213 --> 00:03:14,460
而之前却只有一个方括号

47
00:03:14,460 --> 00:03:19,393
区别在于 这是一个真正的1乘5的矩阵

48
00:03:19,393 --> 00:03:23,481
而之前的是秩为1的数组

49
00:03:23,481 --> 00:03:28,129
并且 如果你打印a和a转置的积

50
00:03:28,129 --> 00:03:32,444
这样会得到向量的外积 对吧?

51
00:03:32,444 --> 00:03:35,795
向量的外积是一个矩阵

52
00:03:35,795 --> 00:03:40,305
下面我们更深入地了解一下刚才看到的情况

53
00:03:40,305 --> 00:03:43,185
刚才我们运行的第一个命令是这个

54
00:03:43,185 --> 00:03:47,839
它创建了这样一个数据结构

55
00:03:47,839 --> 00:03:52,930
a.shape的值就是这个奇怪的(5,)

56
00:03:52,930 --> 00:03:57,270
这称为秩为1的数组

57
00:03:57,270 --> 00:03:58,960
这是个很奇怪的数据结构

58
00:03:58,960 --> 00:04:04,000
它的行为并不总与行向量或者列向量相一致

59
00:04:04,000 --> 00:04:06,750
这使得它会带来一些不直观的影响

60
00:04:06,750 --> 00:04:10,770
所以我的建议是 当你在做编程练习时

61
00:04:10,770 --> 00:04:14,050
或者准确地说 在实现作业中的逻辑回归或神经网络时

62
00:04:14,050 --> 00:04:19,740
不要使用这种秩1为数组

63
00:04:21,020 --> 00:04:24,098
相反 如果你在每次创建数组时

64
00:04:24,098 --> 00:04:27,500
都确保使它是一个列向量

65
00:04:27,500 --> 00:04:32,360
就像这样创建5乘1的向量 或者确保它是一个行向量

66
00:04:32,360 --> 00:04:36,670
那么这些向量的行为将更容易理解

67
00:04:36,670 --> 00:04:43,115
所以这里a.shape等于(5,1)

68
00:04:43,115 --> 00:04:48,510
这实际上就是一个列向量

69
00:04:48,510 --> 00:04:53,233
因此你可以把它当成5乘1的矩阵 也就是列向量

70
00:04:53,233 --> 00:04:56,880
然后 这里a.shape的值是(1,5)

71
00:04:56,880 --> 00:05:01,000
它的行为始终和行向量一致

72
00:05:02,150 --> 00:05:06,258
所以当你需要一个向量时 可以二者择其一

73
00:05:06,258 --> 00:05:07,538
但不要用秩为1的数组

74
00:05:07,538 --> 00:05:12,061
我在编程时还经常会做这样一件事

75
00:05:12,061 --> 00:05:17,029
如果我不太确定某一个向量的维度
我通常会将其放入断言语句中

76
00:05:17,029 --> 00:05:21,720
就像在这里 用来确保a是5乘1的向量

77
00:05:21,720 --> 00:05:23,730
所以它是个列向量

78
00:05:23,730 --> 00:05:26,900
执行这些断言的成本很低

79
00:05:26,900 --> 00:05:30,250
并且还能充当代码的文档

80
00:05:30,250 --> 00:05:34,160
当你觉得需要的时候 就使用断言语句

81
00:05:34,160 --> 00:05:35,320
不要犹豫

82
00:05:35,320 --> 00:05:39,510
最后 如果出于某些原因 你得到了一个秩1为数组

83
00:05:39,510 --> 00:05:43,960
你可以用reshape来改变它的形状 a=a.reshape((5,1))

84
00:05:43,960 --> 00:05:48,900
比如使其成为(5,1)或者(1,5)的数组

85
00:05:48,900 --> 00:05:53,750
这样它就会始终表现为列向量或者行向量

86
00:05:53,750 --> 00:05:57,626
我有时会见到学生
因为这些秩为1的数组的不直观的行为

87
00:05:57,626 --> 00:06:01,119
出现一些很难找出的bug

88
00:06:01,119 --> 00:06:06,246
通过在旧代码中消除秩为1的矩阵
我觉得我的代码变得更简单了

89
00:06:06,246 --> 00:06:09,463
而且我并不觉得这样写会限制

90
00:06:09,463 --> 00:06:10,335
代码的表达

91
00:06:10,335 --> 00:06:12,469
我从来不用秩为1的数组

92
00:06:12,469 --> 00:06:17,090
要点是 为了简化代码 不要使用秩为1的数组

93
00:06:17,090 --> 00:06:19,437
始终使用n乘1的矩阵

94
00:06:19,437 --> 00:06:24,510
本质上是列向量
或者使用1乘n的矩阵 本质上是行向量

95
00:06:24,510 --> 00:06:26,599
自由使用断言语句

96
00:06:26,599 --> 00:06:29,590
来复查矩阵和数组的维度

97
00:06:29,590 --> 00:06:34,480
还有 不要怕使用reshape操作

98
00:06:34,480 --> 00:06:38,780
来确保矩阵和向量是你所需要的维度

99
00:06:38,780 --> 00:06:39,420
由此

100
00:06:39,420 --> 00:06:44,770
我希望这些建议能帮你从源头消除Python代码的bug

101
00:06:44,770 --> 00:06:48,840
也能让编程练习变得更容易