В попередньому відео я казав, що посів [broadcasting] - це ще одна методика прискорення виконання твого Python коду. В цьому відео, давай детальніше розглянемо як працює посів у Python. Давай розглянемо посів на прикладі. В цій матриці я показав кількість вуглеводних, білкових і жирових калорій, які містяться в 100г 4-ох різних продуктів. Тож, наприклад, в 100г яблук - 56 вуглеводних калорій, а білкових і жирових набагато менше. В той час як в 100г м'яса білкових калорій - 105, а жирових - 135. Тепер, скажімо, ми хочемо обчислити у % вуглеводні, білкові і жирові калорії для кожного типу їжі. Тож, наприклад, якщо ми глянемо на цей стовпець і додамо числа в ньому, то отримаємо, що 100г яблук містять 56+1,2+1,8, тобто 59 калорій. Тож у відсотках вуглеводних калорій в яблуках буде 56/59, буде 94,9%. Тож більшість калорій з яблук надходять від вуглеводів, в той час як більшість калорій з яловичини надходять з білків і жирів і т.д. Тож для обчислення нам треба додати всі 4 стовпці матриці, щоб отримати загальну кількість калорій в 100г яблук, яловичини, яєць і картоплі. Далі поділити кожен член матриці так, щоб отримати у % вуглеводні, білкові і жирові калорії для кожного з 4 типів їжі. Тож виникає питання: чи можемо ми це зробити без явного циклу for? Давай подивимось як це можна зробити. Зараз я покажу як можна перетворити, скажімо, цю матрицю розміру 3*4, матрицю A. За допомогою лише однієї строки Python коду ми просумуємо всі стовпці. Тож ми отримаємо 4 числа, що відповідають загальній кількості калорій в цих 4-ох типах їжі. В 100г цих 4-ох типів їжі. Зараз я напишу другу строку Python коду, щоб поділити кожен з 4-ох стовпців на відповідну суму. Якщо я не дуже зрозуміло описав це словами, надіюсь, зараз стане зрозуміліше коли я напишу Python код. Тож зараз ми в записнику Jupyter. Я вже написав частину коду, що заповнює матрицю A числами, які ми вже бачили. Тож натискаємо Shift+Enter і запускаємо виконання. Тож ось матриця A. А тепер додамо ще 2 строки Python коду. Спочатку обчислимо cal=A.sum(axis=0), що означає просумувати по вертикалі. Я розкажу про це детальніше дещо пізніше. І виводимо cal. Тож ми просумували по вертикалі. Тепер 59 - це загальна кількість калорій в яблуках, 239 - загальна кількість калорій в яловичині, і т.д. в яйцях і картоплі. І тепер ми можемо обчислити %: percentage=A/cal.reshape(1,4). І множимо це ще на 100, щоб отримати %. І давай виведемо percentage. Давай виконаємо. Цією командою ми беремо матрицю A і ділимо на цю матрицю розміру 1*4. І отримуємо матрицю відсотків. Якщо співставити [матриці], то для яблук (перший стовпець) 94,9% калорій припадає на вуглеводи. Давай повернемось до слайдів. Просто повторимо 2 рядки нашого коду. Ті, що ми записали в записнику Jupiter. Трохи детальніше про цей параметр. (axis=0) означає, що ми хочемо, щоб Python просумував по вертикалі. Тобто по оцій осі 0 просумувати по вертикалі. А горизонтальна вісь - це axis=1. Тобто можна присвоїти axis 1, 
щоб просумувати горизонтально, а не вертикально. А ось ця команда - це приклад Python посіву. Тут береться матриця A, матриця розміру 3*4, і ділиться на матрицю розміру 1*4. І, технічно, після першого рядка коду cal, змінна cal, вже є матрицею розміру 1*4. Тож, технічно, не потрібно викликати reshape() знову, це вже трохи зайве. Проте, коли я пишу Python код, я не завжди впевнений який розмір у матриці, тож я часто викликаю команду reshape(), щоб пересвідчитись, 
що використовується правильний вектор-стовпець, вектор-рядок чи щось інше. Команда reshape виконується визначений час. Це операція першого порядку, тож її виконання дуже дешеве. Тож не бійся використовувати команду reshape, 
щоб пересвідчитись, що твої матриці потрібного розміру. Тепер давай більш детально пояснимо як працюють операції такого типу. Ми маємо матрицю 3*4, яка ділиться на матрицю 1*4. Тож як ми можемо поділити матрицю 3*4 на матрицю 1*4 або вектор 1*4? Давай розглянемо ще кілька прикладів посіву. Якщо ми візьмемо вектор 4*1 і додамо його до числа, то Python візьме це число і автоматично розширить його до вектора теж 1*4. Ось так. Тож додавання до вектора [1, 2, 3, 4] числа 100, замінить 100 на вектор справа. Тобто додасть 100 до кожного елементу. 
І, дійсно, ми використовували цю форму посіву коли нашою константою був параметр b в попередньому відео. І ця форма посіву працює і з векторами-стовпцями, і з векторами-рядками. І, фактично, цю ж форму посіву ми використовували раніше до константи, коли доданком вектора був параметр b ЛР. Інший приклад. Скажімо, ми маємо матрицю 2*3 і додаємо до неї матрицю 1*n. Тож в загальному випадку, якщо є матриця m*n і до неї додається матриця 1*n, То Python скопіює додавану матрицю m разів, що перетворити її на m*n. Тож оця матриця 1*3 буде скопійована 2 рази (в цьому прикладі), 
щоб бути перетвореною на матрицю 2*3. Тож її можна буде додати і отримати оцей результат справа. Так? Тож ми додаємо 100 до першого стовпця, додаємо 200 до другого стовпця і додаємо 300 до третього. Ось, по суті, те, що ми зробили на попередньому слайді. Просто ми виконували операцію ділення, а не додавання. І ще один, останній приклад. Якщо ми маємо матрицю m*n і додаємо її до вектора m*1, матриці m*1, то вона буде скопійована n разів по горизонталі. Ми отримаємо матрицю m*n. Тож, уявімо, що ми копіюємо її 3 рази по горизонталі і додаємо ось цю. Тож ми отримаємо ось це. Тобто додаємо 100 до першого рядка і 200 - до другого. Ось загальний принцип посіву в Python. Якщо ми маємо матриця m*n і ми додаємо, або віднімаємо, або множимо, або ділимо на матрицю 1*n, то це буде скопійовано m разів до отримання матриці m*n. А потім буде виконано додавання, віднімання, множення чи ділення поелементно. Натомість, якщо ми хочемо додати, відняти, помножити чи поділити на матрицю m*1, то це теж буде скопійовано n разів і перетворено на матрицю m*n, 
і тоді виконано операцію поелементно. Одна з форм посіву, це коли ми маємо матрицю m*1, тобто вектор-стовпець, скажімо, [1, 2, 3] і хочемо додати відняти, помножити чи поділити на дійсне число, або матрицю 1*1. Тож ось це +100. А в результаті ми отримаємо скопійоване m разів це дійсне число 
(поки не створиться ще одна матриця m*1). І потім виконаємо операцію додавання (в цьому прикладі) поелементно. Аналогічно відбувається для векторів-рядків. Повна загальна версія посіву може робити ще дещо. Якщо тобі цікаво, відкрий документацію по NumPy і пошукай там посів [broadcasting]. Там є більш загальне визначення посіву. Проте, використані на слайді форми - основні з тих, які можуть знадобитись при реалізації нейронної мережі (НМ). Перед тим як закінчити, додам останній коментар для тих, хто програмував в Matlab або Octave. 
Якщо ти використовував/ла в Matlab або Octave функцію bsxfun, то в програмуванні НМ вона виконує щось схоже. 
Не повністю те саме, але часто використовується для тих же цілей, що й посів в Python. Проте, це лише для дуже просунутих Matlab і Octave користувачів. Якщо ти про це не чув/ла, не переймайся. Це не потрібно знати, якщо пишеш код НМ на Python. Тож ось що таке посів в Python. Надіюсь, коли ти будеш виконувати домашнє завдання, 
посів дозволить тобі не лише пришвидшити код, але й допоможе скоротити кількість рядків коду. Перед тим як ти почнеш виконувати програмувальну вправу, 
хочу поділитись з тобою ще одним набором ідей, деякими хитрощами, які, як я виявив, зменшують кількість помилок в моєму Python коді і, надіюсь, допоможуть тобі також. Тож давай поговоримо про це в наступному відео.