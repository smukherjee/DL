В попередньому відео ти бачив/ла кілька прикладів 
як векторизація, використовуючи вбудовані функції і уникаючи явних циклів for, дозволяє значно пришвидшити код. Давай розглянемо ще кілька прикладів. Практичне правило, яке варто запам'ятати, це коли ми програмуємо нейронну мережу (НМ) або логістичну регресію (ЛР) завжди, коли це можливо, треба уникати явних циклів for. Звичайно, взагалі не використовувати цикл for - не завжди можливо. Проте, використовуючи вбудовані функції або інші способи необхідних обчислень, це часто буде швидше ніж циклом for. Давай розглянемо приклад. Якщо ми хочемо обчислити вектор u, що є добутком матриці A і іншого вектору v, то за визначенням множення матриць наш вектор uᵢ= сумі по j для Aᵢⱼvⱼ. Правильно? Так ми визначаємо uᵢ. Невекторизована реалізація цього буде u=np.zeros(n, 1) u=np.zeros(n, 1). І далі "for i" і так далі, "for j" і так далі. Так? І далі u[i]+=A[i][j]*v[j]. Тож ми маємо 2 цикли for, що проходять для i та j. Тож це - невекторизована версія. Векторизована реалізація буде u=np.dot(A, v). Імплементація справа (векторизована версія) позбувається цих 2-ох циклів for і виконується набагато швидше. Давай розглянемо ще один приклад. Скажімо, ми вже маємо в пам'яті вектор v і хочемо застосувати експоненційну операцію для кожного елементу цього вектора. Тож ми обчислюємо u= вектор, 
що складається з e в степені v₁, e в степені v₂ і так далі до e в степені vₙ. Тож це буде невекторизована реалізація, де ми спочатку ініціалізуємо u як нульовий вектор, далі маємо цикл for, що обчислює 1 елемент за 1 прохід. Проте, виявляється, що Python і NumPy 
мають багато вбудованих функцій, що дозволяють обчислювати ці вектори, викликавши всього одну функцію. Тож, щоб реалізувати це, я б зробив "import NumPy as np", а потім просто викликав "u=np.exp(v)". 
Відміть, що в той час як в попередньому випадку ми мали явний цикл for з лише одним рядком коду, то тут вектор v використовується як вхідний, а u - як результуючий. Ми позбулись явного циклу for і реалізація справа буде набагато швидшою ніж та, що з явним циклом for. Насправді, бібліотека NumPy має багато інших векторних функцій. Тож, "np.log(v)" обчислює логарифми поелементно, "np.abs(v)" обчислює абсолютні величини, "np.maximum(v, 0)" обчислює максимуми поелементно (можна обчислити максимуми відносно кожного елемента і 0), "v**2" підносить в квадрат поелементно кожен елемент v. "1/v" обчислює поелементно обернені числа і т.д. Тож, коли тобі хочеться використати цикл for - пошукай. Можливо, в NumPy є вбудована функція, яка зробить це без циклу for. Тож давай візьмемо всі ці знання і спробуємо застосувати їх до нашої ЛР для реалізації Градієнтного спуску і подивимось чи можемо ми позбутись одного-двох циклів for, 
які в нас є. Тож ось наш код для обчислення похідних для ЛР. Ми маємо 2 цикли for. Один - ось тут вгорі, а інший - ось тут. Так? Тож в нашому прикладі ми мали nₓ=2, але, якщо ми маємо більше ознак ніж просто 2, то нам потрібен цикл for для dw₁, dw₂, dw₃ і т.д. Тобто ми б мали тут "for j=1..nₓ" і коригували б dwⱼ - "dwⱼ+=...". Так? Тож ми хочемо позбутися цього другого циклу for. Ось що ми зробимо з цією лінією. Тож замість явної ініціалізації dw₁, dw₂ і т.д. в 0, ми позбудемось цього і запишемо dw як вектор. Тож ініціалізуємо "dw=np.zeros(nₓ, 1)" як вектор розмірністю nₓ*1. А тут, замість оцього циклу for для окремих компонентів, ми використаємо векторну операцію dw+= x⁽ⁱ⁾*dz⁽ⁱ⁾. І, нарешті, замість оцього запишемо dw/=m. Тож тепер замість 2-ох ми маємо всього 1 цикл for. У нас залишається оцей 1 цикл for 
для окремого тренувального зразка. Тож, надіюсь, це відео дало тобі розуміння суті векторизації і що, позбувшись 1-ого циклу for, твій код буде вже працювати швидше. Проте, виявляється, що ми можемо зробити ще краще. Тож у наступному відео ми поговоримо як ще векторизувати ЛР і ти виявиш несподіваний результат, -
що, навіть, взагалі без використання циклів for (без циклу for для тренувальних зразків) ти зможеш написати код, щоб обробити весь тренувальний набір, практично одномоментно. Тож давай подивимось на це в наступному відео.