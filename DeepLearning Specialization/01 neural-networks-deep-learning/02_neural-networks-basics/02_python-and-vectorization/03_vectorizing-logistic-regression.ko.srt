1
00:00:00,860 --> 00:00:05,760
vectorization이 여러분의 코드 속도를 어떻게 높힐 수 있는지 이야기 했었는데요, 

2
00:00:05,760 --> 00:00:08,160
이번 비디오에서는 로지스틱 회귀분석 도입을 어떻게 vectorize

3
00:00:08,160 --> 00:00:10,545
할 수 있는지 이야기 해보겠습니다.

4
00:00:10,545 --> 00:00:12,960
전체 트레이닝 세트를 처리할 수 있게 말이죠. 

5
00:00:12,960 --> 00:00:15,930
기울기 강하의 single iteration을 도입하는 것이죠 

6
00:00:15,930 --> 00:00:22,330
전체 트레이닝 세트에 대해서, for loop의 사용없이 말이죠. 

7
00:00:22,330 --> 00:00:24,039
이 기술이 매우 기대됩니다.

8
00:00:24,039 --> 00:00:26,670
나중에 신경망에서 이야기할텐데요, 

9
00:00:26,670 --> 00:00:30,050
하나의 for loop를 이용해서 말이죠. 

10
00:00:30,050 --> 00:00:35,965
시작해보겠습니다. 로지스틱 회귀분석의 전 방향전파 단계를 먼저 보겠습니다.

11
00:00:35,965 --> 00:00:37,860
m 트레이닝 예시가 있는 경우, 

12
00:00:37,860 --> 00:00:40,605
첫번째 예시에 대해 예측하자면, 

13
00:00:40,605 --> 00:00:42,105
이것을 산출해야하는데요, 

14
00:00:42,105 --> 00:00:45,480
z를 산출합니다. 여기 이 익숙한 공식을 써서 말이죠. 

15
00:00:45,480 --> 00:00:47,370
그리고 activation을 계산하고, 

16
00:00:47,370 --> 00:00:49,485
첫번째 예시의 ŷ 을 계산하고, 

17
00:00:49,485 --> 00:00:52,705
두번째 트레이닝 예시에 대해 예측값을 구하고, 

18
00:00:52,705 --> 00:00:54,405
이것을 계산해야되죠, 

19
00:00:54,405 --> 00:00:57,085
그 다음에 세번째 예시에 대해 예측값을 구합니다.

20
00:00:57,085 --> 00:00:59,045
그리고 이 값을 계산해야죠, 등등.

21
00:00:59,045 --> 00:01:01,020
이것을 m번 진행해야 할텐데요, 

22
00:01:01,020 --> 00:01:03,855
여러분이 m 트레이닝 예시가 있는 경우 말이죠.

23
00:01:03,855 --> 00:01:08,250
여러분이 전 방향전파 단계를 실행하기 위해서는, 

24
00:01:08,250 --> 00:01:13,435
m 트레이닝 예시에 대해서 예측값을 산출해야 합니다.

25
00:01:13,435 --> 00:01:14,865
진행하는 방법이 있는데요

26
00:01:14,865 --> 00:01:17,925
explicit for loop 없이도 말이죠. 

27
00:01:17,925 --> 00:01:20,450
어떻게 하는지 보겠습니다.

28
00:01:20,450 --> 00:01:26,455
첫번째로, 대문자 X 매트릭스를 트레이닝 입력값으로 정의했었는데요, 

29
00:01:26,455 --> 00:01:30,895
이 값들을 줄별로 쌓았었습니다.

30
00:01:30,895 --> 00:01:33,810
이것은 매트릭스인데요, 

31
00:01:33,810 --> 00:01:38,425
이것은 (nx, m) 매트릭스입니다.

32
00:01:38,425 --> 00:01:41,885
이것은 파이썬 넘파이 모양으로 적고 있습니다.

33
00:01:41,885 --> 00:01:50,350
이것은 x가 nx, m 다이멘션의 매트릭스라는 것입니다.

34
00:01:50,350 --> 00:01:54,670
첫번째로 제가 하고 싶은 것은 z1, z2, z3를 어떻게 계산하는지 

35
00:01:54,670 --> 00:01:56,512
보여주는 것입니다.

36
00:01:56,512 --> 00:01:58,665
한번에 말이죠.

37
00:01:58,665 --> 00:02:01,195
그것도 한줄의 코드로 말이죠.

38
00:02:01,195 --> 00:02:06,930
저는 1 x m 매트릭스는 

39
00:02:06,930 --> 00:02:13,100
만들건데요, 이것은 가로 벡터인데요, z1, 

40
00:02:13,100 --> 00:02:15,405
z2 등등을 계산할 것입니다.

41
00:02:15,405 --> 00:02:18,480
zm 까지 말이죠, 한번에 계산합니다.

42
00:02:18,480 --> 00:02:22,175
이것은 w transpose 대문자 X 매트릭스

43
00:02:22,175 --> 00:02:29,225
더하기 벡터 b, b등으로 표현할 

44
00:02:29,225 --> 00:02:31,040
수 있습니다.

45
00:02:31,040 --> 00:02:33,315
b는, 이것은 

46
00:02:33,315 --> 00:02:34,480
즉, 여기 b, b, b, b, 는 

47
00:02:34,480 --> 00:02:38,980
1 x m 벡터입니다.

48
00:02:38,980 --> 00:02:46,725
또는 1 x m 매트릭스입니다. 또는 m차원의 가로 벡터이기도 하죠.

49
00:02:46,725 --> 00:02:50,495
여러분이 얼마나 매트릭스 곱셈에 익숙한지에 따라서, 

50
00:02:50,495 --> 00:02:56,300
w transpose x1, x2 등등 

51
00:02:56,300 --> 00:02:58,760
xm 까지 

52
00:02:58,760 --> 00:03:05,755
w transpose 가 가로 벡터인 것을 확인할 수 있을 것입니다.

53
00:03:05,755 --> 00:03:10,655
그러면 여기 w transpose는 이와 같이 행 벡터가 될텐데요, 

54
00:03:10,655 --> 00:03:18,614
그리고 여기 첫번째 항은 w transpose x1, 

55
00:03:18,614 --> 00:03:22,970
w transpose x2, 그리고 등등... 

56
00:03:22,970 --> 00:03:29,840
w tanspose xm 으로 계산될 것입니다. 그 다름에, 
여기 두번째b항을 더합니다.

57
00:03:29,840 --> 00:03:30,960
b, b, b등등 과 같이 말이죠. 

58
00:03:30,960 --> 00:03:33,565
그리하여, 각각의 element에 b를 더하게 되는 것이죠. 

59
00:03:33,565 --> 00:03:37,650
그렇게 하면 또 하나의 1 x m 벡터가 남게되는데요, 

60
00:03:37,650 --> 00:03:38,955
이것은 첫번째 element이고 

61
00:03:38,955 --> 00:03:40,590
이것이 두번째 element이고, 

62
00:03:40,590 --> 00:03:42,810
이것은 n번째 element 입니다.

63
00:03:42,810 --> 00:03:45,605
그리고 여기 정의를 보면, 

64
00:03:45,605 --> 00:03:51,250
첫번째 element는 정확히 Z1의 정의입니다.

65
00:03:51,250 --> 00:03:57,305
그리고 두번째 element는 정확히 Z2의 정의이구요, 

66
00:03:57,305 --> 00:04:00,035
그러면 X값을 얻은 것과 같이, 

67
00:04:00,035 --> 00:04:02,870
여러분의 트레이닝 예시 를 가지고 

68
00:04:02,870 --> 00:04:07,400
쌓아올린 것 처럼, 가로로 쌓은 거처럼 말이죠.

69
00:04:07,400 --> 00:04:11,069
여기 대문자 Z를 정의할텐데요, 

70
00:04:11,069 --> 00:04:16,385
소문자 z들을 가지고 가로로 쌓아올리는 것입니다.

71
00:04:16,385 --> 00:04:21,080
그리고 다른 트레이닝 예시에 대해서 소문자 x를 쌓는 경우, 

72
00:04:21,080 --> 00:04:24,350
가로로 쌓으면 이런 대문자 X 변수를 갖게되는데요, 

73
00:04:24,350 --> 00:04:27,420
여기 소문자 z 변수를 가지고 

74
00:04:27,420 --> 00:04:28,805
가로로 쌓는 것과 같이 말이죠. 

75
00:04:28,805 --> 00:04:34,050
여기 대문자 Z로 표현한 변수를 갖게 됩니다.

76
00:04:34,050 --> 00:04:37,400
이것을 도입하기 위해서는

77
00:04:37,400 --> 00:04:45,773
넘파이 명령은 대문자 Z = np 점 w 점 T입니다.

78
00:04:45,773 --> 00:04:51,095
이것은 w transpose x 그리고 더하기 b 입니다.

79
00:04:51,095 --> 00:04:53,645
파이썬에서는 미묘한 부분이 있는데요, 

80
00:04:53,645 --> 00:04:59,405
여기서 b는 실수를 나타내는데요, 만약 1 x 1 매트릭스인 경우, 

81
00:04:59,405 --> 00:05:01,330
그냥 실수를 나타냅니다. 

82
00:05:01,330 --> 00:05:06,230
하지만 여기 벡터에 더하는 경우엔 

83
00:05:06,230 --> 00:05:13,235
파이썬은 자동으로 이 b라는 실수를 가지고 여기 1 X m 줄 벡터에 확장시킵니다.

84
00:05:13,235 --> 00:05:16,490
이 운영이 조금 이해하기 힘든 경우엔, 

85
00:05:16,490 --> 00:05:20,120
이것은 파이썬에서 broadcasting이라고 합니다.

86
00:05:20,120 --> 00:05:22,210
아직은 걱정 안하셔도 됩니다. 

87
00:05:22,210 --> 00:05:25,760
나중에 비디오 강의에서 이야기하겠습니다.

88
00:05:25,760 --> 00:05:29,180
이해하셔야 할 부분은, 한줄의 코드로, 여기 있는 코드로, 

89
00:05:29,180 --> 00:05:33,290
대문자 Z를 계산하고, 이 값은 

90
00:05:33,290 --> 00:05:37,698
1Xm 매트릭스인데요, 모든 소문자 z의 값을 내포하고 있습니다.

91
00:05:37,698 --> 00:05:41,200
소문자 z1에서 zm 까지 말이죠. 

92
00:05:41,200 --> 00:05:46,255
이것이 z에 대한 내용이였는데요, 그럼 a는 어떨까요.

93
00:05:46,255 --> 00:05:48,260
다음으로는, 

94
00:05:48,260 --> 00:05:52,685
a1을 계산하는 방법을 보겠습니다.

95
00:05:52,685 --> 00:05:57,220
a2도 보고, am까지 알아보겠습니다.

96
00:05:57,220 --> 00:05:58,700
모두 한번에 말이죠. 

97
00:05:58,700 --> 00:06:03,350
그리고 소문자 x들을 쌓아서 나온

98
00:06:03,350 --> 00:06:08,870
대문자 X처럼, 소문자 z를 가로로 쌓아서 대문자 Z가 나왔는데요, 

99
00:06:08,870 --> 00:06:10,810
소문자 a를 쌓는 경우에는, 

100
00:06:10,810 --> 00:06:12,470
새로운 변수가 결과값으로 나올 것입니다.

101
00:06:12,470 --> 00:06:15,200
새로운 변수가 결과값으로 나올 것입니다.

102
00:06:15,200 --> 00:06:18,075
프로그램 연습 과제에서, 

103
00:06:18,075 --> 00:06:22,790
vector valued sigmoid 함수를 도입하는 방법을 보겠습니다.

104
00:06:22,790 --> 00:06:24,480
그러면 여기 시그모이드 함수는 

105
00:06:24,480 --> 00:06:32,380
대문자 Z를 변수로 입력하고, 효율적으로 대문자 A값을 산출하게 됩니다.

106
00:06:32,380 --> 00:06:36,620
이것에 대한 상세내용은 프로그램 과제에서 볼 것입니다.

107
00:06:36,620 --> 00:06:38,110
복습하자면, 

108
00:06:38,110 --> 00:06:42,655
이번 슬라이드에서 본 것은, 소문자 z와 소문자a를 계산하는데
m 트레이닝 샘플에 대해서

109
00:06:42,655 --> 00:06:47,515
하나하나씩 loop over할 필요없이, 

110
00:06:47,515 --> 00:06:52,090
이것과 같은 한줄의 코드를 도입하면 된다는 것입니다.

111
00:06:52,090 --> 00:06:54,290
모든 z의 값들을 한번에 산출하기 위해서 말이죠. 

112
00:06:54,290 --> 00:06:57,100
그런 다음, 이런 한줄의 코드는 

113
00:06:57,100 --> 00:06:59,260
소문자 시그마의 적합한 도입을 통해

114
00:06:59,260 --> 00:07:04,115
소문자 a를 모두 한꺼번에 산출할 수 있도록 해줍니다.

115
00:07:04,115 --> 00:07:05,965
이렇게 하여 m 개의 트레이닝 예시에 대한 

116
00:07:05,965 --> 00:07:07,948
전 방향전파 에서의 

117
00:07:07,948 --> 00:07:11,560
vectorized 된 도입을 한꺼번에 하는 방법을 알아봤습니다.

118
00:07:11,560 --> 00:07:13,985
요약하자면, 방금 본 것은 

119
00:07:13,985 --> 00:07:18,100
vectorization을 사용하여 효율적으로 모든 activation을 산출하는 방법을 알아냈습니다.

120
00:07:18,100 --> 00:07:21,700
즉, 소문자 a를 한번에 계산하는 방법을 말이죠. 

121
00:07:21,700 --> 00:07:24,860
다음으로는, vectorization을 사용해서

122
00:07:24,860 --> 00:07:27,910
후 방향전파 효율적으로 산출하는 방법을 알아보겠습니다.

123
00:07:27,910 --> 00:07:29,650
기울기를 계산하기 위해서 말이죠.

124
00:07:29,650 --> 00:07:32,000
이것을 어떻게 하는지 다음 비디오에서 보겠습니다.